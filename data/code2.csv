
 LOGGER.debug("Mode LINK");
 VBox contextPanel = new VBox(10);
 for (int j = 0; j < markers.length; j++) {
 BibEntry firstEntry = entries.get(0);
        btnConnect.disableProperty().bind(viewModel.formValidation().validProperty().not());
        }
 ExternalFileType found = null;
        mainStage.showingProperty().addListener(new ChangeListener<Boolean>() {
 BackgroundTask
                    defTypes.remove(found);
 return;
        m_modifiedSubtree.clear();
 public void toggle(SidePaneType type) {
 @FunctionalInterface
 TABLE_ICONS.put(StandardField.PDF, icon);
 List<ExternalFileType> types = new ArrayList<>(getDefaultExternalFileTypes());
 LOGGER.info("Cannot rename string '" + mem + "' to '" + disk + "' because the name "
 public Optional<ExternalFileType> getExternalFileTypeByName(String name) {
        database.getDatabase().insertEntries(entries);
public class NewSubLibraryAction extends SimpleCommand {
 private void startSearch() {
 public boolean isGeneratedNameSameAsOriginal() {
                    fieldChanges.add(new FieldChangeViewModel(field, memEntry, tmpEntry, mem.orElse(null), tmp.get(), disk.get()));
public class JabRefExecutorService {
        getOpenDatabaseAction().openFile(file, true);
 public void requestFocus(Field fieldName) {
 public void setPasteActionHandler(PasteActionHandler handler) {
 private void onSelectedGroupChanged(ObservableList<GroupNodeViewModel> newValue) {
 for (BibEntry entry : pr.getDatabase().getEntries()) {
 private GridPane getSelectorPanel() {
 private void onActiveDatabaseChanged(Optional<BibDatabaseContext> newDatabase) {
 String[] cmd = (application != null) && !application.isEmpty() ? new String[] {"/usr/bin/open", "-a",
        keywordGroupSearchField.setText(prefs.get(JabRefPreferences.GROUPS_DEFAULT_FIELD));
                    clonedEntry.getField(StandardField.CROSSREF).ifPresent(crossref -> {
 SpecialFieldViewModel printedViewModel = new SpecialFieldViewModel(SpecialField.PRINTED, undoManager);
 private String[] getStringArrayRepresentation(ExternalFileType type) {
 String newText = abbreviation.getName();
 public void writeOrCreate() throws IOException {
 private static Image getImageFX(String name) {
            root.setSelected(true);
 GlobalBibtexKeyPattern keypatterns = getKeyPatternAsGlobalBibtexKeyPattern();
 TABLE_ICONS.put(fileType.getField(), icon);
 public static Supplier<List<MenuItem>> getNameMenu(final TextInputControl textInput) {
                        uniquefiers.put(key, String.valueOf((char) uniq));
 for (Iterator<Path> iterator = filesToOpen.iterator(); iterator.hasNext();) {
 public void automatedImport(List<String> filenames) {
 if ((directory == null) || !directory.exists() || !directory.isDirectory()) {
        stateManager.activeDatabaseProperty().bind(
 QUALITY_ASSURED(MaterialDesignIcon.CERTIFICATE), /*css: certificate */
 TABLE_ICONS.put(StandardField.FILE, icon);
 if (filenames.isEmpty()) {
        addToGroups(entries, stateManager.getSelectedGroup(database));
 private final int m_subtreeRootChildCount;
 public void searchButtonClicked() {
 // FIXME: prefix can be removed?!
 public boolean delete() {
 switch (ControlHelper.getDroppingMouseLocation(row, event)) {
 if (panel == null) {
public class ExporterViewModel {
class BibtexKeyPatternPrefTab extends BibtexKeyPatternPanel implements PreferencesTab {
        xSet.insert(xImpLoader.activate("com.sun.star.comp.loader.JavaLoader", null, null, null));
 final Timer searchTask = FxTimer.create(Duration.ofMillis(400), () -> {
 VBox explicitPanel = createOptionsExplicitGroup();
public class ThemeLoader {
 BackgroundTask
        button.graphicProperty().unbind();
                }
public class GuiAppender extends AbstractAppender {
 switch (mouseLocation) {
 public static void openFolderAndSelectFile(Path fileLink) throws IOException {
 private static Map<String, String> readIconThemeFile(URL url, String prefix) {
public class UndoableRemoveEntry extends AbstractUndoableJabRefEdit {
 boolean isModifiedLocally = (DuplicateCheck.compareEntriesStrictly(memEntry, tmpEntry) <= 1);
 if (Globals.prefs == null) {
 public BibEntry getMergeEntry() {
 public void focus() {
 public abstract boolean shouldShow(BibEntry entry);
            basePanel.getUndoManager().registerListener(new UndoRedoEventManager());
 TABLE_ICONS.put(StandardField.EPRINT, icon);
 void operationCompleted();
 public UndoableAddOrRemoveGroup(GroupTreeNodeViewModel groupsRoot,
 try {
        xSet.insert(xImpLoader.activate("com.sun.star.comp.connections.Acceptor", null, null, null));
    }
 List<Integer> num = new ArrayList<>(keys.length);
 ParserResult pr = importer.get().importDatabase(filename, Globals.prefs.getDefaultEncoding());
 XComponentContext xContext = org.jabref.gui.openoffice.Bootstrap.bootstrap(loader);
 private final int m_editType;
 HBox fontBox = new HBox();
 LOGGER.debug("Mode MOVE");
public class EntryEditor extends BorderPane {
        setupKeyBindings(keyBindingRepository);
 return new ReadOnlyStringWrapper("");
 Exporter defaultChoice = exporters.stream()
 int uniq = 'a';
public class ViewModelTableRowFactory<S> implements Callback<TableView<S>, TableRow<S>> {
 OS.NEWLINE = Globals.prefs.get(JabRefPreferences.NEWLINE);
 for (String key : cited) {
 String sConnect = "uno:socket,host=localhost,port=2083" + ";urp;StarOffice.ComponentContext";
 protected static String processPreview(List<String> citations) {
            populateSubMenu(items, "IEEETran", IEEETranEntryTypeDefinitions.ALL, entry, undoManager);
            visibleComponents.sort(new PreferredIndexSort());
 List<String> getRestartWarnings();
 ParserResult parserResult = OpenDatabase.loadDatabase(file.toFile(),
 List<String> dir = databaseContext.getFileDirectories(field, Globals.prefs.getFilePreferences());
        annotationList.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
 public static XComponentContext createInitialComponentContext(Map<String, Object> context_entries) throws Exception {
 switch (m_editType) {
 private void generateKeys(List<BibEntry> entries) {
public class HelpAction extends SimpleCommand {
 List<LinkedFile> filesToSerialize = files.stream()
 public <T> void putValue(Class<T> type, T value) {
 XComponentContext xLocalContext = createInitialComponentContext((Map<String, Object>) null);
        anySelectedEntriesMatched.invalidate();
 private Optional<BibEntry> findInternalDuplicate(BibEntry entry) {
 if (!toRemove.isEmpty()) {
 for (Map.Entry<String, Set<Field>> tab : entryEditorPreferences.getEntryEditorTabList().entrySet()) {
public final class EntryEditorTabList {
public class ExternalFileTypes {
 boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;
 boolean success = saveDatabase(targetPath, false,
public interface PushToApplication {
public class OpenHyperlinksInExternalBrowser implements ChangeListener<Worker.State>, EventListener {
public class ViewModelTreeTableCellFactory<S> implements Callback<TreeTableColumn<S, S>, TreeTableCell<S, S>> {
 public static URL getIconUrl(String name) {
        browser.addEventFilter(javafx.scene.input.MouseEvent.ANY, javafx.scene.input.MouseEvent::consume);
            correctEntries = entries;
 for (Observable observable : newEntry.getObservables()) {
 public SuggestionProviders() {
public class NoSelectionModel<T> extends MultipleSelectionModel<T> {
 public void moveDown(SidePaneComponent comp) {
        }
 Set<Field> jointFields = new TreeSet<>(Comparator.comparing(Field::getName));
public class RelatedArticlesTab extends EntryEditorTab {
 GroupTreeNode node = newParent.getChildAt(newChildIndex).get(); //TODO: Null
public class TemporalAccessorPicker extends DatePicker {
public abstract class SimpleCommand extends CommandBase {
 NamedCompound ce = new NamedCompound(Localization.lang("Merge entries"));
 Optional<String> valInNewField = entry.getField(newField);
    }
public class AbbreviationViewModel {
    }
        }
public enum DroppingMouseLocation {
 @Override
 this.frame = frame;
public class UnlinkedFilesCrawler extends BackgroundTask<CheckBoxTreeItem<FileNodeWrapper>> {
            fields.addAll(entry.getFields());

 public List<BasePanel> getBasePanelList() {
        entriesSorted = new SortedList<>(entriesFiltered);
 private ScrollPane getRelatedArticleInfo(List<BibEntry> list, MrDLibFetcher fetcher) {
        base.removeString(string.getId());
 public List<String> refreshCiteMarkers(List<BibDatabase> databases, OOBibStyle style)
        }
 GroupTreeNode newNode = m_subtreeBackup.copySubtree();
 private void openFile(Path filePath) {
 Class<?> clazz = Class.forName("javafx.scene.control.TableUtil");
            }
public class ContentSelectorSuggestionProvider implements AutoCompleteSuggestionProvider<String> {
 try {
        setPrefHeight(Double.POSITIVE_INFINITY);
        tearDownJabRef(filenames);
 try {
 XNamed xNamed = UnoRuntime.queryInterface(XNamed.class, bookmark);
 @Override
    }
 public static final String FRAME_TITLE = "JabRef";
 protected boolean couldNotConnect; // Set to true in case the tunnel to the program (if one is used) does not operate
            row.contextMenuProperty().bind(
public class CitationStyleToClipboardWorker {
public class CustomExternalFileType implements ExternalFileType {
 if (!sb.toString().trim().isEmpty()) {
 catch (IOException excep) {
public class UnlinkedPDFFileFilter implements FileFilter {
 List<BibEntry> toRemove = new ArrayList<>(entries.size());
public enum AutoCompleteFirstNameMode {
 private List<Integer> findCitedEntryIndex(String citRefName, List<String> keys) {
    }
public class ManageJournalAbbreviationsViewModel extends AbstractViewModel {
 public void show(SidePaneType type) {
 if (bibtexResult == null) {
public class OpenDatabaseAction extends SimpleCommand {
 TABLE_ICONS.put(SpecialField.PRIORITY, icon);
 if (!identicalTypes && !typeRadioButtons.isEmpty() && typeRadioButtons.get(0).isSelected()) {
 if (this.stringConverter == null) {
 public void installCss(Scene scene, JabRefPreferences preferences) {
        getGroupNode().moveTo(target.getGroupNode());
 return pathname -> true;
 private final Version installedVersion;
 if (strippedLink.substring(strippedLinkIndex + 1).indexOf('/') >= 1) {
 public void setupAllTables() {
            notifyNewSelectedFile(currentFile);
                }
 Platform.runLater(() -> {
 String[] keys = citeMatcher.group(2).split(",");
 String howToReproduce = "Steps to reproduce:\n\n1. ...\n2. ...\n3. ...";
                        pr.getDatabase().clearSharedDatabaseID();
 ENTRY_EDITOR_PREVIOUS_PANEL_2("Entry editor, previous panel 2", Localization.lang("Entry editor, previous panel 2"), "ctrl+MINUS", KeyBindingCategory.VIEW),
            stateManager.activeSearchQueryProperty().set(newBasePanel.getCurrentSearchQuery());
 StackPane helpButtonContainer = new StackPane();
 private final int m_subtreeRootChildCount;
 private static UndoableEdit massRenameField(Collection<BibEntry> entries, Field field, Field newField,
 public static final int REMOVE_NODE_KEEP_CHILDREN = 1;
 public boolean dragDropped(ListProperty<PreviewLayout> targetList, Dragboard dragboard) {
 FETCH_FULLTEXT(MaterialDesignIcon.MAGNIFY), // TODO: use WEB_SEARCH instead as soon as it is available
 @Override
 public String getDefaultKeyBinding() {
            dialogService.notify(Localization.lang("Added group \"%0\".", group.getName()));
 new LatexFieldFormatter(fieldFormatterPreferences).format(newValue, fieldName);
 ControlsFxVisualizer visualizer = new ControlsFxVisualizer();
 if (nameChange) {
 if (!result.getToAdd().isEmpty()) {
            markingContent = markingContent.replaceAll("-" + NEWLINE, "");
 public <T> BackgroundTask<T> thenRun(Function<V, T> nextOperation) {
public class CheckForNewEntryTypesAction implements GUIPostOpenAction {
 private void openTheFile(Path file, boolean raisePanel) {
        entryEditorTabs.add(new OtherFieldsTab(databaseContext, panel.getSuggestionProviders(), undoManager,
        entriesList = databaseContext.getDatabase().getEntries();
public class FindFullTextAction extends SimpleCommand {
public class CustomizeExternalFileTypesDialog extends BaseDialog<Void> {
 ToggleGroup groupType = new ToggleGroup();
public abstract class BackgroundTask<V> {
 protected abstract void bindToEntry(BibEntry entry);
 Object context = xUrlResolver.resolve(sConnect);
 if (dataBaseNumber >= 0) {
 new PersistenceVisualStateTable(this, Globals.prefs);
public class AutosaveUIManager {
 UpdateField.setAutomaticFields(entries, updateFieldPreferences);
 PreviewPreferences previewPreferences = Globals.prefs.getPreviewPreferences();
 XFootnote footer = UnoRuntime.queryInterface(XFootnote.class, range.getText());
 private static void ensureCorrectJavaVersion() {
        typeSubscription = EasyBind.subscribe(this.entry.typeProperty(), type -> {
 continue;
 public static Optional<String> getSuffix(final String link) {
 return Optional.empty();
 private final List<String> columnHeadings = Arrays.asList(Localization.lang("Field"),
 XTextContent xTextContent = UnoRuntime.queryInterface(XTextContent.class, bookmark);
 public void editAbbreviation(String name, String abbreviation) {
 private void updateMergedEntry() {
            panel.setSaving(false);
 if (exporter != null) {
            } else if (answer == DuplicateResolverDialog.DuplicateResolverResult.KEEP_MERGE) {
public class UndoableInsertEntry extends AbstractUndoableJabRefEdit {
 public void storeSettings() {
 protected abstract boolean isMatch(T suggestion, ISuggestionRequest request);
 final boolean namesNatbib = Globals.prefs.getBoolean(JabRefPreferences.NAMES_NATBIB); //MK:
 public void insertEntry(List<BibEntry> entries, BibDatabase database,
 MetaData metaData = panel.getBibDatabaseContext().getMetaData();
            cleanUpMovePDF.setDisable(true);
 Field privatePopup = AutoCompletionBinding.class.getDeclaredField("autoCompletionPopup");
 if (newGroups.getGroup() instanceof AllEntriesGroup) {
class OOBibBase {
 if (!handleMultipleAppInstances(arguments) || argumentProcessor.shouldShutDown()) {
 public void about() {
 public JabRefIcon getTypeIcon() {
            selectedFieldName.ifPresent(this::requestFocus);
 public abstract int getPageNumber();
 String suffix;
        browser.getEngine().getLoadWorker().progressProperty().addListener((observable, oldValue, newValue) -> {
 for (Field field : jointFields) {
 boolean citePressed = dialogService.showConfirmationDialogAndWait(Localization.lang("Cite"),
 String quotePath = "\"" + filePath + "\"";
public class AbbreviationsFileViewModel {
            xCursorProps.setPropertyValue("CharLocale", new Locale("zxx", "", ""));
        info.getChildren().setAll(icon, link, desc, progressIndicator);
        }
 private Optional<BibEntry> entry = Optional.empty();
 String[] allParams = {viewModel.getLocalization(), params[0], params[1]};
            background.setWidth(getDesiredWidth());
        setGraphic(menu, action);
class UndefinedCharacterFormatException extends Exception {
 <V> Future<?> schedule(BackgroundTask<V> task, long delay, TimeUnit unit);
 REMOVE_ROW(MaterialDesignIcon.SERVER_MINUS) /*css: server-minus */,
public class AutoLinkFilesAction extends SimpleCommand {
 public static XComponentContext createInitialComponentContext(Hashtable<String, Object> context_entries) throws Exception {
    requires java.desktop;
    requires java.prefs;
    requires java.annotation;
    requires org.jabref.thirdparty.libreoffice;
public class DatabaseChangeEvent {
}
public interface DatabaseChangeListener {
public class DatabaseChangeRegistration {
    }
 SearchQuery searchQuery = new SearchQuery("Journal Title 500", false, false);
 SearchQuery searchQuery = new SearchQuery("Journal Title 500", false, false);
public class OracleConnection implements Connection {
public class OracleDriver {
public class OracleStatement {
package oracle.jdbc;
}
public @interface ApacheCommonsLang3Allowed {
 String value();
 System.out.println(new AuxParserResultViewModel(result).getInformation(true));
public enum BasePanelMode {
 public void setContent(ClipboardContent content) {
 public String getContents() {
 private static Optional<ParserResult> importToOpenBase(String argument) {
 private Optional<ParserResult> fetch(String fetchCommand) {
 try {
 System.out.println(Localization.lang("Importing in unknown format") + ": " + file);
 if (cli.isPreferencesReset()) {
 if (cli.isPreferencesImport()) {
 List<ParserResult> loaded = importAndOpenFiles();
 ParserResult pr = loaded.get(loaded.size() - 1);
 if (!matches.isEmpty()) {
 switch (data.length) {
                    formatName = "tablerefsabsbib";
 Optional<Exporter> exporter = Globals.exportFactory.getExporterByName(formatName);
 boolean bibExtension = aLeftOver.toLowerCase(Locale.ENGLISH).endsWith("bib");
 if (startupMode == Mode.INITIAL_START) {
 if ((newBase != null) && newBase.hasEntries()) {
 if (fileWriter.hasEncodingProblems()) {
 if (!loaded.isEmpty()) {
 ParserResult pr = loaded.get(loaded.size() - 1);
 File theFile = pr.getFile().get();
    }
 return;
 public SuggestionProviders getSuggestionProviders() {
 private void copyCitationToClipboard(CitationStyleOutputFormat outputFormat) {
 public void delete(boolean cut) {
 public void runCommand(final Actions command) {
 public void insertEntry(final BibEntry bibEntry) {
 private void setupAutoCompletion() {
 public void showAndEdit(BibEntry entry) {
 public void clearAndSelect(final BibEntry bibEntry) {
 public void entryEditorClosing() {
 private void ensureNotShowingBottomPanel(BibEntry entry) {
 private void saveDividerLocation(Number position) {
 public List<BibEntry> getSelectedEntries() {
 public void setCurrentSearchQuery(Optional<SearchQuery> currentSearchQuery) {
 private class SearchAutoCompleteListener {
 private class SearchListener {
 private final Map<Actions, BaseAction> actions = new HashMap<>();
 private BasePanelMode mode = BasePanelMode.SHOWING_NOTHING;
 private PersonNameSuggestionProvider searchAutoCompleter;
 private BibEntry showing;
 private Optional<SearchQuery> currentSearchQuery = Optional.empty();
 this.bibDatabaseContext.getDatabase().registerListener(new GroupTreeListener());
 this.bibDatabaseContext.getDatabase().registerListener(this);
 String changeFlag = isModified() && !isAutosaveEnabled ? "*" : "";
                    title.append('*');
        actions.put(Actions.COPY, this::copy);
        actions.put(Actions.PASTE, this::paste);
        actions.put(Actions.COPY_KEY, this::copyKey);
        actions.put(Actions.COPY_TITLE, this::copyTitle);
        actions.put(Actions.COPY_CITE_KEY, this::copyCiteKey);
        actions.put(Actions.COPY_KEY_AND_LINK, new CopyBibTeXKeyAndLinkAction(mainTable, Globals.clipboardManager));
 List<String> titles = selectedBibEntries.stream()
                output(Localization.lang("Copied") + " '" + JabRefDialogService.shortenDialogMessage(copiedTitles) + "'.");
 for (BibEntry be : bes) {
                output(Localization.lang("Copied") + " '" + JabRefDialogService.shortenDialogMessage(copiedCiteCommand) + "'.");
 for (BibEntry be : bes) {
                output(Localization.lang("Copied") + " '" + JabRefDialogService.shortenDialogMessage(copiedKeys) + "'.");
 StringReader sr = new StringReader("\\bibtexkey - \\begin{title}\\format[RemoveBrackets]{\\title}\\end{title}\n");
 for (BibEntry be : bes) {
                output(Localization.lang("Copied") + " '" + JabRefDialogService.shortenDialogMessage(copiedKeysAndTitles) + "'.");
 UpdateField.setAutomaticFields(bibEntry, true, true, Globals.prefs.getUpdateFieldPreferences());
                getUndoManager().addEdit(new UndoableInsertEntry(bibDatabaseContext.getDatabase(), bibEntry));
 if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_OPEN_FORM)) {
            entryEditor.setFocusToField(field);
        mainTable.addSelectionListener(listEvent -> Globals.stateManager.setSelectedEntries(mainTable.getSelectedEntries()));
        mainTable.addSelectionListener(event -> mainTable.getSelectedEntries()
 /*
        createMainTable();
        instantiateSearchAutoCompleter();
        dividerPositionSubscription = EasyBind.monadic(Bindings.valueAt(splitPane.getDividers(), 0))
            resetChangeMonitorAndChangePane();
 this.baseChanged = true;
 CoarseChangeFilter changeFilter = new CoarseChangeFilter(bibDatabaseContext);
            suggestionProviders = new SuggestionProviders();
        frame.setWindowTitle();
 FileFinder fileFinder = FileFinders.constructFromConfiguration(Globals.prefs.getAutoLinkPreferences());
 if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_ASSIGN_GROUP)) {
 DefaultTaskExecutor.runInJavaFXThread(() -> frame.getGlobalSearchBar().performSearch());
 List<LinkedFile> files = bes.get(0).getFiles();
public class CrossrefFetcherEvaluator {
 private static Object createDependency(Class<?> clazz) {
 Injector.setInstanceSupplier(DefaultInjector::createDependency);
public interface DialogService {
 <T> Optional<T> showChoiceDialogAndWait(String title, String content, String okButtonLabel, T defaultChoice, Collection<T> choices);
 Optional<String> showInputDialogAndWait(String title, String content);
 Optional<String> showInputDialogWithDefaultAndWait(String title, String content, String defaultValue);
 void showInformationDialogAndWait(String title, String content);
 void showWarningDialogAndWait(String title, String content);
 void showErrorDialogAndWait(String title, String content);
 void showErrorDialogAndWait(String message, Throwable exception);
 void showErrorDialogAndWait(String title, String content, Throwable exception);
 void showErrorDialogAndWait(String message);
 boolean showConfirmationDialogAndWait(String title, String content);
 boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel);
 boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel);
 boolean showConfirmationDialogWithOptOutAndWait(String title, String content,
 boolean showConfirmationDialogWithOptOutAndWait(String title, String content,
 <R> Optional<R> showCustomDialogAndWait(Dialog<R> dialog);
 <V> void showProgressDialogAndWait(String title, String content, Task<V> task);
 void notify(String message);
 Optional<Path> showFileSaveDialog(FileDialogConfiguration fileDialogConfiguration);
 Optional<Path> showFileOpenDialog(FileDialogConfiguration fileDialogConfiguration);
 List<Path> showFileOpenDialogAndGetMultipleFiles(FileDialogConfiguration fileDialogConfiguration);
 Optional<Path> showDirectorySelectionDialog(DirectoryDialogConfiguration directoryDialogConfiguration);
 boolean showPrintDialog(PrinterJob job);
 Optional<Path> showFileOpenFromArchiveDialog(Path archivePath) throws IOException;
public class DragAndDropDataFormats {
public class EntryTypeView extends BaseDialog<EntryType> {
 return type;
        bibTexTitlePane.managedProperty().bind(bibTexTitlePane.visibleProperty());
 break;
public class FXDialog extends Alert {
 public static JournalAbbreviationLoader journalAbbreviationLoader;
 public static ProtectedTermsLoader protectedTermsLoader;
 public static ClipBoardManager clipboardManager = new ClipBoardManager();
 public static final RemoteListenerServerLifecycle REMOTE_LISTENER = new RemoteListenerServerLifecycle();
 public static JabRefPreferences prefs;
 private static KeyBindingRepository keyBindingRepository;
 public static synchronized KeyBindingRepository getKeyPrefs() {
 public static void startBackgroundTasks() throws JabRefException {
 SDKShutdownActivity.INSTANCE.stopAll();
public class GUIGlobals {
 public static void init() {
 public static final int WIDTH_ICON_COL_RANKING = 5 * 16; // Width of Ranking Icon Column
 public static final String UNTITLED_TITLE = Localization.lang("untitled");
 GUIGlobals.updateEntryEditorColors();
 Globals.prefs.putInt(JabRefPreferences.FONT_SIZE, size);
 private static final Logger LOGGER = LoggerFactory.getLogger(JabRefCLI.class);
        options.addOption("h", "help", false, Localization.lang("Display help on command line options"));
public class JabRefDialogService implements DialogService {
        alert.getDialogPane().applyCss();
        alert.setDialogPane(new DialogPane() {
        alert.getDialogPane().setExpandableContent(new Group());
public class JabRefLauncher {
public class SidePane extends BorderPane {
 public void beforeClosing() {
 public void afterOpening() {
    }
 return null;
 return false;
 return null;
 return null;
 return null;
 return null;
    }
 return false;
    }
    }
    }
 return false;
 return null;
    }
 return false;
    }
 return null;
    }
 return 0;
 return null;
    }
 return null;
 return null;
 return null;
 return null;
    }
    }
 return 0;
 return null;
 return null;
    }
    }
 return null;
 return null;
 return null;
 return null;
 return null;
 return null;
 return null;
 return null;
 return null;
 return null;
 return false;
    }
    }
 return null;
 return null;
 return null;
 return null;
    }
 return null;
    }
    }
 return 0;
 public void savePartOfDatabase(BibDatabaseContext bibDatabaseContext, List<BibEntry> entries) throws IOException {
public class AutosaveEvent {
 private final DuplicationChecker duplicationChecker = new DuplicationChecker();
 protected void writeMetaData(MetaData metaData, GlobalBibtexKeyPattern globalCiteKeyPattern) throws IOException {
 public boolean hasEntries() {
 public boolean containsEntryWithId(String id) {
 public Set<Field> getAllVisibleFields() {
 public synchronized List<BibEntry> getEntriesByKey(String key) {
 public synchronized boolean insertEntry(BibEntry entry, EntryEventSource eventSource) throws KeyCollisionException {
 public synchronized void removeEntry(BibEntry toBeDeleted) {
 public synchronized void setPreamble(String preamble) {
 public void removeString(String id) {
 public BibtexString getString(String id) {
 public boolean hasNoStrings() {
 public void copyPreamble(BibDatabase database) {
 public BibEntry resolveForStrings(BibEntry entry, boolean inPlace) {
 Optional<Month> month = Month.getMonthByShortName(label);
 for (BibEntry entry : toChange) {
                    newRes.append(res.substring(next));
 private Optional<Path> file;
 public Optional<Path> getFirstExistingFileDir(FilePreferences preferences) {
        comparators.add(new CrossRefEntryComparator());
 return getFileDirectories(preferences).stream()
        preferences.getFileDirectory(field).ifPresent(path -> fileDirs.add(path.toAbsolutePath().toString()));
                relDir = databaseFile.get().getParent();
 public BibDatabaseMode getOppositeMode() {
 private T parent;
 private T child;
 public Optional<T> getParent() {
 public boolean isAncestorOf(T anotherNode) {
 public void addAtEnd(T node) {
public abstract class ChainNode<T extends ChainNode<T>> {
public class CoarseChangeFilter {
        uriBuilder.addParameter("within", "owners.owner=GUIDE"); // Search within the ACM Guide to Computing Literature (encompasses the ACM Full-Text Collection)
 Set<BibEntryType> typesToWrite = new HashSet<>();
public class DatabaseNotSupportedException extends Exception {
 if (preferences.getSaveType() != SavePreferences.DatabaseSaveType.PLAIN_BIBTEX) {
 private boolean isDuplicateCiteKeyExisting(String citeKey) {
 private void removeKeyFromSet(String key) {
 private List<FieldChange> cleanupSingleField(Field fieldKey, BibEntry entry) {
 public TreeNode(Class<T> derivingClass) {
 private final ObservableList<T> children;
 private T parent;
 public int getPositionInParent() {
 public int getLevel() {
 public List<T> getPathFromRoot() {
 public Optional<T> getPreviousSibling() {
 protected boolean childIndexExists(int index) {
 if (entryTypesManager.isCustomType(entry.getType(), bibDatabaseContext.getMode())) {
 public void removeFromParent() {
                entryTypesManager.enrich(entry.getType(), bibDatabaseContext.getMode()).ifPresent(typesToWrite::add);
 public void sortChildren(Comparator<? super T> comparator, boolean recursive) {
 public void moveTo(T target, int targetIndex) {
 public T copySubtree() {
        }
 public static void runMigrations() {
 private static void upgradeFaultyEncodingStrings(JabRefPreferences prefs) {
 private static void upgradeSortOrder(JabRefPreferences prefs) {
            writeEntryTypeDefinitions(typesToWrite);
 if (mainPrefsNode.get(JabRefPreferences.DEFAULT_BIBTEX_KEY_PATTERN, null) == null) {
 if (mainPrefsNode.nodeExists(JabRefPreferences.BIBTEX_KEY_PATTERNS_NODE)) {
        writeEpilogue(bibDatabaseContext.getDatabase().getEpilog());
 public abstract String getKey();
 public abstract String format(String value);
public class ACS implements FulltextFetcher {
 @Override
 if (!groupedByField.containsKey(key)) {
 List<String> formattersForKey = groupedByField.get(key);
 StringBuilder result = new StringBuilder();
 String content = bibtexString.getContent();
public class BiblioscapeImporter extends Importer {
            }
 if ("------".equals(line)) {
                    }
 for (int i = 1; (i >= 0) && BibEntry.DEFAULT_TYPE.equals(bibtexType); --i) {
 if (bibtexType.equals(StandardEntryType.Article)) {
 if (address != null) {
                    hm.put(StandardField.COMMENT, String.join(";", comments));
 public static Optional<BibEntry> getEntry(String entryUrl, ImportFormatPreferences importFormatPreferences) {
 for (BibtexString original : originalDatabase.getStringValues()) {
 if (!Objects.equals(original.getContent(), match.get().getContent())) {
                    differences.add(new BibStringDiff(original, match.get()));
                notMatched.add(original);
 for (Iterator<BibtexString> iterator = notMatched.iterator(); iterator.hasNext(); ) {
        newDatabase.getStringValues().stream()
 private int convertSpecialChar(StringBuilder sb, char[] c, int start, FORMAT_MODE format) {
 Document html = Jsoup.connect(source).ignoreHttpErrors(true).get();
 public static Optional<String> findSpecialChar(char[] c, int pos) {
 ALL_LOWERS('l'),
 if (preferences.isSaveInOriginalOrder()) {
 while ((i < c.length) && (braceLevel > 0)) {
 Optional<String> s = BibtexCaseChanger.findSpecialChar(c, i);
 @Override
public class ChangeCaseFunction implements BstFunction {
 for (Field field : FIELDS) {
 public static List<BibEntry> getSortedEntries(BibDatabaseContext bibDatabaseContext, List<BibEntry> entriesToSort, SavePreferences preferences) {
public class DiVA implements IdBasedParserFetcher {
public class DoiResolution implements FulltextFetcher {
 if (!sciLink.isEmpty()) {
                    connection.timeout(10000);
 if ((href.contains("pdf") || hrefText.contains("pdf")) && new URLDownload(href).isPdf()) {
 if (links.size() == 1) {
 public List<String> getValue(EntryType entryType) {
        row.startFullDrag();
 public static List<Field> SUPPORTED_FIELDS = Arrays.asList(StandardField.DOI, StandardField.EPRINT, StandardField.ISBN);
            } else {
            } else {
 public static final String[] getDefaultOptions() {
 boolean disable_dynloading = false;
 private XTextRange getBookmarkRange(String name) throws NoSuchElementException, WrappedTargetException {
        text = mxDoc.getText();
 throw new ConnectionLostException(ex.getMessage());
public class SidePaneManager {
 for (int j = 0; j < cEntries.length; j++) {
        text.insertTextContent(position, xTextContent, true);
 Optional<String> pageInfo = getCustomProperty(name);
 XTextContent xTextContent = UnoRuntime.queryInterface(XTextContent.class, bookmark);
 XBookmarksSupplier xBookmarksSupplier = UnoRuntime.queryInterface(XBookmarksSupplier.class, xCurrentComponent);
 String bName = getUniqueReferenceMarkName(keyString, OOBibBase.AUTHORYEAR_PAR);
                    resultDatabase.insertEntry(clonedEntry);
 if (!emptyKeys) {
 Optional<Path> actualFile = chooseAmongInstallations(installations);
class ConnectionLostException extends RuntimeException {
public class PreferencesDialogView extends BaseDialog<PreferencesDialogViewModel> {
 private void jumpToSearchKey(ListView<PreviewLayout> list, KeyEvent keypressed) {
 private class PreferredIndexSort implements Comparator<SidePaneComponent> {
 void setValues();
 for (PreferencesTab tab : preferenceTabs) {
 HBox themeBox = new HBox();
 boolean validateSettings();
 Label keyGeneratorSettings = new Label(Localization.lang("Key generator settings"));
 public StringProperty mainFileDirProperty() { return mainFileDirProperty; }
public class StateManager {
                    fileLinker.moveFilesToFileDirAndAddToEntry(entry, files);
 return menu;
 boolean requiresBibtexKeys();
                    prefix.concat("\"" + getCiteCommand().replaceAll("\\\\", "\\\\\\\\") + "{" + keys + "}\"").concat(suffix);
 try {
        base.setPreamble(newValue);
 ViewLoader.view(this)
 private final boolean separationBySpace;
                        setOnContextMenuRequested(event -> {
public class OnlyIntegerFormatter extends TextFormatter<Integer> {
 private static PseudoClass dragOverBottom = PseudoClass.getPseudoClass("dragOver-bottom");
            row.setOnContextMenuRequested(event -> {
public class TooltipTextUtil {
 <V> Future<V> execute(Task<V> task);
 void shutdown();
 return true;
public class AutoCompleteUpdater {
 final CountDownLatch doneLatch = new CountDownLatch(1);
 private StringConverter<T> converter;
 public BackgroundTask<Void> thenRun(Consumer<V> nextOperation) {
 boolean openFolders = JabRefPreferences.getInstance().getBoolean(JabRefPreferences.OPEN_FOLDERS_OF_ATTACHED_FILES);
 public void addPossibleSuggestions(Collection<T> newPossible) {
 private final Map<Field, AutoCompleteSuggestionProvider<?>> providers = new HashMap<>();
public class WordSuggestionProvider extends StringSuggestionProvider implements AutoCompleteSuggestionProvider<String> {
 int columnsNumber = 2;
 public BasePanel getBasePanelAt(int i) {
public class CopyFilesResultListDependency {
    }
 /*
 void openPdfWithParameters(String filePath, List<String> parameters) throws IOException;
 if (!file.isPresent() || !Files.exists(file.get())) {
                command = command.replace("%DIR", absolutePath);
 EasyBind.subscribe(currentPage, this::showPage);
            viewModel.getKeywords().set(event.getTablePosition().getRow(), event.getNewValue());
 Optional<FieldChange> change = entry.putKeywords(keywords, preferences.getKeywordDelimiter());
 for (Map.Entry<Field, String> field : outOfFocusEntry.getFieldMap().entrySet()) {
 if (!Objects.equals(newEntry.getType(), outOfFocusEntry.getType())) {
 return Collections.emptySortedSet();
 private StackPane getRelatedArticlesPane(BibEntry entry) {
 LOGGER.debug("Mode MOVE");
        entryEditorTabs.add(new RequiredFieldsTab(databaseContext, panel.getSuggestionProviders(), undoManager, dialogService));
        entryEditorTabs.add(new MathSciNetTab());
 if (typeSubscription != null) {
 private EntryType currentEntryType;
 protected void handleFocus() {
        content.textProperty().bind(EasyBind.select(viewModel.currentAnnotationProperty()).selectObject(FileAnnotationViewModel::contentProperty));
 public void copyCurrentAnnotation() {
 public void reportIssue() {
 Globals.prefs.fileDirForDatabase = panel.getBibDatabaseContext().getFileDirectoriesAsPaths(Globals.prefs.getFilePreferences()).stream().map(Path::toString).collect(Collectors.toList());
public class ExportCommand extends SimpleCommand {
 Globals.prefs.fileDirForDatabase = frame.getCurrentBasePanel()
 Globals.prefs.put(JabRefPreferences.LAST_USED_EXPORT, format.getName());
                })
 if (context.getLocation() == DatabaseLocation.SHARED) {
                        entriesToAdd = xmpEntriesInFile;
 Files.createDirectories(destination.getParent());
public class FindUnlinkedFilesDialog extends BaseDialog<Void> {
        stateManager.activeDatabaseProperty().bind(
 return node.path.getFileName() + " (" + node.fileCount + " file" + (node.fileCount > 1 ? "s" : "") + ")";
 VBox panelDirectory = new VBox(5);
 EasyBind.subscribe(stateManager.activeSearchQueryProperty(),
 public Optional<ExternalFileType> getExternalFileTypeForName(String filename) {
 List<ExternalFileType> defTypes = new ArrayList<>(getDefaultExternalFileTypes());
 ExternalFileType toRemove = null;
                types.add(type);
            setWindowTitle();
 Optional<ExternalFileType> mimeType = getExternalFileTypeByMimeType(linkedFile.getFileType());
 return FileHelper.getFileExtension(linkedFile.getLink())
 public static ExternalFileType buildFromArgs(String[] val) {
 public void storeSettings() {
 if (link.substring(index + 1).indexOf('/') >= 1) {
 void addToContextMenu(final Supplier<List<MenuItem>> items);
 try {
        );
        taskExecutor.execute(writeTask);
 if (!suggestedType.isPresent()) {
 @SuppressWarnings("unchecked")
 public static Supplier<List<MenuItem>> getDOIMenu(TextArea textArea) {
public class FileListEntry {
class UndoableMoveGroup extends AbstractUndoableJabRefEdit {
 for (int i = 0; i < tabbedPane.getTabs().size(); i++) {
 PseudoClass anySelected = PseudoClass.getPseudoClass("any-selected");
        m_pathToNode = editedNode.getNode().getIndexedPathFromRoot();
 for (int i = 0; i < (m_pathToNode.size() - 1); ++i) {
 private final List<GroupTreeNode> m_modifiedSubtree = new ArrayList<>();
 public UndoableModifySubtree(GroupTreeNodeViewModel groupRoot,
 final GroupTreeNode subtreeRoot = m_groupRoot.getDescendant(m_subtreeRootPath).get(); //TODO: NULL
class GroupDialog extends BaseDialog<AbstractGroup> {
 HBox mainPanel = new HBox(15);
                                warnAboutSameName = true;
 if (editedGroup == null) {
public class GroupSidePane extends SidePaneComponent {
    }
 if (targetParent.equals(getParent())) {
 boolean keepPreviousAssignments = dialogService.showConfirmationDialogAndWait(
 boolean removePreviousAssignments = (oldGroup.getGroupNode().getGroup() instanceof ExplicitGroup)
 private static final Set<String> AVAILABLE_LANG_FILES = Stream.of("en", "de", "fr", "in", "ja")
 return false;
public class ErrorConsoleAction extends SimpleCommand {
 OPEN(MaterialDesignIcon.FOLDER_OUTLINE) /*css: folder */,
 READ_STATUS_SKIMMED(Color.ORANGE, MaterialDesignIcon.EYE), /*css: eye */
 TextInputControl textInput = (TextInputControl) focusOwner;
 TOGGLE_GROUPS(MaterialDesignIcon.VIEW_LIST), /*css: view-list */
 WRITE_XMP(MaterialDesignIcon.IMPORT), /* css: import */
 REG_EX(MaterialDesignIcon.REGEX), /*css: mdi-regex */
 FORUM(MaterialDesignIcon.FORUM), /* css: forum */
 break;
        jabRefFrame.getDialogService().showWarningDialogAndWait(dialogTitle, dialogContent.toString());
                    imports.add(Globals.IMPORT_FORMAT_READER.importUnknownFormat(filename, Globals.getFileUpdateMonitor()));
 ParserResult pr = importResult.parserResult;
 UpdateField.setAutomaticFields(entries, Globals.prefs.getUpdateFieldPreferences()); // set timestamp and owner
                entries.add(dialog.getMergedEntry());
 boolean overwriteOwner = Globals.prefs.getBoolean(JabRefPreferences.OVERWRITE_OWNER);
 boolean isActionNecessary(ParserResult pr);
 public void openFile(Path file, boolean raisePanel) {
 private static final List<GUIPostOpenAction> POST_OPEN_ACTIONS = Arrays.asList(
                openTheFile(theFile, raisePanel);
 else if (toRaise != null) {
public class AbbreviateAction implements BaseAction {
public class UnabbreviateAction implements BaseAction {
 UndoableUnabbreviator undoableAbbreviator = new UndoableUnabbreviator(Globals.journalAbbreviationLoader
 public class JournalAbbreviationsAbbreviationTableEditingCell extends TableCell<AbbreviationViewModel, String> {
 public boolean unabbreviate(BibDatabase database, BibEntry entry, Field field, CompoundEdit ce) {
 TABLE_ICONS.put(SpecialField.QUALITY, icon);
 TABLE_ICONS.put(SpecialField.RANKING, icon);
 final JabRefPreferences preferences = JabRefPreferences.getInstance();
 Class<?> clazz = Class.forName("javafx.scene.control.TableUtil");
 if (preferences.resizeColumnsToFit()) {
