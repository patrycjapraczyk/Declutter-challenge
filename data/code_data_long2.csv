public static void showContextMenu(TextArea textArea, ContextMenu contextMenu, ContextMenuEvent e) { public static void showContextMenu(TextArea textArea, ContextMenu contextMenu, ContextMenuEvent e) { double screenX = e.getScreenX(); double screenY = e.getScreenY(); double sceneX = e.getSceneX();  TextAreaSkin skin = (TextAreaSkin) textArea.getSkin();  if (Properties.IS_TOUCH_SUPPORTED) { Point2D menuPos; if (textArea.getSelection().getLength() == 0) { skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false); menuPos = skin.getMenuPosition(); } else { menuPos = skin.getMenuPosition(); if (menuPos != null && (menuPos.getX() <= 0 || menuPos.getY() <= 0)) { skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false); menuPos = skin.getMenuPosition(); } }  if (menuPos != null) { Point2D p = textArea.localToScene(menuPos); Scene scene = textArea.getScene(); Window window = scene.getWindow(); Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(), window.getY() + scene.getY() + p.getY()); screenX = location.getX(); sceneX = p.getX(); screenY = location.getY(); } }  double menuWidth = contextMenu.prefWidth(-1); double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0); Screen currentScreen = Screen.getPrimary(); Rectangle2D bounds = currentScreen.getBounds();  if (menuX < bounds.getMinX()) { textArea.getProperties().put("CONTEXT_MENU_SCREEN_X", screenX); textArea.getProperties().put("CONTEXT_MENU_SCENE_X", sceneX); contextMenu.show(textArea, bounds.getMinX(), screenY); } else if (screenX + menuWidth > bounds.getMaxX()) { double leftOver = menuWidth - (bounds.getMaxX() - screenX); textArea.getProperties().put("CONTEXT_MENU_SCREEN_X", screenX); textArea.getProperties().put("CONTEXT_MENU_SCENE_X", sceneX); contextMenu.show(textArea, screenX - leftOver, screenY); } else { textArea.getProperties().put("CONTEXT_MENU_SCREEN_X", 0); textArea.getProperties().put("CONTEXT_MENU_SCENE_X", 0); contextMenu.show(textArea, menuX, screenY); } }


private boolean confirmClose(BasePanel panel) { private boolean confirmClose(BasePanel panel) { String filename = panel.getBibDatabaseContext() .getDatabasePath() .map(Path::toAbsolutePath) .map(Path::toString) .orElse(GUIGlobals.UNTITLED_TITLE);  ButtonType saveChanges = new ButtonType(Localization.lang("Save changes"), ButtonBar.ButtonData.YES); ButtonType discardChanges = new ButtonType(Localization.lang("Discard changes"), ButtonBar.ButtonData.NO); ButtonType cancel = new ButtonType(Localization.lang("Return to JabRef"), ButtonBar.ButtonData.CANCEL_CLOSE);  Optional<ButtonType> response = dialogService.showCustomButtonDialogAndWait(Alert.AlertType.CONFIRMATION, Localization.lang("Save before closing"), Localization.lang("Library '%0' has changed.", filename), saveChanges, discardChanges, cancel);  if (response.isPresent() && response.get().equals(saveChanges)) { // The user wants to save. try { SaveDatabaseAction saveAction = new SaveDatabaseAction(panel, Globals.prefs, Globals.entryTypesManager); if (saveAction.save()) { // Saved, now exit. return true; } // The action was either canceled or unsuccessful. dialogService.notify(Localization.lang("Unable to save library")); } catch (Throwable ex) { LOGGER.error("A problem occurred when trying to save the file", ex); dialogService.showErrorDialogAndWait(Localization.lang("Save library"), Localization.lang("Could not save file."), ex); } // Save was cancelled or an error occurred. return false; } return !response.isPresent() || !response.get().equals(cancel); }







public class DefaultFileUpdateMonitor implements Runnable, FileUpdateMonitor { public class DefaultFileUpdateMonitor implements Runnable, FileUpdateMonitor {  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultFileUpdateMonitor.class);  private final Multimap<Path, FileUpdateListener> listeners = ArrayListMultimap.create(20, 4); private WatchService watcher;  @Override public void run() { try (WatchService watcher = FileSystems.getDefault().newWatchService()) { this.watcher = watcher; while (true) { WatchKey key; try { key = watcher.take(); } catch (InterruptedException e) { return; }  for (WatchEvent<?> event : key.pollEvents()) { WatchEvent.Kind<?> kind = event.kind();  if (kind == StandardWatchEventKinds.OVERFLOW) { Thread.yield(); continue; } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) { // We only handle "ENTRY_MODIFY" here, so the context is always a Path @SuppressWarnings("unchecked") WatchEvent<Path> ev = (WatchEvent<Path>) event; Path path = ((Path) key.watchable()).resolve(ev.context()); notifyAboutChange(path); } key.reset(); } Thread.yield(); } } catch (Throwable e) { LOGGER.error("FileUpdateMonitor has been interrupted.", e); } }  private void notifyAboutChange(Path path) { listeners.get(path).forEach(FileUpdateListener::fileUpdated); }  @Override public void addListenerForFile(Path file, FileUpdateListener listener) throws IOException { if (watcher == null) { throw new IllegalStateException("You need to start the file monitor before watching files"); }  // We can't watch files directly, so monitor their parent directory for updates Path directory = file.toAbsolutePath().getParent(); directory.register(watcher, StandardWatchEventKinds.ENTRY_MODIFY); listeners.put(file, listener); }  @Override public void removeListener(Path path, FileUpdateListener listener) { listeners.remove(path, listener); } }

public static <A, B> MappedList<B, A> mapBacked(ObservableList<A> source, Function<A, B> mapper) { public static <A, B> MappedList<B, A> mapBacked(ObservableList<A> source, Function<A, B> mapper) { return new MappedList<>(source, mapper); }
public BackgroundTask<V> onFailure(Consumer<Exception> onException) { public BackgroundTask<V> onFailure(Consumer<Exception> onException) { this.onException = onException; return this; }





void storeSettings(); void storeSettings();


public MergeEntries(BibEntry entryLeft, BibEntry entryRight, String headingLeft, String headingRight, BibDatabaseMode type) { public MergeEntries(BibEntry entryLeft, BibEntry entryRight, String headingLeft, String headingRight, BibDatabaseMode type) { this.leftEntry = entryLeft; this.rightEntry = entryRight;  initialize(); setLeftHeaderText(headingLeft); setRightHeaderText(headingRight); }

public boolean dragDroppedInChosenCell(PreviewLayout targetLayout, Dragboard dragboard) { public boolean dragDroppedInChosenCell(PreviewLayout targetLayout, Dragboard dragboard) { boolean success = false;  if (dragboard.hasContent(DragAndDropDataFormats.PREVIEWLAYOUTS)) { List<PreviewLayout> draggedSelectedLayouts = new ArrayList<>(localDragboard.getPreviewLayouts()); if (!draggedSelectedLayouts.isEmpty()) {  int targetId = chosenListProperty.getValue().indexOf(targetLayout);  // see https://stackoverflow.com/questions/28603224/sort-tableview-with-drag-and-drop-rows int onSelectedDelta = 0; while (draggedSelectedLayouts.contains(targetLayout)) { onSelectedDelta = 1; targetId--; if (targetId < 0) { targetId = 0; targetLayout = null; break; } targetLayout = chosenListProperty.getValue().get(targetId); }  dragSourceList.getValue().removeAll(draggedSelectedLayouts);  if (targetLayout != null) { targetId = chosenListProperty.getValue().indexOf(targetLayout) + onSelectedDelta; } else if (targetId != 0) { targetId = chosenListProperty.getValue().size(); }  chosenListProperty.getValue().addAll(targetId, draggedSelectedLayouts);  chosenSelectionModelProperty.getValue().clearSelection(); draggedSelectedLayouts.forEach(layout -> chosenSelectionModelProperty.getValue().select(layout));  success = true; } }  return success; }
public class BindingsHelper { public class BindingsHelper {  private BindingsHelper() { }  public static <T> BooleanBinding any(ObservableList<T> source, Predicate<T> predicate) { return Bindings.createBooleanBinding(() -> source.stream().anyMatch(predicate), source); }  public static <T> BooleanBinding all(ObservableList<T> source, Predicate<T> predicate) { // Stream.allMatch() (in contrast to Stream.anyMatch() returns 'true' for empty streams, so this has to be checked explicitly. return Bindings.createBooleanBinding(() -> !source.isEmpty() && source.stream().allMatch(predicate), source); }  public static void includePseudoClassWhen(Node node, PseudoClass pseudoClass, ObservableValue<? extends Boolean> condition) { Consumer<Boolean> changePseudoClass = value -> node.pseudoClassStateChanged(pseudoClass, value); EasyBind.subscribe(condition, changePseudoClass);  // Put the pseudo class there depending on the current value changePseudoClass.accept(condition.getValue()); }  /** * Creates a new list in which each element is converted using the provided mapping. * All changes to the underlying list are propagated to the converted list. * * In contrast to {@link org.fxmisc.easybind.EasyBind#map(ObservableList, Function)}, * the items are converted when the are inserted (and at the initialization) instead of when they are accessed. * Thus the initial CPU overhead and memory consumption is higher but the access to list items is quicker. */ public static <A, B> MappedList<B, A> mapBacked(ObservableList<A> source, Function<A, B> mapper) { return new MappedList<>(source, mapper); }  public static <T, U> ObservableList<U> map(ObservableValue<T> source, Function<T, List<U>> mapper) { PreboundBinding<List<U>> binding = new PreboundBinding<List<U>>(source) {  @Override protected List<U> computeValue() { return mapper.apply(source.getValue()); } };  ObservableList<U> list = FXCollections.observableArrayList(); binding.addListener((observable, oldValue, newValue) -> list.setAll(newValue)); return list; }  /** * Binds propertA bidirectional to propertyB using the provided map functions to convert between them. */ public static <A, B> void bindBidirectional(Property<A> propertyA, Property<B> propertyB, Function<A, B> mapAtoB, Function<B, A> mapBtoA) { Consumer<B> updateA = newValueB -> propertyA.setValue(mapBtoA.apply(newValueB)); Consumer<A> updateB = newValueA -> propertyB.setValue(mapAtoB.apply(newValueA)); bindBidirectional(propertyA, propertyB, updateA, updateB); }  /** * Binds propertA bidirectional to propertyB while using updateB to update propertyB when propertyA changed. */ public static <A> void bindBidirectional(Property<A> propertyA, ObservableValue<A> propertyB, Consumer<A> updateB) { bindBidirectional(propertyA, propertyB, propertyA::setValue, updateB); }  /** * Binds propertA bidirectional to propertyB using updateB to update propertyB when propertyA changed and similar * for updateA. */ public static <A, B> void bindBidirectional(ObservableValue<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<A> updateB) { final BidirectionalBinding<A, B> binding = new BidirectionalBinding<>(propertyA, propertyB, updateA, updateB);  // use updateB as initial source updateA.accept(propertyB.getValue());  propertyA.addListener(binding.getChangeListenerA()); propertyB.addListener(binding.getChangeListenerB()); }  public static <A, B> void bindContentBidirectional(ObservableList<A> propertyA, ListProperty<B> propertyB, Consumer<ObservableList<B>> updateA, Consumer<List<A>> updateB) { bindContentBidirectional( propertyA, (ObservableValue<ObservableList<B>>) propertyB, updateA, updateB); }  public static <A, B> void bindContentBidirectional(ObservableList<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<List<A>> updateB) { final BidirectionalListBinding<A, B> binding = new BidirectionalListBinding<>(propertyA, propertyB, updateA, updateB);  // use property as initial source updateA.accept(propertyB.getValue());  propertyA.addListener(binding); propertyB.addListener(binding); }  public static <A, B> void bindContentBidirectional(ListProperty<A> listProperty, Property<B> property, Function<List<A>, B> mapToB, Function<B, List<A>> mapToList) { Consumer<B> updateList = newValueB -> listProperty.setAll(mapToList.apply(newValueB)); Consumer<List<A>> updateB = newValueList -> property.setValue(mapToB.apply(newValueList));  bindContentBidirectional( listProperty, property, updateList, updateB); }  public static <A, V, B> void bindContentBidirectional(ObservableMap<A, V> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<Map<A, V>> updateB) { final BidirectionalMapBinding<A, V, B> binding = new BidirectionalMapBinding<>(propertyA, propertyB, updateA, updateB);  // use list as initial source updateB.accept(propertyA);  propertyA.addListener(binding); propertyB.addListener(binding); }  public static <A, V, B> void bindContentBidirectional(ObservableMap<A, V> propertyA, Property<B> propertyB, Consumer<B> updateA, Function<Map<A, V>, B> mapToB) { Consumer<Map<A, V>> updateB = newValueList -> propertyB.setValue(mapToB.apply(newValueList)); bindContentBidirectional( propertyA, propertyB, updateA, updateB); }  public static <T> ObservableValue<T> constantOf(T value) { return new ObjectBinding<T>() {  @Override protected T computeValue() { return value; } }; }  public static ObservableValue<Boolean> constantOf(boolean value) { return new BooleanBinding() {  @Override protected boolean computeValue() { return value; } }; }  public static ObservableValue<? extends String> emptyString() { return new StringBinding() {  @Override protected String computeValue() { return ""; } }; }  /** * Returns a wrapper around the given list that posts changes on the JavaFX thread. */ public static <T> ObservableList<T> forUI(ObservableList<T> list) { return new UiThreadList<>(list); }  public static <T> ObservableValue<T> ifThenElse(ObservableValue<Boolean> condition, T value, T other) { return EasyBind.map(condition, conditionValue -> { if (conditionValue) { return value; } else { return other; } }); }  private static class BidirectionalBinding<A, B> {  private final ObservableValue<A> propertyA; private final Consumer<B> updateA; private final Consumer<A> updateB; private boolean updating = false;  public BidirectionalBinding(ObservableValue<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<A> updateB) { this.propertyA = propertyA; this.updateA = updateA; this.updateB = updateB; }  public ChangeListener<? super A> getChangeListenerA() { return this::changedA; }  public ChangeListener<? super B> getChangeListenerB() { return this::changedB; }  public void changedA(ObservableValue<? extends A> observable, A oldValue, A newValue) { updateLocked(updateB, oldValue, newValue); }  public void changedB(ObservableValue<? extends B> observable, B oldValue, B newValue) { updateLocked(updateA, oldValue, newValue); }  private <T> void updateLocked(Consumer<T> update, T oldValue, T newValue) { if (!updating) { try { updating = true; update.accept(newValue); } finally { updating = false; } } } }  private static class BidirectionalListBinding<A, B> implements ListChangeListener<A>, ChangeListener<B> {  private final ObservableList<A> listProperty; private final ObservableValue<B> property; private final Consumer<B> updateA; private final Consumer<List<A>> updateB; private boolean updating = false;  public BidirectionalListBinding(ObservableList<A> listProperty, ObservableValue<B> property, Consumer<B> updateA, Consumer<List<A>> updateB) { this.listProperty = listProperty; this.property = property; this.updateA = updateA; this.updateB = updateB; }  @Override public void changed(ObservableValue<? extends B> observable, B oldValue, B newValue) { if (!updating) { try { updating = true; updateA.accept(newValue); } finally { updating = false; } } }  @Override public void onChanged(Change<? extends A> c) { if (!updating) { try { updating = true; updateB.accept(listProperty); } finally { updating = false; } } } }  private static class BidirectionalMapBinding<A, V, B> implements MapChangeListener<A, V>, ChangeListener<B> {  private final ObservableMap<A, V> mapProperty; private final ObservableValue<B> property; private final Consumer<B> updateA; private final Consumer<Map<A, V>> updateB; private boolean updating = false;  public BidirectionalMapBinding(ObservableMap<A, V> mapProperty, ObservableValue<B> property, Consumer<B> updateA, Consumer<Map<A, V>> updateB) { this.mapProperty = mapProperty; this.property = property; this.updateA = updateA; this.updateB = updateB; }  @Override public void changed(ObservableValue<? extends B> observable, B oldValue, B newValue) { if (!updating) { try { updating = true; updateA.accept(newValue); } finally { updating = false; } } }  @Override public void onChanged(Change<? extends A, ? extends V> c) { if (!updating) { try { updating = true; updateB.accept(mapProperty); } finally { updating = false; } } } } }
public static List<Text> formatToTexts(String original, TextReplacement... replacements) { public static List<Text> formatToTexts(String original, TextReplacement... replacements) { List<Text> textList = new ArrayList<>(); textList.add(new Text(original)); for (TextReplacement replacement : replacements) { splitReplace(textList, replacement); }  return textList; }
public void copyLog(List<LogEventViewModel> messages) { public void copyLog(List<LogEventViewModel> messages) { if (messages.isEmpty()) { return; } clipBoardManager.setContent(getLogMessagesAsString(messages)); dialogService.notify(Localization.lang("Log copied to clipboard.")); }


public class BibEntrySuggestionProvider extends SuggestionProvider<BibEntry> implements AutoCompleteSuggestionProvider<BibEntry> { public class BibEntrySuggestionProvider extends SuggestionProvider<BibEntry> implements AutoCompleteSuggestionProvider<BibEntry> {  @Override public void indexEntry(BibEntry entry) { if (entry == null) { return; }  addPossibleSuggestions(entry); }  @Override protected Comparator<BibEntry> getComparator() { return new EntryComparator(false, true, InternalField.KEY_FIELD); }  @Override protected boolean isMatch(BibEntry suggestion, AutoCompletionBinding.ISuggestionRequest request) { String userTextLower = request.getUserText().toLowerCase(); return suggestion.getCiteKeyOptional() .map(key -> key.toLowerCase().contains(userTextLower)) .orElse(false); } }

public void addAbbreviation(String name, String abbreviation) { public void addAbbreviation(String name, String abbreviation) { Abbreviation abbreviationObject = new Abbreviation(name, abbreviation); AbbreviationViewModel abbreviationViewModel = new AbbreviationViewModel(abbreviationObject); if (abbreviations.contains(abbreviationViewModel)) { dialogService.showErrorDialogAndWait(Localization.lang("Duplicated Journal Abbreviation"), Localization.lang("Abbreviation %s for journal %s already defined.", abbreviation, name)); } else { abbreviations.add(abbreviationViewModel); currentAbbreviation.set(abbreviationViewModel); shouldWriteLists = true; } }
private class EditAction extends SimpleCommand { private class EditAction extends SimpleCommand {  private final Actions command;  public EditAction(Actions command) { this.command = command; }  @Override public String toString() { return this.command.toString(); }  @Override public void execute() { Node focusOwner = mainStage.getScene().getFocusOwner(); if (focusOwner != null) { if (focusOwner instanceof TextInputControl) { // Focus is on text field -> copy/paste/cut selected text TextInputControl textInput = (TextInputControl) focusOwner; switch (command) { case COPY: textInput.copy(); break; case CUT: textInput.cut(); break; case PASTE: // handled by FX in TextInputControl#paste break; default: throw new IllegalStateException("Only cut/copy/paste supported but got " + command); } } else { // Not sure what is selected -> copy/paste/cut selected entries switch (command) { case COPY: getCurrentBasePanel().copy(); break; case CUT: getCurrentBasePanel().cut(); break; case PASTE: // handled by FX in TextInputControl#paste break; default: throw new IllegalStateException("Only cut/copy/paste supported but got " + command); } } } } }
public ObjectBinding<T> orElse(T other) { public ObjectBinding<T> orElse(T other) { return new PreboundBinding<T>(this) { @Override protected T computeValue() { return OptionalObjectProperty.this.getValue().orElse(other); } }; }
public class OldDatabaseCommandWrapper extends CommandBase { public class OldDatabaseCommandWrapper extends CommandBase {  private static final Logger LOGGER = LoggerFactory.getLogger(OldDatabaseCommandWrapper.class);  private final Actions command; private final JabRefFrame frame;  public OldDatabaseCommandWrapper(Actions command, JabRefFrame frame, StateManager stateManager) { this.command = command; this.frame = frame;  this.executable.bind( EasyBind.map(stateManager.activeDatabaseProperty(), Optional::isPresent)); }  @Override public void execute() { if (frame.getTabbedPane().getTabs().size() > 0) { try { frame.getCurrentBasePanel().runCommand(command); } catch (Throwable ex) { LOGGER.error("Problem with executing command: " + command, ex); } } else { LOGGER.info("Action '" + command + "' must be disabled when no database is open."); } }  @Override public double getProgress() { return 0; }  @Override public String toString() { return this.command.toString(); }  @Override public ReadOnlyDoubleProperty progressProperty() { return null; } }

