"public static void showContextMenu(TextArea textArea, ContextMenu contextMenu, ContextMenuEvent e) { double screenX = e.getScreenX(); double screenY = e.getScreenY(); double sceneX = e.getSceneX();  TextAreaSkin skin = (TextAreaSkin) textArea.getSkin();  if (Properties.IS_TOUCH_SUPPORTED) { Point2D menuPos; if (textArea.getSelection().getLength() == 0) { skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false); menuPos = skin.getMenuPosition(); } else { menuPos = skin.getMenuPosition(); if (menuPos != null && (menuPos.getX() <= 0 || menuPos.getY() <= 0)) { skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false); menuPos = skin.getMenuPosition(); } }  if (menuPos != null) { Point2D p = textArea.localToScene(menuPos); Scene scene = textArea.getScene(); Window window = scene.getWindow(); Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(), window.getY() + scene.getY() + p.getY()); screenX = location.getX(); sceneX = p.getX(); screenY = location.getY(); } }  double menuWidth = contextMenu.prefWidth(-1); double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0); Screen currentScreen = Screen.getPrimary(); Rectangle2D bounds = currentScreen.getBounds();  if (menuX < bounds.getMinX()) { textArea.getProperties().put("CONTEXT_MENU_SCREEN_X", screenX); textArea.getProperties().put("CONTEXT_MENU_SCENE_X", sceneX); contextMenu.show(textArea, bounds.getMinX(), screenY); } else if (screenX + menuWidth > bounds.getMaxX()) { double leftOver = menuWidth - (bounds.getMaxX() - screenX); textArea.getProperties().put("CONTEXT_MENU_SCREEN_X", screenX); textArea.getProperties().put("CONTEXT_MENU_SCENE_X", sceneX); contextMenu.show(textArea, screenX - leftOver, screenY); } else { textArea.getProperties().put("CONTEXT_MENU_SCREEN_X", 0); textArea.getProperties().put("CONTEXT_MENU_SCENE_X", 0); contextMenu.show(textArea, menuX, screenY); } }"


"private boolean confirmClose(BasePanel panel) { String filename = panel.getBibDatabaseContext() .getDatabasePath() .map(Path::toAbsolutePath) .map(Path::toString) .orElse(GUIGlobals.UNTITLED_TITLE);  ButtonType saveChanges = new ButtonType(Localization.lang("Save changes"), ButtonBar.ButtonData.YES); ButtonType discardChanges = new ButtonType(Localization.lang("Discard changes"), ButtonBar.ButtonData.NO); ButtonType cancel = new ButtonType(Localization.lang("Return to JabRef"), ButtonBar.ButtonData.CANCEL_CLOSE);  Optional<ButtonType> response = dialogService.showCustomButtonDialogAndWait(Alert.AlertType.CONFIRMATION, Localization.lang("Save before closing"), Localization.lang("Library '%0' has changed.", filename), saveChanges, discardChanges, cancel);  if (response.isPresent() && response.get().equals(saveChanges)) { // The user wants to save. try { SaveDatabaseAction saveAction = new SaveDatabaseAction(panel, Globals.prefs, Globals.entryTypesManager); if (saveAction.save()) { // Saved, now exit. return true; } // The action was either canceled or unsuccessful. dialogService.notify(Localization.lang("Unable to save library")); } catch (Throwable ex) { LOGGER.error("A problem occurred when trying to save the file", ex); dialogService.showErrorDialogAndWait(Localization.lang("Save library"), Localization.lang("Could not save file."), ex); } // Save was cancelled or an error occurred. return false; } return !response.isPresent() || !response.get().equals(cancel); }"







"public class DefaultFileUpdateMonitor implements Runnable, FileUpdateMonitor {  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultFileUpdateMonitor.class);  private final Multimap<Path, FileUpdateListener> listeners = ArrayListMultimap.create(20, 4); private WatchService watcher;  @Override public void run() { try (WatchService watcher = FileSystems.getDefault().newWatchService()) { this.watcher = watcher; while (true) { WatchKey key; try { key = watcher.take(); } catch (InterruptedException e) { return; }  for (WatchEvent<?> event : key.pollEvents()) { WatchEvent.Kind<?> kind = event.kind();  if (kind == StandardWatchEventKinds.OVERFLOW) { Thread.yield(); continue; } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) { // We only handle "ENTRY_MODIFY" here, so the context is always a Path @SuppressWarnings("unchecked") WatchEvent<Path> ev = (WatchEvent<Path>) event; Path path = ((Path) key.watchable()).resolve(ev.context()); notifyAboutChange(path); } key.reset(); } Thread.yield(); } } catch (Throwable e) { LOGGER.error("FileUpdateMonitor has been interrupted.", e); } }  private void notifyAboutChange(Path path) { listeners.get(path).forEach(FileUpdateListener::fileUpdated); }  @Override public void addListenerForFile(Path file, FileUpdateListener listener) throws IOException { if (watcher == null) { throw new IllegalStateException("You need to start the file monitor before watching files"); }  // We can't watch files directly, so monitor their parent directory for updates Path directory = file.toAbsolutePath().getParent(); directory.register(watcher, StandardWatchEventKinds.ENTRY_MODIFY); listeners.put(file, listener); }  @Override public void removeListener(Path path, FileUpdateListener listener) { listeners.remove(path, listener); } }"

"public static <A, B> MappedList<B, A> mapBacked(ObservableList<A> source, Function<A, B> mapper) { return new MappedList<>(source, mapper); }"
"public BackgroundTask<V> onFailure(Consumer<Exception> onException) { this.onException = onException; return this; }"





"void storeSettings();"


"public MergeEntries(BibEntry entryLeft, BibEntry entryRight, String headingLeft, String headingRight, BibDatabaseMode type) { this.leftEntry = entryLeft; this.rightEntry = entryRight;  initialize(); setLeftHeaderText(headingLeft); setRightHeaderText(headingRight); }"

"public boolean dragDroppedInChosenCell(PreviewLayout targetLayout, Dragboard dragboard) { boolean success = false;  if (dragboard.hasContent(DragAndDropDataFormats.PREVIEWLAYOUTS)) { List<PreviewLayout> draggedSelectedLayouts = new ArrayList<>(localDragboard.getPreviewLayouts()); if (!draggedSelectedLayouts.isEmpty()) {  int targetId = chosenListProperty.getValue().indexOf(targetLayout);  // see https://stackoverflow.com/questions/28603224/sort-tableview-with-drag-and-drop-rows int onSelectedDelta = 0; while (draggedSelectedLayouts.contains(targetLayout)) { onSelectedDelta = 1; targetId--; if (targetId < 0) { targetId = 0; targetLayout = null; break; } targetLayout = chosenListProperty.getValue().get(targetId); }  dragSourceList.getValue().removeAll(draggedSelectedLayouts);  if (targetLayout != null) { targetId = chosenListProperty.getValue().indexOf(targetLayout) + onSelectedDelta; } else if (targetId != 0) { targetId = chosenListProperty.getValue().size(); }  chosenListProperty.getValue().addAll(targetId, draggedSelectedLayouts);  chosenSelectionModelProperty.getValue().clearSelection(); draggedSelectedLayouts.forEach(layout -> chosenSelectionModelProperty.getValue().select(layout));  success = true; } }  return success; }"
"public class BindingsHelper {  private BindingsHelper() { }  public static <T> BooleanBinding any(ObservableList<T> source, Predicate<T> predicate) { return Bindings.createBooleanBinding(() -> source.stream().anyMatch(predicate), source); }  public static <T> BooleanBinding all(ObservableList<T> source, Predicate<T> predicate) { // Stream.allMatch() (in contrast to Stream.anyMatch() returns 'true' for empty streams, so this has to be checked explicitly. return Bindings.createBooleanBinding(() -> !source.isEmpty() && source.stream().allMatch(predicate), source); }  public static void includePseudoClassWhen(Node node, PseudoClass pseudoClass, ObservableValue<? extends Boolean> condition) { Consumer<Boolean> changePseudoClass = value -> node.pseudoClassStateChanged(pseudoClass, value); EasyBind.subscribe(condition, changePseudoClass);  // Put the pseudo class there depending on the current value changePseudoClass.accept(condition.getValue()); }  /** * Creates a new list in which each element is converted using the provided mapping. * All changes to the underlying list are propagated to the converted list. * * In contrast to {@link org.fxmisc.easybind.EasyBind#map(ObservableList, Function)}, * the items are converted when the are inserted (and at the initialization) instead of when they are accessed. * Thus the initial CPU overhead and memory consumption is higher but the access to list items is quicker. */ public static <A, B> MappedList<B, A> mapBacked(ObservableList<A> source, Function<A, B> mapper) { return new MappedList<>(source, mapper); }  public static <T, U> ObservableList<U> map(ObservableValue<T> source, Function<T, List<U>> mapper) { PreboundBinding<List<U>> binding = new PreboundBinding<List<U>>(source) {  @Override protected List<U> computeValue() { return mapper.apply(source.getValue()); } };  ObservableList<U> list = FXCollections.observableArrayList(); binding.addListener((observable, oldValue, newValue) -> list.setAll(newValue)); return list; }  /** * Binds propertA bidirectional to propertyB using the provided map functions to convert between them. */ public static <A, B> void bindBidirectional(Property<A> propertyA, Property<B> propertyB, Function<A, B> mapAtoB, Function<B, A> mapBtoA) { Consumer<B> updateA = newValueB -> propertyA.setValue(mapBtoA.apply(newValueB)); Consumer<A> updateB = newValueA -> propertyB.setValue(mapAtoB.apply(newValueA)); bindBidirectional(propertyA, propertyB, updateA, updateB); }  /** * Binds propertA bidirectional to propertyB while using updateB to update propertyB when propertyA changed. */ public static <A> void bindBidirectional(Property<A> propertyA, ObservableValue<A> propertyB, Consumer<A> updateB) { bindBidirectional(propertyA, propertyB, propertyA::setValue, updateB); }  /** * Binds propertA bidirectional to propertyB using updateB to update propertyB when propertyA changed and similar * for updateA. */ public static <A, B> void bindBidirectional(ObservableValue<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<A> updateB) { final BidirectionalBinding<A, B> binding = new BidirectionalBinding<>(propertyA, propertyB, updateA, updateB);  // use updateB as initial source updateA.accept(propertyB.getValue());  propertyA.addListener(binding.getChangeListenerA()); propertyB.addListener(binding.getChangeListenerB()); }  public static <A, B> void bindContentBidirectional(ObservableList<A> propertyA, ListProperty<B> propertyB, Consumer<ObservableList<B>> updateA, Consumer<List<A>> updateB) { bindContentBidirectional( propertyA, (ObservableValue<ObservableList<B>>) propertyB, updateA, updateB); }  public static <A, B> void bindContentBidirectional(ObservableList<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<List<A>> updateB) { final BidirectionalListBinding<A, B> binding = new BidirectionalListBinding<>(propertyA, propertyB, updateA, updateB);  // use property as initial source updateA.accept(propertyB.getValue());  propertyA.addListener(binding); propertyB.addListener(binding); }  public static <A, B> void bindContentBidirectional(ListProperty<A> listProperty, Property<B> property, Function<List<A>, B> mapToB, Function<B, List<A>> mapToList) { Consumer<B> updateList = newValueB -> listProperty.setAll(mapToList.apply(newValueB)); Consumer<List<A>> updateB = newValueList -> property.setValue(mapToB.apply(newValueList));  bindContentBidirectional( listProperty, property, updateList, updateB); }  public static <A, V, B> void bindContentBidirectional(ObservableMap<A, V> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<Map<A, V>> updateB) { final BidirectionalMapBinding<A, V, B> binding = new BidirectionalMapBinding<>(propertyA, propertyB, updateA, updateB);  // use list as initial source updateB.accept(propertyA);  propertyA.addListener(binding); propertyB.addListener(binding); }  public static <A, V, B> void bindContentBidirectional(ObservableMap<A, V> propertyA, Property<B> propertyB, Consumer<B> updateA, Function<Map<A, V>, B> mapToB) { Consumer<Map<A, V>> updateB = newValueList -> propertyB.setValue(mapToB.apply(newValueList)); bindContentBidirectional( propertyA, propertyB, updateA, updateB); }  public static <T> ObservableValue<T> constantOf(T value) { return new ObjectBinding<T>() {  @Override protected T computeValue() { return value; } }; }  public static ObservableValue<Boolean> constantOf(boolean value) { return new BooleanBinding() {  @Override protected boolean computeValue() { return value; } }; }  public static ObservableValue<? extends String> emptyString() { return new StringBinding() {  @Override protected String computeValue() { return ""; } }; }  /** * Returns a wrapper around the given list that posts changes on the JavaFX thread. */ public static <T> ObservableList<T> forUI(ObservableList<T> list) { return new UiThreadList<>(list); }  public static <T> ObservableValue<T> ifThenElse(ObservableValue<Boolean> condition, T value, T other) { return EasyBind.map(condition, conditionValue -> { if (conditionValue) { return value; } else { return other; } }); }  private static class BidirectionalBinding<A, B> {  private final ObservableValue<A> propertyA; private final Consumer<B> updateA; private final Consumer<A> updateB; private boolean updating = false;  public BidirectionalBinding(ObservableValue<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<A> updateB) { this.propertyA = propertyA; this.updateA = updateA; this.updateB = updateB; }  public ChangeListener<? super A> getChangeListenerA() { return this::changedA; }  public ChangeListener<? super B> getChangeListenerB() { return this::changedB; }  public void changedA(ObservableValue<? extends A> observable, A oldValue, A newValue) { updateLocked(updateB, oldValue, newValue); }  public void changedB(ObservableValue<? extends B> observable, B oldValue, B newValue) { updateLocked(updateA, oldValue, newValue); }  private <T> void updateLocked(Consumer<T> update, T oldValue, T newValue) { if (!updating) { try { updating = true; update.accept(newValue); } finally { updating = false; } } } }  private static class BidirectionalListBinding<A, B> implements ListChangeListener<A>, ChangeListener<B> {  private final ObservableList<A> listProperty; private final ObservableValue<B> property; private final Consumer<B> updateA; private final Consumer<List<A>> updateB; private boolean updating = false;  public BidirectionalListBinding(ObservableList<A> listProperty, ObservableValue<B> property, Consumer<B> updateA, Consumer<List<A>> updateB) { this.listProperty = listProperty; this.property = property; this.updateA = updateA; this.updateB = updateB; }  @Override public void changed(ObservableValue<? extends B> observable, B oldValue, B newValue) { if (!updating) { try { updating = true; updateA.accept(newValue); } finally { updating = false; } } }  @Override public void onChanged(Change<? extends A> c) { if (!updating) { try { updating = true; updateB.accept(listProperty); } finally { updating = false; } } } }  private static class BidirectionalMapBinding<A, V, B> implements MapChangeListener<A, V>, ChangeListener<B> {  private final ObservableMap<A, V> mapProperty; private final ObservableValue<B> property; private final Consumer<B> updateA; private final Consumer<Map<A, V>> updateB; private boolean updating = false;  public BidirectionalMapBinding(ObservableMap<A, V> mapProperty, ObservableValue<B> property, Consumer<B> updateA, Consumer<Map<A, V>> updateB) { this.mapProperty = mapProperty; this.property = property; this.updateA = updateA; this.updateB = updateB; }  @Override public void changed(ObservableValue<? extends B> observable, B oldValue, B newValue) { if (!updating) { try { updating = true; updateA.accept(newValue); } finally { updating = false; } } }  @Override public void onChanged(Change<? extends A, ? extends V> c) { if (!updating) { try { updating = true; updateB.accept(mapProperty); } finally { updating = false; } } } } }"
"public static List<Text> formatToTexts(String original, TextReplacement... replacements) { List<Text> textList = new ArrayList<>(); textList.add(new Text(original)); for (TextReplacement replacement : replacements) { splitReplace(textList, replacement); }  return textList; }"
"public void copyLog(List<LogEventViewModel> messages) { if (messages.isEmpty()) { return; } clipBoardManager.setContent(getLogMessagesAsString(messages)); dialogService.notify(Localization.lang("Log copied to clipboard.")); }"


"public class BibEntrySuggestionProvider extends SuggestionProvider<BibEntry> implements AutoCompleteSuggestionProvider<BibEntry> {  @Override public void indexEntry(BibEntry entry) { if (entry == null) { return; }  addPossibleSuggestions(entry); }  @Override protected Comparator<BibEntry> getComparator() { return new EntryComparator(false, true, InternalField.KEY_FIELD); }  @Override protected boolean isMatch(BibEntry suggestion, AutoCompletionBinding.ISuggestionRequest request) { String userTextLower = request.getUserText().toLowerCase(); return suggestion.getCiteKeyOptional() .map(key -> key.toLowerCase().contains(userTextLower)) .orElse(false); } }"

"public void addAbbreviation(String name, String abbreviation) { Abbreviation abbreviationObject = new Abbreviation(name, abbreviation); AbbreviationViewModel abbreviationViewModel = new AbbreviationViewModel(abbreviationObject); if (abbreviations.contains(abbreviationViewModel)) { dialogService.showErrorDialogAndWait(Localization.lang("Duplicated Journal Abbreviation"), Localization.lang("Abbreviation %s for journal %s already defined.", abbreviation, name)); } else { abbreviations.add(abbreviationViewModel); currentAbbreviation.set(abbreviationViewModel); shouldWriteLists = true; } }"
"private class EditAction extends SimpleCommand {  private final Actions command;  public EditAction(Actions command) { this.command = command; }  @Override public String toString() { return this.command.toString(); }  @Override public void execute() { Node focusOwner = mainStage.getScene().getFocusOwner(); if (focusOwner != null) { if (focusOwner instanceof TextInputControl) { // Focus is on text field -> copy/paste/cut selected text TextInputControl textInput = (TextInputControl) focusOwner; switch (command) { case COPY: textInput.copy(); break; case CUT: textInput.cut(); break; case PASTE: // handled by FX in TextInputControl#paste break; default: throw new IllegalStateException("Only cut/copy/paste supported but got " + command); } } else { // Not sure what is selected -> copy/paste/cut selected entries switch (command) { case COPY: getCurrentBasePanel().copy(); break; case CUT: getCurrentBasePanel().cut(); break; case PASTE: // handled by FX in TextInputControl#paste break; default: throw new IllegalStateException("Only cut/copy/paste supported but got " + command); } } } } }"
"public ObjectBinding<T> orElse(T other) { return new PreboundBinding<T>(this) { @Override protected T computeValue() { return OptionalObjectProperty.this.getValue().orElse(other); } }; }"
"public class OldDatabaseCommandWrapper extends CommandBase {  private static final Logger LOGGER = LoggerFactory.getLogger(OldDatabaseCommandWrapper.class);  private final Actions command; private final JabRefFrame frame;  public OldDatabaseCommandWrapper(Actions command, JabRefFrame frame, StateManager stateManager) { this.command = command; this.frame = frame;  this.executable.bind( EasyBind.map(stateManager.activeDatabaseProperty(), Optional::isPresent)); }  @Override public void execute() { if (frame.getTabbedPane().getTabs().size() > 0) { try { frame.getCurrentBasePanel().runCommand(command); } catch (Throwable ex) { LOGGER.error("Problem with executing command: " + command, ex); } } else { LOGGER.info("Action '" + command + "' must be disabled when no database is open."); } }  @Override public double getProgress() { return 0; }  @Override public String toString() { return this.command.toString(); }  @Override public ReadOnlyDoubleProperty progressProperty() { return null; } }"

"abstract class FieldsEditorTab extends EntryEditorTab { public PreviewPanel previewPanel; protected final BibDatabaseContext databaseContext; private final Map<Field, FieldEditorFX> editors = new LinkedHashMap<>(); private final boolean isCompressed; private final SuggestionProviders suggestionProviders; private final DialogService dialogService; private FieldEditorFX activeField; private UndoManager undoManager; private Collection<Field> fields = new ArrayList<>(); private GridPane gridPane;  public FieldsEditorTab(boolean compressed, BibDatabaseContext databaseContext, SuggestionProviders suggestionProviders, UndoManager undoManager, DialogService dialogService) { this.isCompressed = compressed; this.databaseContext = databaseContext; this.suggestionProviders = suggestionProviders; this.undoManager = undoManager; this.dialogService = dialogService; }  private static void addColumn(GridPane gridPane, int columnIndex, List<Label> nodes) { gridPane.addColumn(columnIndex, nodes.toArray(new Node[nodes.size()])); }  private static void addColumn(GridPane gridPane, int columnIndex, Stream<Parent> nodes) { gridPane.addColumn(columnIndex, nodes.toArray(Node[]::new)); }  private void setupPanel(BibEntry entry, boolean compressed, SuggestionProviders suggestionProviders, UndoManager undoManager) { // The preferences might be not initialized in tests -> return immediately // TODO: Replace this ugly workaround by proper injection propagation if (Globals.prefs == null) { return; }  editors.clear(); gridPane.getChildren().clear(); gridPane.getColumnConstraints().clear(); gridPane.getRowConstraints().clear();  fields = determineFieldsToShow(entry);  List<Label> labels = new ArrayList<>(); boolean isFirstField = true; for (Field field : fields) { FieldEditorFX fieldEditor = FieldEditors.getForField(field, Globals.TASK_EXECUTOR, dialogService, Globals.journalAbbreviationLoader.getRepository(Globals.prefs.getJournalAbbreviationPreferences()), Globals.prefs, databaseContext, entry.getType(), suggestionProviders, undoManager); fieldEditor.bindToEntry(entry);  editors.put(field, fieldEditor); if (isFirstField) { activeField = fieldEditor; isFirstField = false; }  labels.add(new FieldNameLabel(field)); }  ColumnConstraints columnExpand = new ColumnConstraints(); columnExpand.setHgrow(Priority.ALWAYS);  ColumnConstraints columnDoNotContract = new ColumnConstraints(); columnDoNotContract.setMinWidth(Region.USE_PREF_SIZE); int rows; if (compressed) { rows = (int) Math.ceil((double) fields.size() / 2);  addColumn(gridPane, 0, labels.subList(0, rows)); addColumn(gridPane, 3, labels.subList(rows, labels.size())); addColumn(gridPane, 1, editors.values().stream().map(FieldEditorFX::getNode).limit(rows)); addColumn(gridPane, 4, editors.values().stream().map(FieldEditorFX::getNode).skip(rows));  gridPane.getColumnConstraints().addAll(columnDoNotContract, columnExpand, new ColumnConstraints(10), columnDoNotContract, columnExpand);  setCompressedRowLayout(gridPane, rows); } else { addColumn(gridPane, 0, labels); addColumn(gridPane, 1, editors.values().stream().map(FieldEditorFX::getNode));  gridPane.getColumnConstraints().addAll(columnDoNotContract, columnExpand);  setRegularRowLayout(gridPane); } }  private void setRegularRowLayout(GridPane gridPane) { double totalWeight = fields.stream() .mapToDouble(field -> editors.get(field).getWeight()) .sum();  List<RowConstraints> constraints = new ArrayList<>(); for (Field field : fields) { RowConstraints rowExpand = new RowConstraints(); rowExpand.setVgrow(Priority.ALWAYS); rowExpand.setValignment(VPos.TOP); rowExpand.setPercentHeight(100 * editors.get(field).getWeight() / totalWeight); constraints.add(rowExpand); } gridPane.getRowConstraints().addAll(constraints); }  private void setCompressedRowLayout(GridPane gridPane, int rows) { RowConstraints rowExpand = new RowConstraints(); rowExpand.setVgrow(Priority.ALWAYS); rowExpand.setValignment(VPos.TOP); if (rows == 0) { rowExpand.setPercentHeight(100); } else { rowExpand.setPercentHeight(100 / (double) rows); } for (int i = 0; i < rows; i++) { gridPane.getRowConstraints().add(rowExpand); } }  /** * Focuses the given field. */ public void requestFocus(Field fieldName) { if (editors.containsKey(fieldName)) { activeField = editors.get(fieldName); activeField.focus(); } }  @Override public boolean shouldShow(BibEntry entry) { return !determineFieldsToShow(entry).isEmpty(); }  @Override public void handleFocus() { if (activeField != null) { activeField.focus(); } }  @Override protected void bindToEntry(BibEntry entry) { Optional<Field> selectedFieldName = editors.entrySet() .stream() .filter(editor -> editor.getValue().childIsFocused()) .map(Map.Entry::getKey) .findFirst();  initPanel(); setupPanel(entry, isCompressed, suggestionProviders, undoManager);  previewPanel.setEntry(entry);  Platform.runLater(() -> { // Restore focus to field (run this async so that editor is already initialized correctly) selectedFieldName.ifPresent(this::requestFocus); }); }  protected abstract SortedSet<Field> determineFieldsToShow(BibEntry entry);  public Collection<Field> getShownFields() { return fields; }  private void initPanel() { if (gridPane == null) { gridPane = new GridPane(); gridPane.getStyleClass().add("editorPane");  previewPanel = new PreviewPanel(databaseContext, null, dialogService, ExternalFileTypes.getInstance(), Globals.getKeyPrefs(), Globals.prefs.getPreviewPreferences());  // Warp everything in a scroll-pane ScrollPane scrollPane = new ScrollPane(); scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER); scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED); scrollPane.setContent(gridPane); scrollPane.setFitToWidth(true); scrollPane.setFitToHeight(true);  SplitPane container = new SplitPane(scrollPane, previewPanel);  setContent(container); } } }"

"public void clearLog() { LogMessages.getInstance().clear(); }"
"public boolean setNewBinding(KeyEvent evt) { // validate the shortcut is no modifier key  KeyCode code = evt.getCode(); if (code.isModifierKey() || (code == KeyCode.BACK_SPACE) || (code == KeyCode.SPACE) || (code == KeyCode.TAB) || (code == KeyCode.ENTER) || (code == KeyCode.UNDEFINED)) { return false; }  // gather the pressed modifier keys String modifiers = ""; if (evt.isControlDown()) { modifiers = "ctrl+"; } if (evt.isShiftDown()) { modifiers += "shift+"; } if (evt.isAltDown()) { modifiers += "alt+"; }  // if no modifier keys are pressed, only special keys can be shortcuts if (modifiers.isEmpty()) { if (!(code.isFunctionKey() || (code == KeyCode.ESCAPE) || (code == KeyCode.DELETE))) { return false; } }  String newShortcut = modifiers + code; setBinding(newShortcut);  return true; }"



"public static SearchDescriber getSearchDescriberFor(SearchQuery searchQuery) { if (searchQuery.getRule() instanceof GrammarBasedSearchRule) { GrammarBasedSearchRule grammarBasedSearchRule = (GrammarBasedSearchRule) searchQuery.getRule();  return new GrammarBasedSearchRuleDescriber(grammarBasedSearchRule.isCaseSensitiveSearch(), grammarBasedSearchRule.isRegExpSearch(), grammarBasedSearchRule.getTree()); } else if (searchQuery.getRule() instanceof ContainBasedSearchRule) { ContainBasedSearchRule containBasedSearchRule = (ContainBasedSearchRule) searchQuery.getRule();  return new ContainsAndRegexBasedSearchRuleDescriber(containBasedSearchRule.isCaseSensitive(), false, searchQuery.getQuery()); } else if (searchQuery.getRule() instanceof RegexBasedSearchRule) { RegexBasedSearchRule regexBasedSearchRule = (RegexBasedSearchRule) searchQuery.getRule();  return new ContainsAndRegexBasedSearchRuleDescriber(regexBasedSearchRule.isCaseSensitive(), true, searchQuery.getQuery()); } else { throw new IllegalStateException("Cannot find a describer for searchRule " + searchQuery.getRule() + " and query " + searchQuery.getQuery()); } }"
"private int replaceItem(BibEntry entry, NamedCompound compound) { int counter = 0; if (this.allFieldReplace) { for (Field field : entry.getFields()) { counter += replaceField(entry, field, compound); } } else { for (Field espField : fields) { counter += replaceField(entry, espField, compound); } } return counter; }"

"public SortedMap<KeyBinding, String> getKeyBindings() { return new TreeMap<>(bindings); }"


"private static void addGroups(GroupTreeNode newGroups, CompoundEdit ce) {  // paranoia: ensure that there are never two instances of AllEntriesGroup if (newGroups.getGroup() instanceof AllEntriesGroup) { return; // this should be impossible anyway }  Globals.stateManager.getActiveDatabase() .map(BibDatabaseContext::getMetaData) .flatMap(MetaData::getGroups) .ifPresent(newGroups::moveTo);  //UndoableAddOrRemoveGroup undo = new UndoableAddOrRemoveGroup(groupsRoot, //        new GroupTreeNodeViewModel(newGroups), UndoableAddOrRemoveGroup.ADD_NODE); //ce.addEdit(undo); }"
"public List<FieldChange> addEntriesToGroup(List<BibEntry> entries) { return node.addEntriesToGroup(entries); }"






"public class CustomLocalDragboard {  @SuppressWarnings("unchecked") private static final Class<List<BibEntry>> BIB_ENTRIES = (Class<List<BibEntry>>) (Class<?>) List.class;  private final Map<Class<?>, Object> contents = new HashMap<>();  /** * Puts the value of the concrete class in a map. All previous content stored in the map is removed * @param type The Type of the class * @param value The value to store */ public <T> void putValue(Class<T> type, T value) { clearAll(); contents.put(type, type.cast(value)); }  public <T> T getValue(Class<T> type) { return type.cast(contents.get(type)); }  public boolean hasType(Class<?> type) { return contents.containsKey(type); }  public void clear(Class<?> type) { contents.remove(type); }  public void clearAll() { contents.clear(); }  /** * Puts A List of {@link BibEntry} in the map * All previous content is cleared * @param entries The list to put */ public void putBibEntries(List<BibEntry> entries) { putValue(BIB_ENTRIES, entries); }  /** * Get a List of {@link BibEntry} from the dragboard * @return List of BibEntry or empty list if no entries are avaiable */ public List<BibEntry> getBibEntries() { if (hasBibEntries()) { return getValue(BIB_ENTRIES); } return Collections.emptyList(); }  public boolean hasBibEntries() { return hasType(BIB_ENTRIES); }  /** * Puts A List of {@link PreviewLayout} in the map All previous content is cleared * * @param previewLayouts The list to put */ public void putPreviewLayouts(List<PreviewLayout> previewLayouts) { putValue(DragAndDropDataFormats.PREVIEWLAYOUT_LIST_CLASS, previewLayouts); }  /** * Get a List of {@link PreviewLayout} from the dragboard * * @return List of PreviewLayout or empty list if no entries are avaiable */ public List<PreviewLayout> getPreviewLayouts() { if (hasType(DragAndDropDataFormats.PREVIEWLAYOUT_LIST_CLASS)) { return getValue(DragAndDropDataFormats.PREVIEWLAYOUT_LIST_CLASS); } return Collections.emptyList(); } }"
"public void importButtonClicked() { ImportEntriesDialog dialog = new ImportEntriesDialog(databaseContext, BackgroundTask.wrap(() -> new ArrayList<>(resolverResult.getNewEntries())));  dialog.setTitle(Localization.lang("Import entries from LaTeX files")); dialog.showAndWait(); }"
"public class FromAuxDialog extends BaseDialog<Void> {  private final DialogService dialogService; private final BasePanel basePanel; @FXML private ButtonType generateButtonType; private Button generateButton; @FXML private TextField auxFileField; @FXML private ListView<String> notFoundList;  private AuxParserResult auxParserResult; @FXML private TextArea statusInfos;  public FromAuxDialog(JabRefFrame frame) { basePanel = frame.getCurrentBasePanel(); dialogService = frame.getDialogService();  this.setTitle(Localization.lang("AUX file import"));  ViewLoader.view(this) .load() .setAsDialogPane(this);  generateButton = (Button) this.getDialogPane().lookupButton(generateButtonType); generateButton.setDisable(true); generateButton.defaultButtonProperty().bind(generateButton.disableProperty().not()); setResultConverter(button -> { if (button == generateButtonType) { Defaults defaults = new Defaults(Globals.prefs.getDefaultBibDatabaseMode()); BasePanel bp = new BasePanel(frame, BasePanelPreferences.from(Globals.prefs), new BibDatabaseContext(auxParserResult.getGeneratedBibDatabase(), defaults), ExternalFileTypes.getInstance()); frame.addTab(bp, true); dialogService.notify(Localization.lang("New library created.")); } return null; }); }  @FXML private void parseActionPerformed() { notFoundList.getItems().clear(); statusInfos.setText(""); BibDatabase refBase = basePanel.getDatabase(); String auxName = auxFileField.getText();  if ((auxName != null) && (refBase != null) && !auxName.isEmpty()) { AuxParser auxParser = new DefaultAuxParser(refBase); auxParserResult = auxParser.parse(Paths.get(auxName)); notFoundList.getItems().setAll(auxParserResult.getUnresolvedKeys()); statusInfos.setText(new AuxParserResultViewModel(auxParserResult).getInformation(false));  if (!auxParserResult.getGeneratedBibDatabase().hasEntries()) { // The generated database contains no entries -> no active generate-button statusInfos.setText(statusInfos.getText() + "\n" + Localization.lang("empty library")); generateButton.setDisable(true); } else { generateButton.setDisable(false); } } else { generateButton.setDisable(true); } }  @FXML private void browseButtonClicked() { FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .addExtensionFilter(StandardFileType.AUX) .withDefaultExtension(StandardFileType.AUX) .withInitialDirectory(Globals.prefs.get(JabRefPreferences.WORKING_DIRECTORY)).build(); dialogService.showFileOpenDialog(fileDialogConfiguration).ifPresent(file -> auxFileField.setText(file.toAbsolutePath().toString())); }  }"
"public static void showParserResultWarningDialog(final ParserResult parserResult, final JabRefFrame jabRefFrame, final int dataBaseNumber) { Objects.requireNonNull(parserResult); Objects.requireNonNull(jabRefFrame); // Return if no warnings if (!(parserResult.hasWarnings())) { return; } // Switch tab if asked to do so if (dataBaseNumber >= 0) { jabRefFrame.showBasePanelAt(dataBaseNumber); } // Generate string with warning texts final List<String> warnings = parserResult.warnings(); final StringBuilder dialogContent = new StringBuilder(); int warningCount = 1; for (final String warning : warnings) { dialogContent.append(String.format("%d. %s%n", warningCount++, warning)); } dialogContent.deleteCharAt(dialogContent.length() - 1); // Generate dialog title String dialogTitle; if (dataBaseNumber < 0) { dialogTitle = Localization.lang("Warnings"); } else { dialogTitle = Localization.lang("Warnings") + " (" + parserResult.getFile().get().getName() + ")"; } // Show dialog jabRefFrame.getDialogService().showWarningDialogAndWait(dialogTitle, dialogContent.toString());}"





"public void putPreviewLayouts(List<PreviewLayout> previewLayouts) { putValue(DragAndDropDataFormats.PREVIEWLAYOUT_LIST_CLASS, previewLayouts); }"










"private void setCurrentAbbreviationNameAndAbbreviationIfValid(String name, String abbreviation) { if (name.trim().isEmpty()) { dialogService.showErrorDialogAndWait(Localization.lang("Name cannot be empty")); return; } else if (abbreviation.trim().isEmpty()) { dialogService.showErrorDialogAndWait(Localization.lang("Abbreviation cannot be empty")); return; } currentAbbreviation.get().setName(name); currentAbbreviation.get().setAbbreviation(abbreviation); shouldWriteLists = true; }"



" void performAction(BasePanel panel, ParserResult pr);"
"private CheckBoxTreeItem<FileNodeWrapper> searchDirectory(File directory, UnlinkedPDFFileFilter ff) { // Return null if the directory is not valid. if ((directory == null) || !directory.exists() || !directory.isDirectory()) { return null; }  File[] filesArray = directory.listFiles(ff); List<File> files; if (filesArray == null) { files = Collections.emptyList(); } else { files = Arrays.asList(filesArray); } CheckBoxTreeItem<FileNodeWrapper> root = new CheckBoxTreeItem<>(new FileNodeWrapper(directory.toPath(), 0));  int filesCount = 0;  filesArray = directory.listFiles(pathname -> (pathname != null) && pathname.isDirectory()); List<File> subDirectories; if (filesArray == null) { subDirectories = Collections.emptyList(); } else { subDirectories = Arrays.asList(filesArray); } for (File subDirectory : subDirectories) { if (isCanceled()) { return root; }  CheckBoxTreeItem<FileNodeWrapper> subRoot = searchDirectory(subDirectory, ff); if ((subRoot != null) && (!subRoot.getChildren().isEmpty())) { filesCount += subRoot.getValue().fileCount; root.getChildren().add(subRoot); } }  root.setValue(new FileNodeWrapper(directory.toPath(), files.size() + filesCount));  for (File file : files) { root.getChildren().add(new CheckBoxTreeItem<>(new FileNodeWrapper(file.toPath())));  counter++; if (counter == 1) { updateMessage(Localization.lang("One file found")); } else { updateMessage(Localization.lang("%0 files found", Integer.toString(counter))); } }  return root; }"
"private void addLinkedFileFromURL(URL url, BibEntry entry, Path targetDirectory) { LinkedFile newLinkedFile = new LinkedFile(url, "");  if (!entry.getFiles().contains(newLinkedFile)) {  LinkedFileViewModel onlineFile = new LinkedFileViewModel( newLinkedFile, entry, basePanel.getBibDatabaseContext(), Globals.TASK_EXECUTOR, dialogService, JabRefPreferences.getInstance().getXMPPreferences(), JabRefPreferences.getInstance().getFilePreferences(), ExternalFileTypes.getInstance());  try { URLDownload urlDownload = new URLDownload(newLinkedFile.getLink()); BackgroundTask<Path> downloadTask = onlineFile.prepareDownloadTask(targetDirectory, urlDownload); downloadTask.onSuccess(destination -> { LinkedFile downloadedFile = LinkedFilesEditorViewModel.fromFile( destination, basePanel.getBibDatabaseContext().getFileDirectoriesAsPaths(JabRefPreferences.getInstance().getFilePreferences()), ExternalFileTypes.getInstance()); entry.addFile(downloadedFile); dialogService.notify(Localization.lang("Finished downloading full text document for entry %0.", entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); }); Globals.TASK_EXECUTOR.execute(downloadTask); } catch (MalformedURLException exception) { dialogService.showErrorDialogAndWait(Localization.lang("Invalid URL"), exception); } } else { dialogService.notify(Localization.lang("Full text document for entry %0 already linked.", entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); } }"

"public SuggestionProviderString(Callback<T, String> stringConverter) { this.stringConverter = stringConverter;  // In case no stringConverter was provided, use the default strategy if (this.stringConverter == null) { this.stringConverter = obj -> { return obj != null ? obj.toString() : ""; //$NON-NLS-1$ }; } }"



" public void addNewFile() { FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .addExtensionFilter(StandardFileType.TXT) .build();  dialogService.showFileSaveDialog(fileDialogConfiguration).ifPresent(this::openFile); }"







"public void setValues(AbstractBibtexKeyPattern keyPattern) { for (Map.Entry<EntryType, TextField> entry : textFields.entrySet()) { setValue(entry.getValue(), entry.getKey(), keyPattern); }  if ((keyPattern.getDefaultValue() == null) || keyPattern.getDefaultValue().isEmpty()) { defaultPat.setText(""); } else { defaultPat.setText(keyPattern.getDefaultValue().get(0)); } }"
"public static <T> SuggestionProvider<T> create(Collection<T> possibleSuggestions) { return create(null, possibleSuggestions); }"


" protected static ClipboardContent processRtf(List<String> citations) { String result = "{\\rtf" + OS.NEWLINE + String.join(CitationStyleOutputFormat.RTF.getLineSeparator(), citations) + "}"; ClipboardContent content = new ClipboardContent(); content.putRtf(result); return content; }"

"public static List<MenuItem> getDefaultContextMenuItems(TextInputControl textInputControl) { boolean editable = textInputControl.isEditable(); boolean hasText = (textInputControl.getLength() > 0); boolean hasSelection = (textInputControl.getSelection().getLength() > 0); boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength()); boolean maskText = (textInputControl instanceof PasswordField); // (maskText("A") != "A"); ArrayList<MenuItem> items = new ArrayList<>();  MenuItem cutMI = new MenuItem(Localization.lang("Cut")); cutMI.setOnAction(e -> textInputControl.cut()); MenuItem copyMI = new MenuItem(Localization.lang("Copy")); copyMI.setOnAction(e -> textInputControl.copy()); MenuItem pasteMI = new MenuItem(Localization.lang("Paste")); pasteMI.setOnAction(e -> textInputControl.paste()); MenuItem deleteMI = new MenuItem(Localization.lang("Delete")); deleteMI.setOnAction(e -> { IndexRange selection = textInputControl.getSelection(); textInputControl.deleteText(selection); }); MenuItem selectAllMI = new MenuItem(Localization.lang("Select all")); selectAllMI.setOnAction(e -> textInputControl.selectAll()); MenuItem separatorMI = new SeparatorMenuItem();  if (SHOW_HANDLES) { if (!maskText && hasSelection) { if (editable) { items.add(cutMI); } items.add(copyMI); } if (editable && Clipboard.getSystemClipboard().hasString()) { items.add(pasteMI); } if (hasText && !allSelected) { items.add(selectAllMI); } selectAllMI.getProperties().put("refreshMenu", Boolean.TRUE); } else { if (editable) { items.addAll(Arrays.asList(cutMI, copyMI, pasteMI, deleteMI, separatorMI, selectAllMI)); } else { items.addAll(Arrays.asList(copyMI, separatorMI, selectAllMI)); } cutMI.setDisable(maskText || !hasSelection); copyMI.setDisable(maskText || !hasSelection); pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString()); deleteMI.setDisable(!hasSelection); }  return items; }"

"SearchDisplayMode(Supplier<String> displayName, Supplier<String> toolTipText) { this.displayName = displayName; this.toolTipText = toolTipText; }"





"public class UndoablePreambleChange extends AbstractUndoableJabRefEdit {  private final BibDatabase base; private final String oldValue; private final String newValue;  public UndoablePreambleChange(BibDatabase base, String oldValue, String newValue) { this.base = base; this.oldValue = oldValue; this.newValue = newValue; }  @Override public String getPresentationName() { return Localization.lang("change preamble");  }  @Override public void undo() { super.undo();  // Revert the change. base.setPreamble(oldValue);  }  @Override public void redo() { super.redo();  // Redo the change. base.setPreamble(newValue);  }  }"



"public String getIconName() { return iconName; }"






"public class ViewModelListCellFactory<T> implements Callback<ListView<T>, ListCell<T>> {  private Callback<T, String> toText; private Callback<T, Node> toGraphic; private Callback<T, Tooltip> toTooltip; private BiConsumer<T, ? super MouseEvent> toOnMouseClickedEvent; private Callback<T, String> toStyleClass; private Callback<T, ContextMenu> toContextMenu; private BiConsumer<T, ? super MouseEvent> toOnDragDetected; private BiConsumer<T, ? super DragEvent> toOnDragDropped; private BiConsumer<T, ? super DragEvent> toOnDragEntered; private BiConsumer<T, ? super DragEvent> toOnDragExited; private BiConsumer<T, ? super DragEvent> toOnDragOver; private Map<PseudoClass, Callback<T, ObservableValue<Boolean>>> pseudoClasses = new HashMap<>();  public ViewModelListCellFactory<T> withText(Callback<T, String> toText) { this.toText = toText; return this; }  public ViewModelListCellFactory<T> withGraphic(Callback<T, Node> toGraphic) { this.toGraphic = toGraphic; return this; }  public ViewModelListCellFactory<T> withIcon(Callback<T, JabRefIcon> toIcon) { this.toGraphic = viewModel -> { JabRefIcon icon = toIcon.call(viewModel); if (icon != null) { return icon.getGraphicNode(); } return null; }; return this; }  public ViewModelListCellFactory<T> withIcon(Callback<T, JabRefIcon> toIcon, Callback<T, Color> toColor) { this.toGraphic = viewModel -> {  return toIcon.call(viewModel).withColor(toColor.call(viewModel)).getGraphicNode(); }; return this; }  public ViewModelListCellFactory<T> withStringTooltip(Callback<T, String> toStringTooltip) { this.toTooltip = viewModel -> { String tooltipText = toStringTooltip.call(viewModel); if (StringUtil.isNotBlank(tooltipText)) { return new Tooltip(tooltipText); } return null; }; return this; }  public ViewModelListCellFactory<T> withTooltip(Callback<T, Tooltip> toTooltip) { this.toTooltip = toTooltip; return this; }  public ViewModelListCellFactory<T> withContextMenu(Callback<T, ContextMenu> toContextMenu) { this.toContextMenu = toContextMenu; return this; }  public ViewModelListCellFactory<T> withStyleClass(Callback<T, String> toStyleClass) { this.toStyleClass = toStyleClass; return this; }  public ViewModelListCellFactory<T> withOnMouseClickedEvent(BiConsumer<T, ? super MouseEvent> toOnMouseClickedEvent) { this.toOnMouseClickedEvent = toOnMouseClickedEvent; return this; }  public ViewModelListCellFactory<T> setOnDragDetected(BiConsumer<T, ? super MouseEvent> toOnDragDetected) { this.toOnDragDetected = toOnDragDetected; return this; }  public ViewModelListCellFactory<T> setOnDragDropped(BiConsumer<T, ? super DragEvent> toOnDragDropped) { this.toOnDragDropped = toOnDragDropped; return this; }  public ViewModelListCellFactory<T> setOnDragEntered(BiConsumer<T, ? super DragEvent> toOnDragEntered) { this.toOnDragEntered = toOnDragEntered; return this; }  public ViewModelListCellFactory<T> setOnDragExited(BiConsumer<T, ? super DragEvent> toOnDragExited) { this.toOnDragExited = toOnDragExited; return this; }  public ViewModelListCellFactory<T> setOnDragOver(BiConsumer<T, ? super DragEvent> toOnDragOver) { this.toOnDragOver = toOnDragOver; return this; }  public ViewModelListCellFactory<T> withPseudoClass(PseudoClass pseudoClass, Callback<T, ObservableValue<Boolean>> toCondition) { this.pseudoClasses.putIfAbsent(pseudoClass, toCondition); return this; }  public void install(ComboBox<T> comboBox) { comboBox.setButtonCell(this.call(null)); comboBox.setCellFactory(this); }  public void install(ListView<T> listView) { listView.setCellFactory(this); }  @Override public ListCell<T> call(ListView<T> param) {  return new ListCell<T>() {  @Override protected void updateItem(T item, boolean empty) { super.updateItem(item, empty);  T viewModel = getItem(); if (empty || (viewModel == null)) { setText(null); setGraphic(null); setOnMouseClicked(null); setTooltip(null); } else { if (toText != null) { setText(toText.call(viewModel)); } if (toGraphic != null) { setGraphic(toGraphic.call(viewModel)); } if (toOnMouseClickedEvent != null) { setOnMouseClicked(event -> toOnMouseClickedEvent.accept(viewModel, event)); } if (toStyleClass != null) { getStyleClass().setAll(toStyleClass.call(viewModel)); } if (toTooltip != null) { setTooltip(toTooltip.call(viewModel)); } if (toContextMenu != null) { setContextMenu(toContextMenu.call(viewModel)); } if (toOnDragDetected != null) { setOnDragDetected(event -> toOnDragDetected.accept(viewModel, event)); } if (toOnDragDropped != null) { setOnDragDropped(event -> toOnDragDropped.accept(viewModel, event)); } if (toOnDragEntered != null) { setOnDragEntered(event -> toOnDragEntered.accept(viewModel, event)); } if (toOnDragExited != null) { setOnDragExited(event -> toOnDragExited.accept(viewModel, event)); } if (toOnDragOver != null) { setOnDragOver(event -> toOnDragOver.accept(viewModel, event)); } for (Map.Entry<PseudoClass, Callback<T, ObservableValue<Boolean>>> pseudoClassWithCondition : pseudoClasses.entrySet()) { ObservableValue<Boolean> condition = pseudoClassWithCondition.getValue().call(viewModel); BindingsHelper.includePseudoClassWhen(this, pseudoClassWithCondition.getKey(), condition); } } getListView().refresh(); } }; } }"


"public class WaitForSaveFinishedDialog {  private final DialogService dialogService;  public WaitForSaveFinishedDialog(DialogService dialogService) { this.dialogService = dialogService; }  public void showAndWait(List<BasePanel> basePanels) { if (basePanels.stream().anyMatch(BasePanel::isSaving)) { Task<Void> waitForSaveFinished = new Task<Void>() { @Override protected Void call() throws Exception { while (basePanels.stream().anyMatch(BasePanel::isSaving)) { if (isCancelled()) { return null; } else { Thread.sleep(100); } } return null; } };  dialogService.showProgressDialogAndWait( Localization.lang("Please wait..."), Localization.lang("Waiting for save operation to finish") + "...", waitForSaveFinished ); } } }"


"public class PersistenceVisualStateTable {  private final MainTable mainTable; private final JabRefPreferences preferences; private final Map<String, SortType> columnsSortOrder = new LinkedHashMap<>();  public PersistenceVisualStateTable(final MainTable mainTable, JabRefPreferences preferences) { this.mainTable = mainTable; this.preferences = preferences;  mainTable.getColumns().addListener(this::onColumnsChanged); mainTable.getColumns().forEach(col -> col.sortTypeProperty().addListener(obs -> updateColumnSortType(col.getText(), col.getSortType()))); mainTable.getColumns().forEach(col -> col.widthProperty().addListener(obs -> updateColumnPreferences()));  }  private void onColumnsChanged(ListChangeListener.Change<? extends TableColumn<BibEntryTableViewModel, ?>> change) { boolean changed = false; while (change.next()) { changed = true; }  if (changed) { updateColumnPreferences(); }  }  private void updateColumnSortType(String text, SortType sortType) { columnsSortOrder.put(text, sortType); preferences.setMainTableColumnSortType(columnsSortOrder); }  /** * Store shown columns and their width in preferences. */ private void updateColumnPreferences() { List<String> columnNames = new ArrayList<>(); List<String> columnsWidths = new ArrayList<>();  for (TableColumn<BibEntryTableViewModel, ?> column : mainTable.getColumns()) { if (column instanceof NormalTableColumn) { NormalTableColumn normalColumn = (NormalTableColumn) column;  columnNames.add(normalColumn.getColumnName()); columnsWidths.add(String.valueOf(Double.valueOf(normalColumn.getWidth()).intValue())); } }  if ((columnNames.size() == columnsWidths.size()) && (columnNames.size() == preferences.getStringList(JabRefPreferences.COLUMN_NAMES).size())) { preferences.putStringList(JabRefPreferences.COLUMN_NAMES, columnNames); preferences.putStringList(JabRefPreferences.COLUMN_WIDTHS, columnsWidths); } } }"





"public class JournalAbbreviationsNameTableEditingCell extends TableCell<AbbreviationViewModel, String> {  private TextField textField; private String oldName; private int editingIndex;  @Override public void startEdit() { if (!isEmpty() && viewModel.isAbbreviationEditableAndRemovableProperty().get()) { oldName = viewModel.currentAbbreviationProperty().get().getName(); super.startEdit(); createTextField(); setText(null); setGraphic(textField); editingIndex = journalAbbreviationsTable.getSelectionModel().getSelectedIndex(); textField.requestFocus(); textField.selectAll(); } }  @Override public void cancelEdit() { super.cancelEdit(); setText(getItem()); setGraphic(null); journalAbbreviationsTable.itemsProperty().get().get(editingIndex).setName(oldName); }  @Override public void updateItem(String item, boolean empty) { super.updateItem(item, empty); if (empty) { setText(null); setGraphic(null); } else { if (isEditing()) { if (textField != null) { textField.setText(getString()); } setText(null); setGraphic(textField); } else { setText(getString()); setGraphic(null); } } }  @Override public void commitEdit(String name) { journalAbbreviationsTable.getSelectionModel().select(editingIndex); AbbreviationViewModel current = viewModel.currentAbbreviationProperty().get(); super.commitEdit(name); current.setName(oldName); viewModel.editAbbreviation(name, current.getAbbreviation()); }  private void createTextField() { textField = new TextField(getString()); textField.setMinWidth(this.getWidth() - (this.getGraphicTextGap() * 2)); textField.focusedProperty().addListener((observable, oldValue, newValue) -> { if (!newValue) { commitEdit(textField.getText()); } }); textField.setOnKeyPressed(t -> { if (t.getCode() == KeyCode.ENTER) { if (isEditing()) { journalAbbreviationsTable.requestFocus(); } else { startEdit(); } } else if (t.getCode() == KeyCode.ESCAPE) { cancelEdit(); } }); }  private String getString() { return getItem() == null ? "" : getItem(); } }"


" private GroupHierarchyType getContext() { if (independentButton.isSelected()) { return GroupHierarchyType.INDEPENDENT; } if (intersectionButton.isSelected()) { return GroupHierarchyType.REFINING; } if (unionButton.isSelected()) { return GroupHierarchyType.INCLUDING; } return GroupHierarchyType.INDEPENDENT; // default }"


"private void initialize() { setPrefWidth(800);  setupFields();  fillDiffModes();  GridPane mergePanel = new GridPane(); mergePanel.setVgap(10); mergePanel.setHgap(15); ColumnConstraints columnLabel = new ColumnConstraints(); columnLabel.setHgrow(Priority.NEVER); ColumnConstraints columnValues = new ColumnConstraints(); columnValues.setHgrow(Priority.ALWAYS); columnValues.setPercentWidth(40); ColumnConstraints columnSelect = new ColumnConstraints(); columnSelect.setHgrow(Priority.NEVER); mergePanel.getColumnConstraints().setAll(columnLabel, columnValues, columnSelect, columnSelect, columnSelect, columnValues);  setupHeadingRows(mergePanel); setupEntryTypeRow(mergePanel); setupFieldRows(mergePanel);  ScrollPane scrollPane = new ScrollPane(mergePanel); scrollPane.setFitToWidth(true); setCenter(scrollPane);  updateFieldValues(allFields);  updateMergedEntry();  getStylesheets().add(0, MergeEntries.class.getResource("MergeEntries.css").toExternalForm()); }"
"interface PreferencesTab {  Node getBuilder();  /** * Should return the localized identifier to use for the tab. * * @return Identifier for the tab (for instance "General", "Appearance" or "External Files"). */ String getTabName();  /** * This method is called when the dialog is opened, or if it is made * visible after being hidden. This calls the appropriate method in the * ViewModel. */ void setValues();  /** * This method is called when the user presses OK in the Preferences * dialog. This calls the appropriate method in the ViewModel. */ void storeSettings();  /** * This method is called before the {@link #storeSettings()} method, * to check if there are illegal settings in the tab, or if is ready * to be closed. This calls the appropriate method in the ViewModel. */ boolean validateSettings();  /** * This method should be called after storing the preferences, This * calls the appropriate method in the ViewModel. * * @return The messages for the changed properties (e. g. "Changed language: English") */ List<String> getRestartWarnings(); }"
"void pushEntries(BibDatabaseContext database, List<BibEntry> entries, String keyString);"

"public class MassSetFieldsAction extends SimpleCommand {  private final StateManager stateManager; private DialogService dialogService; private UndoManager undoManager;  public MassSetFieldsAction(StateManager stateManager, DialogService dialogService, UndoManager undoManager) { this.stateManager = stateManager; this.dialogService = dialogService; this.undoManager = undoManager;  this.executable.bind(needsDatabase(stateManager).and(needsEntriesSelected(stateManager))); }  @Override public void execute() { BibDatabaseContext database = stateManager.getActiveDatabase().orElseThrow(() -> new NullPointerException("Database null")); MassSetFieldsDialog dialog = new MassSetFieldsDialog(stateManager.getSelectedEntries(), database, dialogService, undoManager); dialog.showAndWait(); }  }"




"public static void openConsole(File file) throws IOException { if (file == null) { return; }  String absolutePath = file.toPath().toAbsolutePath().getParent().toString(); boolean usingDefault = Globals.prefs.getBoolean(JabRefPreferences.USE_DEFAULT_CONSOLE_APPLICATION);  if (usingDefault) { NATIVE_DESKTOP.openConsole(absolutePath); } else { String command = Globals.prefs.get(JabRefPreferences.CONSOLE_COMMAND); command = command.trim();  if (!command.isEmpty()) { command = command.replaceAll("\\s+", " "); // normalize white spaces command = command.replace("%DIR", absolutePath); // replace the placeholder if used  String[] subcommands = command.split(" ");  LOGGER.info("Executing command \"" + command + "\"..."); JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Executing command \"%0\"...", command));  try { new ProcessBuilder(subcommands).start(); } catch (IOException exception) { LOGGER.error("Open console", exception);  JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Error occured while executing the command \"%0\".", command)); } } } }"

"public boolean quit() { // First ask if the user really wants to close, if the library has not been saved since last save. List<String> filenames = new ArrayList<>(); for (int i = 0; i < tabbedPane.getTabs().size(); i++) { BasePanel panel = getBasePanelAt(i); BibDatabaseContext context = panel.getBibDatabaseContext();  if (panel.isModified() && (context.getLocation() == DatabaseLocation.LOCAL)) { tabbedPane.getSelectionModel().select(i); if (!confirmClose(panel)) { return false; } } else if (context.getLocation() == DatabaseLocation.SHARED) { context.convertToLocalDatabase(); context.getDBMSSynchronizer().closeSharedDatabase(); context.clearDBMSSynchronizer(); } AutosaveManager.shutdown(context); BackupManager.shutdown(context); context.getDatabaseFile().map(File::getAbsolutePath).ifPresent(filenames::add); }  WaitForSaveFinishedDialog waitForSaveFinishedDialog = new WaitForSaveFinishedDialog(dialogService); waitForSaveFinishedDialog.showAndWait(getBasePanelList());  // Good bye! tearDownJabRef(filenames); Platform.exit(); return true; }"

"public abstract class MapBasedEditorViewModel<T> extends OptionEditorViewModel<T> {  private static final Logger LOGGER = LoggerFactory.getLogger(MapBasedEditorViewModel.class);  public MapBasedEditorViewModel(Field field, AutoCompleteSuggestionProvider<?> suggestionProvider, FieldCheckers fieldCheckers) { super(field, suggestionProvider, fieldCheckers); }  protected abstract BiMap<String, T> getItemMap();  @Override public StringConverter<T> getStringConverter() { return new StringConverter<T>() {  @Override public String toString(T object) { if (object == null) { return null; } else { return getItemMap().inverse().getOrDefault(object, object.toString()); //if the object is not found we simply return itself as string } }  @Override public T fromString(String string) { if (string == null) { return null; } else { return getItemMap().getOrDefault(string, getValueFromString(string)); } } }; }  /** * Converts a String value to the Type T. If the type cannot be directly casted to T, this method must be overriden in a subclass * @param string The input value to convert * @return The value or null if the value could not be casted */ @SuppressWarnings("unchecked") protected T getValueFromString(String string) { try { return (T) string; } catch (ClassCastException ex) { LOGGER.error(String.format("Could not cast string to type %1$s. Try overriding the method in a subclass and provide a conversion from string to the concrete type %1$s", string.getClass()), ex); } return null;  }  @Override public List<T> getItems() { return new ArrayList<>(getItemMap().values()); } }"

"public class PersonNameSuggestionProvider extends SuggestionProvider<Author> implements AutoCompleteSuggestionProvider<Author> {  private final Collection<Field> fields; private final Comparator<Author> authorComparator = Comparator.comparing(Author::getNameForAlphabetization);  PersonNameSuggestionProvider(Field fieldName) { this(Collections.singletonList(Objects.requireNonNull(fieldName))); }  public PersonNameSuggestionProvider(Collection<Field> fields) { super();  this.fields = Objects.requireNonNull(fields);  }  @Override public void indexEntry(BibEntry entry) { if (entry == null) { return; }  for (Field field : fields) { entry.getField(field).ifPresent(fieldValue -> { AuthorList authorList = AuthorList.parse(fieldValue); for (Author author : authorList.getAuthors()) { addPossibleSuggestions(author); } }); } }  @Override protected Comparator<Author> getComparator() { return authorComparator; }  @Override protected boolean isMatch(Author suggestion, AutoCompletionBinding.ISuggestionRequest request) { String userTextLower = request.getUserText().toLowerCase(); String suggestionStr = suggestion.getLastFirst(false).toLowerCase(); return suggestionStr.contains(userTextLower); } }"
"public StyleSpans<Collection<String>> computeHighlighting(String text) {  final Pattern XML_TAG = Pattern.compile("(?<ELEMENT>(</?\\h*)(\\w+)([^<>]*)(\\h*/?>))" + "|(?<COMMENT><!--[^<>]+-->)"); final Pattern ATTRIBUTES = Pattern.compile("(\\w+\\h*)(=)(\\h*\"[^\"]+\")");  final int GROUP_OPEN_BRACKET = 2; final int GROUP_ELEMENT_NAME = 3; final int GROUP_ATTRIBUTES_SECTION = 4; final int GROUP_CLOSE_BRACKET = 5; final int GROUP_ATTRIBUTE_NAME = 1; final int GROUP_EQUAL_SYMBOL = 2; final int GROUP_ATTRIBUTE_VALUE = 3;  Matcher matcher = XML_TAG.matcher(text); int lastKeywordEnd = 0; StyleSpansBuilder<Collection<String>> spansBuilder = new StyleSpansBuilder<>(); while (matcher.find()) {  spansBuilder.add(Collections.emptyList(), matcher.start() - lastKeywordEnd); if (matcher.group("COMMENT") != null) { spansBuilder.add(Collections.singleton("comment"), matcher.end() - matcher.start()); } else { if (matcher.group("ELEMENT") != null) { String attributesText = matcher.group(GROUP_ATTRIBUTES_SECTION);  spansBuilder.add(Collections.singleton("tagmark"), matcher.end(GROUP_OPEN_BRACKET) - matcher.start(GROUP_OPEN_BRACKET)); spansBuilder.add(Collections.singleton("anytag"), matcher.end(GROUP_ELEMENT_NAME) - matcher.end(GROUP_OPEN_BRACKET));  if (!attributesText.isEmpty()) {  lastKeywordEnd = 0;  Matcher attributesMatcher = ATTRIBUTES.matcher(attributesText); while (attributesMatcher.find()) { spansBuilder.add(Collections.emptyList(), attributesMatcher.start() - lastKeywordEnd); spansBuilder.add(Collections.singleton("attribute"), attributesMatcher.end(GROUP_ATTRIBUTE_NAME) - attributesMatcher.start(GROUP_ATTRIBUTE_NAME)); spansBuilder.add(Collections.singleton("tagmark"), attributesMatcher.end(GROUP_EQUAL_SYMBOL) - attributesMatcher.end(GROUP_ATTRIBUTE_NAME)); spansBuilder.add(Collections.singleton("avalue"), attributesMatcher.end(GROUP_ATTRIBUTE_VALUE) - attributesMatcher.end(GROUP_EQUAL_SYMBOL)); lastKeywordEnd = attributesMatcher.end(); } if (attributesText.length() > lastKeywordEnd) { spansBuilder.add(Collections.emptyList(), attributesText.length() - lastKeywordEnd); } }  lastKeywordEnd = matcher.end(GROUP_ATTRIBUTES_SECTION);  spansBuilder.add(Collections.singleton("tagmark"), matcher.end(GROUP_CLOSE_BRACKET) - lastKeywordEnd); } } lastKeywordEnd = matcher.end(); } spansBuilder.add(Collections.emptyList(), text.length() - lastKeywordEnd); return spansBuilder.create(); }"
"public void setValues() { for (PreferencesTab preferencesTab : preferenceTabs) { preferencesTab.setValues(); } }"


"private void addImportedEntries(final BasePanel panel, final List<BibEntry> entries) { BackgroundTask<List<BibEntry>> task = BackgroundTask.wrap(() -> entries); ImportEntriesDialog dialog = new ImportEntriesDialog(panel.getBibDatabaseContext(), task); dialog.setTitle(Localization.lang("Import")); dialog.showAndWait(); }"


"class JabRefAction extends org.controlsfx.control.action.Action {  public JabRefAction(Action action, KeyBindingRepository keyBindingRepository) { super(action.getText()); action.getIcon() .ifPresent(icon -> setGraphic(icon.getGraphicNode())); action.getKeyBinding() .ifPresent(keyBinding -> setAccelerator(keyBindingRepository.getKeyCombination(keyBinding)));  setLongText(action.getDescription()); }  public JabRefAction(Action action, Command command, KeyBindingRepository keyBindingRepository) { this(action, command, keyBindingRepository, null); }  /** * especially for the track execute when the action run the same function but from different source. * @param source is a string contains the source, for example "button" */ public JabRefAction(Action action, Command command, KeyBindingRepository keyBindingRepository, Sources source) { this(action, keyBindingRepository);  setEventHandler(event -> { command.execute(); if (source == null) { trackExecute(getActionName(action, command)); } else { trackUserActionSource(getActionName(action, command), source); } });  disabledProperty().bind(command.executableProperty().not());  if (command instanceof SimpleCommand) { SimpleCommand ourCommand = (SimpleCommand) command; longTextProperty().bind(Bindings.concat(action.getDescription(), ourCommand.statusMessageProperty())); } }  private String getActionName(Action action, Command command) { if (command.getClass().isAnonymousClass()) { return action.getText(); } else { String commandName = command.getClass().getSimpleName(); if ((command instanceof OldDatabaseCommandWrapper) || (command instanceof OldCommandWrapper) || commandName.contains("EditAction")) { return command.toString(); } else { return commandName; } } }  private void trackExecute(String actionName) { Globals.getTelemetryClient() .ifPresent(telemetryClient -> telemetryClient.trackEvent(actionName)); }  private void trackUserActionSource(String actionName, Sources source) { Map<String, String> properties = new HashMap<>(); Map<String, Double> measurements = new HashMap<>(); properties.put("Source", source.toString());  Globals.getTelemetryClient().ifPresent(telemetryClient -> telemetryClient.trackEvent(actionName, properties, measurements)); } }"







"protected abstract void initParameters();"
"private final GroupTreeNodeViewModel m_groupsRootHandle;"
"private void onDatabaseChanged(ListChangeListener.Change<? extends BibEntry> change) { calculateNumberOfMatches(); }"




"private TableColumn<BibEntryTableViewModel, Field> createUrlOrDoiColumn(JabRefIcon icon, Field firstField, Field secondField) { TableColumn<BibEntryTableViewModel, Field> column = new TableColumn<>(); Node headerGraphic = icon.getGraphicNode(); Tooltip.install(headerGraphic, new Tooltip(firstField.getDisplayName() + " / " + secondField.getDisplayName())); column.setGraphic(headerGraphic); column.getStyleClass().add(ICON_COLUMN); setExactWidth(column, GUIGlobals.WIDTH_ICON_COL); // icon is chosen based on field name in cell, so map fields to its names column.setCellValueFactory(cellData -> EasyBind.monadic(cellData.getValue().getField(firstField)).map(x -> firstField).orElse(EasyBind.monadic(cellData.getValue().getField(secondField)).map(x -> secondField))); new ValueTableCellFactory<BibEntryTableViewModel, Field>() .withGraphic(cellFactory::getTableIcon) .withTooltip(this::createIdentifierTooltip) .withOnMouseClickedEvent((BibEntryTableViewModel entry, Field content) -> (MouseEvent event) -> openUrlOrDoi(event, entry, content)) .install(column); return column; }"
"protected abstract Comparator<T> getComparator();"



"public abstract class DocumentPageViewModel {  /** * Renders this page and returns an image representation of itself. * @param width * @param height */ public abstract Image render(int width, int height);  /** * Get the page number of the current page in the document. */ public abstract int getPageNumber();  /** * Calculates the aspect ratio (width / height) of the page. */ public abstract double getAspectRatio(); }"
"class ConversionMenu extends Menu {  public ConversionMenu(StringProperty text) { super(Localization.lang("Convert"));  // create menu items, one for each converter for (Formatter converter : Formatters.getConverters()) { CustomMenuItem menuItem = new CustomMenuItem(new Label(converter.getName())); Tooltip toolTip = new Tooltip(converter.getDescription()); Tooltip.install(menuItem.getContent(), toolTip); menuItem.setOnAction(event -> text.set(converter.format(text.get()))); this.getItems().add(menuItem); } } }"


"public String getInformation(boolean includeMissingEntries) { StringBuilder result = new StringBuilder();  result.append(Localization.lang("keys in library")).append(' ').append(this.auxParserResult.getMasterDatabase().getEntryCount()).append('\n') .append(Localization.lang("found in AUX file")).append(' ').append(this.auxParserResult.getFoundKeysInAux()).append('\n') .append(Localization.lang("resolved")).append(' ').append(this.auxParserResult.getResolvedKeysCount()).append('\n') .append(Localization.lang("not found")).append(' ').append(this.auxParserResult.getUnresolvedKeysCount()).append('\n') .append(Localization.lang("crossreferenced entries included")).append(' ').append(this.auxParserResult.getCrossRefEntriesCount()).append('\n') .append(Localization.lang("strings included")).append(' ').append(this.auxParserResult.getInsertedStrings()).append('\n');  if (includeMissingEntries && (this.auxParserResult.getUnresolvedKeysCount() > 0)) { for (String entry : this.auxParserResult.getUnresolvedKeys()) { result.append(entry).append('\n'); } } if (this.auxParserResult.getNestedAuxCount() > 0) { result.append(Localization.lang("nested AUX files")).append(' ').append(this.auxParserResult.getNestedAuxCount()); } return result.toString(); }"
"public void saveJournalAbbreviationFiles() { journalFiles.forEach(file -> { try { file.writeOrCreate(); } catch (IOException e) { logger.debug(e.getLocalizedMessage()); } }); }"
"public BackgroundTask<V> onSuccess(Consumer<V> onSuccess) { this.onSuccess = onSuccess; return this; }"
"package org.jabref.gui.autocompleter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Comparator; import java.util.HashSet; import java.util.List; import javafx.util.Callback; import org.controlsfx.control.textfield.AutoCompletionBinding.ISuggestionRequest; public abstract class SuggestionProvider<T> implements Callback<ISuggestionRequest, Collection<T>> { private final Collection<T> possibleSuggestions = new HashSet<>(); private final Object possibleSuggestionsLock = new Object(); public static <T> SuggestionProvider<T> create(Collection<T> possibleSuggestions) { return create(null, possibleSuggestions); } public static <T> SuggestionProvider<T> create(Callback<T, String> stringConverter, Collection<T> possibleSuggestions) { SuggestionProviderString<T> suggestionProvider = new SuggestionProviderString<>(stringConverter); suggestionProvider.addPossibleSuggestions(possibleSuggestions); return suggestionProvider; } public void addPossibleSuggestions(@SuppressWarnings("unchecked") T... newPossible) { addPossibleSuggestions(Arrays.asList(newPossible)); } public void addPossibleSuggestions(Collection<T> newPossible) { synchronized (possibleSuggestionsLock) { possibleSuggestions.addAll(newPossible); } } public void clearSuggestions() { synchronized (possibleSuggestionsLock) { possibleSuggestions.clear();}}@Override public final Collection<T> call(final ISuggestionRequest request) { List<T> suggestions = new ArrayList<>(); if (!request.getUserText().isEmpty()) { synchronized (possibleSuggestionsLock) { for (T possibleSuggestion : possibleSuggestions) { if (isMatch(possibleSuggestion, request)) { suggestions.add(possibleSuggestion);}}} suggestions.sort(getComparator()); } return suggestions; protected abstract Comparator<T> getComparator(); protected abstract boolean isMatch(T suggestion, ISuggestionRequest request); private static class SuggestionProviderString<T> extends SuggestionProvider<T> { private Callback<T, String> stringConverter; private final Comparator<T> stringComparator = new Comparator<T>() { public int compare(T o1, T o2) {String o1str = stringConverter.call(o1); String o2str = stringConverter.call(o2); return o1str.compareTo(o2str); } }; public SuggestionProviderString(Callback<T, String> stringConverter) { this.stringConverter = stringConverter; if (this.stringConverter == null) { this.stringConverter = obj -> { return obj != null ? obj.toString() : ""; }; } } @Override protected Comparator<T> getComparator() { return stringComparator; } protected boolean isMatch(T suggestion, ISuggestionRequest request) {String userTextLower = request.getUserText().toLowerCase(); String suggestionStr = suggestion.toString().toLowerCase(); return suggestionStr.contains(userTextLower);"

"private void updateView() { sidePane.setComponents(visibleComponents);  if (visibleComponents.isEmpty()) { sidePane.setVisible(false); } else { sidePane.setVisible(true); } }"
"public class UndoableFieldChange extends AbstractUndoableJabRefEdit { private static final Logger LOGGER = LoggerFactory.getLogger(UndoableFieldChange.class);  private final BibEntry entry; private final Field field; private final String oldValue; private final String newValue;  public UndoableFieldChange(BibEntry entry, Field field, String oldValue, String newValue) { this.entry = entry; this.field = field; this.oldValue = oldValue; this.newValue = newValue; }  public UndoableFieldChange(FieldChange change) { this(change.getEntry(), change.getField(), change.getOldValue(), change.getNewValue()); }  @Override public String getPresentationName() { return Localization.lang("change field %0 of entry %1 from %2 to %3", StringUtil.boldHTML(field.getDisplayName()), StringUtil.boldHTML(entry.getCiteKeyOptional().orElse(Localization.lang("undefined"))), StringUtil.boldHTML(oldValue, Localization.lang("undefined")), StringUtil.boldHTML(newValue, Localization.lang("undefined"))); }  @Override public void undo() { super.undo();  // Revert the change. try { if (oldValue == null) { entry.clearField(field); } else { entry.setField(field, oldValue); }  // this is the only exception explicitly thrown here } catch (IllegalArgumentException ex) { LOGGER.info("Cannot perform undo", ex); } }  @Override public void redo() { super.redo();  // Redo the change. try { if (newValue == null) { entry.clearField(field); } else { entry.setField(field, newValue); }  } catch (IllegalArgumentException ex) { LOGGER.info("Cannot perform redo", ex); } }  }"
"public abstract class AbstractPushToApplication implements PushToApplication {  private static final Logger LOGGER = LoggerFactory.getLogger(AbstractPushToApplication.class);  protected boolean couldNotCall; // Set to true in case the command could not be executed, e.g., if the file is not found protected boolean couldNotConnect; // Set to true in case the tunnel to the program (if one is used) does not operate protected boolean notDefined; // Set to true if the corresponding path is not defined in the preferences  protected String commandPath; protected String commandPathPreferenceKey;  protected DialogService dialogService;  public AbstractPushToApplication(DialogService dialogService) { this.dialogService = dialogService; }  @Override public String getName() { return Localization.lang("Push entries to external application (%0)", getApplicationName()); }  @Override public String getTooltip() { return Localization.lang("Push to %0", getApplicationName()); }  @Override public void pushEntries(BibDatabaseContext database, List<BibEntry> entries, String keyString) { couldNotConnect = false; couldNotCall = false; notDefined = false;  initParameters(); commandPath = Globals.prefs.get(commandPathPreferenceKey);  // Check if a path to the command has been specified if ((commandPath == null) || commandPath.trim().isEmpty()) { notDefined = true; return; }  // Execute command try { if (OS.OS_X) { String[] commands = getCommandLine(keyString); if (commands.length < 3) { LOGGER.error("Commandline does not contain enough parameters to \"push to application\""); return; } ProcessBuilder processBuilder = new ProcessBuilder( "open", "-a", commands[0], "-n", "--args", commands[1], commands[2] ); processBuilder.start(); } else { ProcessBuilder processBuilder = new ProcessBuilder(getCommandLine(keyString)); processBuilder.start(); } }  // In case it did not work catch (IOException excep) { couldNotCall = true;  LOGGER.warn("Error: Could not call executable '" + commandPath + "'.", excep); } }  @Override public void operationCompleted() { if (notDefined) { dialogService.showErrorDialogAndWait( Localization.lang("Error pushing entries"), Localization.lang("Path to %0 not defined", getApplicationName()) + "."); } else if (couldNotCall) { dialogService.showErrorDialogAndWait( Localization.lang("Error pushing entries"), Localization.lang("Could not call executable") + " '" + commandPath + "'."); } else if (couldNotConnect) { dialogService.showErrorDialogAndWait( Localization.lang("Error pushing entries"), Localization.lang("Could not connect to %0", getApplicationName()) + "."); } else { dialogService.notify(Localization.lang("Pushed citations to %0", getApplicationName()) + "."); } }  @Override public boolean requiresBibtexKeys() { return true; }  /** * Function to get the command to be executed for pushing keys to be cited * * @param keyString String containing the Bibtex keys to be pushed to the application * @return String array with the command to call and its arguments */ @SuppressWarnings("unused") protected String[] getCommandLine(String keyString) { return new String[0]; }  /** * Function to get the command name in case it is different from the application name * * @return String with the command name */ protected String getCommandName() { return null; }  /** * Function to initialize parameters. Currently it is expected that commandPathPreferenceKey is set to the path of * the application. */ protected abstract void initParameters();  protected String getCiteCommand() { return Globals.prefs.get(JabRefPreferences.CITE_COMMAND); } }"

"public class OldCommandWrapper extends CommandBase {  private static final Logger LOGGER = LoggerFactory.getLogger(OldCommandWrapper.class);  private final Actions command; private final BasePanel panel;  public OldCommandWrapper(Actions command, BasePanel panel) { this.command = command; this.panel = panel; }  @Override public void execute() { try { panel.runCommand(command); } catch (Throwable ex) { LOGGER.debug("Cannot execute command " + command + ".", ex); } }  @Override public double getProgress() { return 0; }  @Override public ReadOnlyDoubleProperty progressProperty() { return null; }  public void setExecutable(boolean executable) { this.executable.bind(BindingsHelper.constantOf(executable)); }  @Override public String toString() { return this.command.toString(); } }"
"public static Supplier<List<MenuItem>> getCleanupURLMenu(TextArea textArea) { return () -> { CustomMenuItem cleanupURL = new CustomMenuItem(new Label(Localization.lang("Cleanup URL link"))); cleanupURL.setDisable(textArea.textProperty().isEmpty().get()); cleanupURL.setOnAction(event -> textArea.setText(new CleanupURLFormatter().format(textArea.getText())));  List<MenuItem> menuItems = new ArrayList<>(); menuItems.add(cleanupURL); return menuItems; }; }"



"public boolean isExternalFileTypeByExt(String extension) { return externalFileTypes.stream().anyMatch(type -> type.getExtension().equalsIgnoreCase(extension)); }"





"public class OptionalObjectProperty<T> extends SimpleObjectProperty<Optional<T>> {  private OptionalObjectProperty(Optional<T> initialValue) { super(initialValue); }  public static <T> OptionalObjectProperty<T> empty() { return new OptionalObjectProperty<>(Optional.empty()); }  /** * Returns a new ObservableValue that holds the value held by this * ObservableValue, or {@code other} when this ObservableValue is empty. */ public ObjectBinding<T> orElse(T other) { return new PreboundBinding<T>(this) { @Override protected T computeValue() { return OptionalObjectProperty.this.getValue().orElse(other); } }; }  public BooleanExpression isPresent() { return BooleanExpression.booleanExpression(new PreboundBinding<Boolean>(this) { @Override protected Boolean computeValue() { return OptionalObjectProperty.this.getValue().isPresent(); } }); } }"
"public static void showContextMenu(TextField textField, ContextMenu contextMenu, ContextMenuEvent e) { double screenX = e.getScreenX(); double screenY = e.getScreenY(); double sceneX = e.getSceneX();  TextFieldSkin skin = (TextFieldSkin) textField.getSkin();  if (Properties.IS_TOUCH_SUPPORTED) { Point2D menuPos; if (textField.getSelection().getLength() == 0) { skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false); menuPos = skin.getMenuPosition(); } else { menuPos = skin.getMenuPosition(); if (menuPos != null && (menuPos.getX() <= 0 || menuPos.getY() <= 0)) { skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false); menuPos = skin.getMenuPosition(); } }  if (menuPos != null) { Point2D p = textField.localToScene(menuPos); Scene scene = textField.getScene(); Window window = scene.getWindow(); Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(), window.getY() + scene.getY() + p.getY()); screenX = location.getX(); sceneX = p.getX(); screenY = location.getY(); } }  double menuWidth = contextMenu.prefWidth(-1); double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0); Screen currentScreen = Screen.getPrimary(); Rectangle2D bounds = currentScreen.getBounds();  if (menuX < bounds.getMinX()) { textField.getProperties().put("CONTEXT_MENU_SCREEN_X", screenX); textField.getProperties().put("CONTEXT_MENU_SCENE_X", sceneX); contextMenu.show(textField, bounds.getMinX(), screenY); } else if (screenX + menuWidth > bounds.getMaxX()) { double leftOver = menuWidth - (bounds.getMaxX() - screenX); textField.getProperties().put("CONTEXT_MENU_SCREEN_X", screenX); textField.getProperties().put("CONTEXT_MENU_SCENE_X", sceneX); contextMenu.show(textField, screenX - leftOver, screenY); } else { textField.getProperties().put("CONTEXT_MENU_SCREEN_X", 0); textField.getProperties().put("CONTEXT_MENU_SCENE_X", 0); contextMenu.show(textField, menuX, screenY); } }"

"public class JabRefDesktop {  private static final Logger LOGGER = LoggerFactory.getLogger(JabRefDesktop.class);  private static final NativeDesktop NATIVE_DESKTOP = getNativeDesktop(); private static final Pattern REMOTE_LINK_PATTERN = Pattern.compile("[a-z]+://.*");  private JabRefDesktop() { }  /** * Open a http/pdf/ps viewer for the given link string. */ public static void openExternalViewer(BibDatabaseContext databaseContext, String initialLink, Field initialField) throws IOException { String link = initialLink; Field field = initialField; if (StandardField.PS.equals(field) || StandardField.PDF.equals(field)) { // Find the default directory for this field type: List<String> dir = databaseContext.getFileDirectories(field, Globals.prefs.getFilePreferences());  Optional<Path> file = FileHelper.expandFilename(link, dir);  // Check that the file exists: if (!file.isPresent() || !Files.exists(file.get())) { throw new IOException("File not found (" + field + "): '" + link + "'."); } link = file.get().toAbsolutePath().toString();  // Use the correct viewer even if pdf and ps are mixed up: String[] split = file.get().getFileName().toString().split("\\."); if (split.length >= 2) { if ("pdf".equalsIgnoreCase(split[split.length - 1])) { field = StandardField.PDF; } else if ("ps".equalsIgnoreCase(split[split.length - 1]) || ((split.length >= 3) && "ps".equalsIgnoreCase(split[split.length - 2]))) { field = StandardField.PS; } } } else if (StandardField.DOI.equals(field)) { openDoi(link); return; } else if (StandardField.EPRINT.equals(field)) { link = Eprint.build(link).map(Eprint::getURIAsASCIIString).orElse(link); // should be opened in browser field = StandardField.URL; }  if (StandardField.URL.equals(field)) { openBrowser(link); } else if (StandardField.PS.equals(field)) { try { NATIVE_DESKTOP.openFile(link, StandardField.PS.getName()); } catch (IOException e) { LOGGER.error("An error occurred on the command: " + link, e); } } else if (StandardField.PDF.equals(field)) { try { NATIVE_DESKTOP.openFile(link, StandardField.PDF.getName()); } catch (IOException e) { LOGGER.error("An error occurred on the command: " + link, e); } } else { LOGGER.info("Message: currently only PDF, PS and HTML files can be opened by double clicking"); } }  private static void openDoi(String doi) throws IOException { String link = DOI.parse(doi).map(DOI::getURIAsASCIIString).orElse(doi); openBrowser(link); }  /** * Open an external file, attempting to use the correct viewer for it. * * @param databaseContext *            The database this file belongs to. * @param link *            The filename. * @return false if the link couldn't be resolved, true otherwise. */ public static boolean openExternalFileAnyFormat(final BibDatabaseContext databaseContext, String link, final Optional<ExternalFileType> type) throws IOException {  if (REMOTE_LINK_PATTERN.matcher(link.toLowerCase(Locale.ROOT)).matches()) { openExternalFilePlatformIndependent(type, link); return true; }  Optional<Path> file = FileHelper.expandFilename(databaseContext, link, Globals.prefs.getFilePreferences()); if (file.isPresent() && Files.exists(file.get())) { // Open the file: String filePath = file.get().toString(); openExternalFilePlatformIndependent(type, filePath); return true; } else { // No file matched the name, try to open it directly using the given app openExternalFilePlatformIndependent(type, link); return true; } }  public static boolean openExternalFileAnyFormat(Path file, final BibDatabaseContext databaseContext, final Optional<ExternalFileType> type) throws IOException { return openExternalFileAnyFormat(databaseContext, file.toString(), type); }  private static void openExternalFilePlatformIndependent(Optional<ExternalFileType> fileType, String filePath) throws IOException { if (fileType.isPresent()) { String application = fileType.get().getOpenWithApplication();  if (application.isEmpty()) { NATIVE_DESKTOP.openFile(filePath, fileType.get().getExtension()); } else { NATIVE_DESKTOP.openFileWithApplication(filePath, application); } } else { //File type is not given and therefore no application specified //Let the OS handle the opening of the file NATIVE_DESKTOP.openFile(filePath, ""); } }  /** * Opens a file browser of the folder of the given file. If possible, the file is selected * @param fileLink the location of the file * @throws IOException */ public static void openFolderAndSelectFile(Path fileLink) throws IOException { if (fileLink == null) { return; } boolean usingDefault = Globals.prefs.getBoolean(JabRefPreferences.USE_DEFAULT_FILE_BROWSER_APPLICATION);  if (usingDefault) { NATIVE_DESKTOP.openFolderAndSelectFile(fileLink); } else { String absolutePath = fileLink.toAbsolutePath().getParent().toString(); String command = Globals.prefs.get(JabRefPreferences.FILE_BROWSER_COMMAND); if (!command.isEmpty()) { command = command.replaceAll("\\s+", " "); // normalize white spaces  // replace the placeholder if used command = command.replace("%DIR", absolutePath); String[] subcommands = command.split(" ");  LOGGER.info("Executing command \"" + command + "\"...");  try { new ProcessBuilder(subcommands).start(); } catch (IOException exception) { LOGGER.error("Open File Browser", exception); JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Error occured while executing the command \"%0\".", command)); } } } }  /** * Opens the given URL using the system browser * * @param url the URL to open * @throws IOException */ public static void openBrowser(String url) throws IOException { Optional<ExternalFileType> fileType = ExternalFileTypes.getInstance().getExternalFileTypeByExt("html"); openExternalFilePlatformIndependent(fileType, url); }  public static void openBrowser(URI url) throws IOException { openBrowser(url.toASCIIString()); }  /** * Opens the url with the users standard Browser. * If that fails a popup will be shown to instruct the user to open the link manually * and the link gets copied to the clipboard * @param url */ public static void openBrowserShowPopup(String url) { try { openBrowser(url); } catch (IOException exception) { Globals.clipboardManager.setContent(url); LOGGER.error("Could not open browser", exception); String couldNotOpenBrowser = Localization.lang("Could not open browser."); String openManually = Localization.lang("Please open %0 manually.", url); String copiedToClipboard = Localization.lang("The link has been copied to the clipboard."); JabRefGUI.getMainFrame().getDialogService().notify(couldNotOpenBrowser); JabRefGUI.getMainFrame().getDialogService().showErrorDialogAndWait(couldNotOpenBrowser, couldNotOpenBrowser + "\n" + openManually + "\n" + copiedToClipboard); } }  /** * Opens a new console starting on the given file location * * If no command is specified in {@link Globals}, * the default system console will be executed. * * @param file Location the console should be opened at. */ public static void openConsole(File file) throws IOException { if (file == null) { return; }  String absolutePath = file.toPath().toAbsolutePath().getParent().toString(); boolean usingDefault = Globals.prefs.getBoolean(JabRefPreferences.USE_DEFAULT_CONSOLE_APPLICATION);  if (usingDefault) { NATIVE_DESKTOP.openConsole(absolutePath); } else { String command = Globals.prefs.get(JabRefPreferences.CONSOLE_COMMAND); command = command.trim();  if (!command.isEmpty()) { command = command.replaceAll("\\s+", " "); // normalize white spaces command = command.replace("%DIR", absolutePath); // replace the placeholder if used  String[] subcommands = command.split(" ");  LOGGER.info("Executing command \"" + command + "\"..."); JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Executing command \"%0\"...", command));  try { new ProcessBuilder(subcommands).start(); } catch (IOException exception) { LOGGER.error("Open console", exception);  JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Error occured while executing the command \"%0\".", command)); } } } }  // TODO: Move to OS.java public static NativeDesktop getNativeDesktop() { if (OS.WINDOWS) { return new Windows(); } else if (OS.OS_X) { return new OSX(); } else if (OS.LINUX) { return new Linux(); } return new DefaultDesktop(); } }"
"public <T> Future<T> execute(Callable<T> command) { Objects.requireNonNull(command); return executorService.submit(command); }"



"public boolean isResolved(BibEntry entry) { if (bibtexFields.isEmpty()) { return false; }  Optional<String> resolvedFieldContent = Optional.empty(); Optional<String> plainFieldContent = Optional.empty(); for (Field field : bibtexFields) { // entry type or bibtex key will never be resolved if (InternalField.TYPE_HEADER.equals(field) || InternalField.OBSOLETE_TYPE_HEADER.equals(field) || InternalField.KEY_FIELD.equals(field)) { return false; } else { plainFieldContent = entry.getField(field); resolvedFieldContent = entry.getResolvedFieldOrAlias(field, database.orElse(null)); }  if (resolvedFieldContent.isPresent()) { break; } } return (!resolvedFieldContent.equals(plainFieldContent)); }"


"private void updateColumnPreferences() { List<String> columnNames = new ArrayList<>(); List<String> columnsWidths = new ArrayList<>();  for (TableColumn<BibEntryTableViewModel, ?> column : mainTable.getColumns()) { if (column instanceof NormalTableColumn) { NormalTableColumn normalColumn = (NormalTableColumn) column;  columnNames.add(normalColumn.getColumnName()); columnsWidths.add(String.valueOf(Double.valueOf(normalColumn.getWidth()).intValue())); } }  if ((columnNames.size() == columnsWidths.size()) && (columnNames.size() == preferences.getStringList(JabRefPreferences.COLUMN_NAMES).size())) { preferences.putStringList(JabRefPreferences.COLUMN_NAMES, columnNames); preferences.putStringList(JabRefPreferences.COLUMN_WIDTHS, columnsWidths); } }"

"public void createFileObjects() { List<String> externalFiles = abbreviationsPreferences.getExternalJournalLists(); externalFiles.forEach(name -> openFile(Paths.get(name))); }"

"public static void runAndWaitInJavaFXThread(Runnable action) { Objects.requireNonNull(action);  // Run synchronously on JavaFX thread if (Platform.isFxApplicationThread()) { action.run(); return; }  // Queue on JavaFX thread and wait for completion final CountDownLatch doneLatch = new CountDownLatch(1); Platform.runLater(() -> { try { action.run(); } finally { doneLatch.countDown(); } });  try { doneLatch.await(); } catch (InterruptedException e) { LOGGER.error("Problem running action on JavaFX thread", e); } }"
"public class JabRefMain extends Application {  private static final Logger LOGGER = LoggerFactory.getLogger(JabRefMain.class);  private static String[] arguments;  public static void main(String[] args) { arguments = args; launch(arguments); }  @Override public void start(Stage mainStage) throws Exception { try { // Fail on unsupported Java versions ensureCorrectJavaVersion(); FallbackExceptionHandler.installExceptionHandler();  // Init preferences final JabRefPreferences preferences = JabRefPreferences.getInstance(); Globals.prefs = preferences; // Perform migrations PreferencesMigrations.runMigrations();  configureProxy(preferences.getProxyPreferences());  Globals.startBackgroundTasks();  applyPreferences(preferences);  try { // Process arguments ArgumentProcessor argumentProcessor = new ArgumentProcessor(arguments, ArgumentProcessor.Mode.INITIAL_START); // Check for running JabRef if (!handleMultipleAppInstances(arguments) || argumentProcessor.shouldShutDown()) { Platform.exit(); return; }  // If not, start GUI new JabRefGUI(mainStage, argumentProcessor.getParserResults(), argumentProcessor.isBlank()); } catch (ParseException e) { LOGGER.error("Problem parsing arguments", e);  JabRefCLI.printUsage(); Platform.exit(); } } catch (Exception ex) { LOGGER.error("Unexpected exception", ex); Platform.exit(); } }  @Override public void stop() { Globals.stopBackgroundTasks(); Globals.shutdownThreadPools(); }  /** * Tests if we are running an acceptable Java and terminates JabRef when we are sure the version is not supported. * This test uses the requirements for the Java version as specified in <code>gradle.build</code>. It is possible to * define a minimum version including the built number and to indicate whether Java 9 can be used (which it currently * can't). It tries to compare this version number to the version of the currently running JVM. The check is * optimistic and will rather return true even if we could not exactly determine the version. * <p> * Note: Users with a very old version like 1.6 will not profit from this since class versions are incompatible and * JabRef won't even start. Currently, JabRef won't start with Java 9 either, but the warning that it cannot be used * with this version is helpful anyway to prevent users to update from an old 1.8 directly to version 9. Additionally, * we soon might have a JabRef that does start with Java 9 but is not perfectly compatible. Therefore, we should leave * the Java 9 check alive. */ private static void ensureCorrectJavaVersion() { // Check if we are running an acceptable version of Java final BuildInfo buildInfo = Globals.BUILD_INFO; JavaVersion checker = new JavaVersion(); final boolean java9Fail = !buildInfo.isAllowJava9() && checker.isJava9(); final boolean versionFail = !checker.isAtLeast(buildInfo.getMinRequiredJavaVersion());  if (java9Fail || versionFail) { StringBuilder versionError = new StringBuilder( Localization.lang("Your current Java version (%0) is not supported. Please install version %1 or higher.", checker.getJavaVersion(), buildInfo.getMinRequiredJavaVersion()));  versionError.append("\n"); versionError.append(Localization.lang("Your Java Runtime Environment is located at %0.", checker.getJavaInstallationDirectory()));  if (!buildInfo.isAllowJava9()) { versionError.append("\n"); versionError.append(Localization.lang("Note that currently, JabRef does not run with Java 9.")); }  FXDialog alert = new FXDialog(Alert.AlertType.ERROR, Localization.lang("Error"), true); alert.setHeaderText(null); alert.setContentText(versionError.toString());  // We exit on Java 9 error since this will definitely not work if (java9Fail) { System.exit(0); } } }  private static boolean handleMultipleAppInstances(String[] args) { RemotePreferences remotePreferences = Globals.prefs.getRemotePreferences(); if (remotePreferences.useRemoteServer()) { // Try to contact already running JabRef RemoteClient remoteClient = new RemoteClient(remotePreferences.getPort()); if (remoteClient.ping()) { // We are not alone, there is already a server out there, send command line arguments to other instance if (remoteClient.sendCommandLineArguments(args)) { // So we assume it's all taken care of, and quit. LOGGER.info(Localization.lang("Arguments passed on to running JabRef instance. Shutting down.")); return false; } else { LOGGER.warn("Could not communicate with other running JabRef instance."); } } else { // We are alone, so we start the server Globals.REMOTE_LISTENER.openAndStart(new JabRefMessageHandler(), remotePreferences.getPort()); } } return true; }  private static void applyPreferences(JabRefPreferences preferences) { // Read list(s) of journal names and abbreviations Globals.journalAbbreviationLoader = new JournalAbbreviationLoader();  // Build list of Import and Export formats Globals.IMPORT_FORMAT_READER.resetImportFormats(Globals.prefs.getImportFormatPreferences(), Globals.prefs.getXMPPreferences(), Globals.getFileUpdateMonitor()); Globals.entryTypesManager.addCustomizedEntryTypes(preferences.loadBibEntryTypes(BibDatabaseMode.BIBTEX), preferences.loadBibEntryTypes(BibDatabaseMode.BIBLATEX)); Globals.exportFactory = Globals.prefs.getExporterFactory(Globals.journalAbbreviationLoader);  // Initialize protected terms loader Globals.protectedTermsLoader = new ProtectedTermsLoader(Globals.prefs.getProtectedTermsPreferences());  // Override used newline character with the one stored in the preferences // The preferences return the system newline character sequence as default OS.NEWLINE = Globals.prefs.get(JabRefPreferences.NEWLINE); }  private static void configureProxy(ProxyPreferences proxyPreferences) { ProxyRegisterer.register(proxyPreferences); if (proxyPreferences.isUseProxy() && proxyPreferences.isUseAuthentication()) { Authenticator.setDefault(new ProxyAuthenticator()); } } }"
" public static final XComponentContext bootstrap(String[] argArray, URLClassLoader loader) throws BootstrapException {  XComponentContext xContext = null;  try { // create default local component context XComponentContext xLocalContext = createInitialComponentContext((Map<String, Object>) null); if (xLocalContext == null) { throw new BootstrapException("no local component context!"); }  // find office executable relative to this class's class loader String sOffice = System.getProperty("os.name").startsWith("Windows") ? "soffice.exe" : "soffice";  File fOffice = NativeLibraryLoader.getResource(loader, sOffice); if (fOffice == null) { throw new BootstrapException("no office executable found!"); }  // create call with arguments //We need a socket, pipe does not work. https://api.libreoffice.org/examples/examples.html String[] cmdArray = new String[argArray.length + 2]; cmdArray[0] = fOffice.getPath(); cmdArray[1] = ("--accept=socket,host=localhost,port=2083" + ";urp;");  System.arraycopy(argArray, 0, cmdArray, 2, argArray.length);  // start office process Process p = Runtime.getRuntime().exec(cmdArray); pipe(p.getInputStream(), System.out, "CO> "); pipe(p.getErrorStream(), System.err, "CE> ");  // initial service manager XMultiComponentFactory xLocalServiceManager = xLocalContext.getServiceManager(); if (xLocalServiceManager == null) { throw new BootstrapException("no initial service manager!"); }  // create a URL resolver XUnoUrlResolver xUrlResolver = UnoUrlResolver.create(xLocalContext);  // connection string String sConnect = "uno:socket,host=localhost,port=2083" + ";urp;StarOffice.ComponentContext";  // wait until office is started for (int i = 0;; ++i) { try { // try to connect to office Object context = xUrlResolver.resolve(sConnect); xContext = UnoRuntime.queryInterface(XComponentContext.class, context); if (xContext == null) { throw new BootstrapException("no component context!"); } break; } catch (com.sun.star.connection.NoConnectException ex) { // Wait 500 ms, then try to connect again, but do not wait // longer than 5 min (= 600 * 500 ms) total: if (i == 600) { throw new BootstrapException(ex); } Thread.sleep(500); } } } catch (BootstrapException e) { throw e; } catch (java.lang.RuntimeException e) { throw e; } catch (java.lang.Exception e) { throw new BootstrapException(e); }  return xContext; }"




" private void updateAfterPreferenceChanges() { setValues();  List<TemplateExporter> customExporters = preferences.getCustomExportFormats(Globals.journalAbbreviationLoader); LayoutFormatterPreferences layoutPreferences = preferences.getLayoutFormatterPreferences(Globals.journalAbbreviationLoader); SavePreferences savePreferences = preferences.loadForExportFromPreferences(); XmpPreferences xmpPreferences = preferences.getXMPPreferences(); Globals.exportFactory = ExporterFactory.create(customExporters, layoutPreferences, savePreferences, xmpPreferences); preferences.updateEntryEditorTabList(); }"
" public boolean equals(Object object) { if (this == object) { return true; }  if (object instanceof CustomExternalFileType) { CustomExternalFileType other = (CustomExternalFileType) object; return Objects.equals(name, other.name) && Objects.equals(extension, other.extension) && Objects.equals(mimeType, other.mimeType) && Objects.equals(openWith, other.openWith) && Objects.equals(iconName, other.iconName); } return false; }"


"public class UiThreadObservableList<E> implements ObservableList<E> {  private final ObservableList<E> delegate;  public UiThreadObservableList(ObservableList<E> delegate) { this.delegate = delegate; }  @Override public void addListener(ListChangeListener<? super E> listener) { delegate.addListener(new UiThreadListChangeListener(listener)); }  @Override public void removeListener(ListChangeListener<? super E> listener) { delegate.removeListener(listener); }  @Override public boolean addAll(E... elements) { return delegate.addAll(elements); }  @Override public boolean setAll(E... elements) { return delegate.setAll(elements); }  @Override public boolean setAll(Collection<? extends E> col) { return delegate.setAll(col); }  @Override public boolean removeAll(E... elements) { return delegate.removeAll(elements); }  @Override public boolean retainAll(E... elements) { return delegate.retainAll(elements); }  @Override public void remove(int from, int to) { delegate.remove(from, to); }  @Override public int size() { return delegate.size(); }  @Override public boolean isEmpty() { return delegate.isEmpty(); }  @Override public boolean contains(Object o) { return delegate.contains(o); }  @Override public Iterator<E> iterator() { return delegate.iterator(); }  @Override public Object[] toArray() { return delegate.toArray(); }  @Override public <T> T[] toArray(T[] a) { return delegate.toArray(a); }  @Override public boolean add(E e) { return delegate.add(e); }  @Override public boolean remove(Object o) { return delegate.remove(o); }  @Override public boolean containsAll(Collection<?> c) { return delegate.containsAll(c); }  @Override public boolean addAll(Collection<? extends E> c) { return delegate.addAll(c); }  @Override public boolean addAll(int index, Collection<? extends E> c) { return delegate.addAll(index, c); }  @Override public boolean removeAll(Collection<?> c) { return delegate.removeAll(c); }  @Override public boolean retainAll(Collection<?> c) { return delegate.retainAll(c); }  @Override public void clear() { delegate.clear(); }  @Override public E get(int index) { return delegate.get(index); }  @Override public E set(int index, E element) { return delegate.set(index, element); }  @Override public void add(int index, E element) { delegate.add(index, element); }  @Override public E remove(int index) { return delegate.remove(index); }  @Override public int indexOf(Object o) { return delegate.indexOf(o); }  @Override public int lastIndexOf(Object o) { return delegate.lastIndexOf(o); }  @Override public ListIterator<E> listIterator() { return delegate.listIterator(); }  @Override public ListIterator<E> listIterator(int index) { return delegate.listIterator(index); }  @Override public List<E> subList(int fromIndex, int toIndex) { return delegate.subList(fromIndex, toIndex); }  @Override public void addListener(InvalidationListener listener) { delegate.addListener(new UiThreadInvalidationListener(listener)); }  @Override public void removeListener(InvalidationListener listener) { delegate.removeListener(listener); } }"
"public <T> List<Future<T>> executeAll(Collection<Callable<T>> tasks) { Objects.requireNonNull(tasks); try { return executorService.invokeAll(tasks); } catch (InterruptedException exception) { // Ignored return Collections.emptyList(); } }"
"public void selectLastJournalFile() { if (journalFiles.size() > 0) { currentFile.set(journalFilesProperty().get(journalFilesProperty().size() - 1)); } }"
"public void deleteAbbreviation() { if (isAbbreviationEditableAndRemovable.get()) { if ((currentAbbreviation.get() != null) && !currentAbbreviation.get().isPseudoAbbreviation()) { int index = abbreviations.indexOf(currentAbbreviation.get()); if (index > 1) { currentAbbreviation.set(abbreviations.get(index - 1)); } else if ((index + 1) < abbreviationsCount.get()) { currentAbbreviation.set(abbreviations.get(index + 1)); } else { currentAbbreviation.set(null); } abbreviations.remove(index); shouldWriteLists = true; } } }"

"public static <T> ObservableList<T> forUI(ObservableList<T> list) { return new UiThreadList<>(list); }"




"public boolean validSettings() { for (PreferencesTab tab : preferenceTabs) { if (!tab.validateSettings()) { return false; } } return true; }"


"public class ActionFactory {  private static final Logger LOGGER = LoggerFactory.getLogger(ActionFactory.class);  private final KeyBindingRepository keyBindingRepository;  public ActionFactory(KeyBindingRepository keyBindingRepository) { this.keyBindingRepository = Objects.requireNonNull(keyBindingRepository); }  /** * For some reason the graphic is not set correctly by the {@link ActionUtils} class, so we have to fix this by hand */ private static void setGraphic(MenuItem node, Action action) { node.graphicProperty().unbind(); action.getIcon().ifPresent(icon -> node.setGraphic(icon.getGraphicNode())); }  /* * Returns MenuItemContainer node associated with this menu item * which can contain: *   1. label node of type Label for displaying menu item text, *   2. right node of type Label for displaying accelerator text, *      or an arrow if it's a Menu, *   3. graphic node for displaying menu item icon, and *   4. left node for displaying either radio button or check box. * * This is basically rewritten impl_styleableGetNode() which * should not be used since it's marked as deprecated. */ private static Label getAssociatedNode(MenuItem menuItem) { ContextMenuContent.MenuItemContainer container = (ContextMenuContent.MenuItemContainer) menuItem.getStyleableNode();  if (container == null) { return null; } else { // We have to use reflection to get the associated label try { Method getLabel = ContextMenuContent.MenuItemContainer.class.getDeclaredMethod("getLabel"); getLabel.setAccessible(true); return (Label) getLabel.invoke(container); } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) { LOGGER.warn("Could not get label of menu item", e); } } return null; }  public MenuItem configureMenuItem(Action action, Command command, MenuItem menuItem) { ActionUtils.configureMenuItem(new JabRefAction(action, command, keyBindingRepository, Sources.FromMenu), menuItem); setGraphic(menuItem, action);  // Show tooltips if (command instanceof SimpleCommand) { EasyBind.subscribe( ((SimpleCommand) command).statusMessageProperty(), message -> { Label label = getAssociatedNode(menuItem); if (label != null) { label.setMouseTransparent(false); if (StringUtil.isBlank(message)) { label.setTooltip(null); } else { label.setTooltip(new Tooltip(message)); } } } ); }  return menuItem; }  public MenuItem createMenuItem(Action action, Command command) { MenuItem menuItem = new MenuItem(); configureMenuItem(action, command, menuItem); return menuItem; }  public CheckMenuItem createCheckMenuItem(Action action, Command command, boolean selected) { CheckMenuItem checkMenuItem = ActionUtils.createCheckMenuItem(new JabRefAction(action, command, keyBindingRepository, Sources.FromMenu)); checkMenuItem.setSelected(selected); setGraphic(checkMenuItem, action);  return checkMenuItem; }  public Menu createMenu(Action action) { Menu menu = ActionUtils.createMenu(new JabRefAction(action, keyBindingRepository));  // For some reason the graphic is not set correctly, so let's fix this setGraphic(menu, action); return menu; }  public Menu createSubMenu(Action action, MenuItem... children) { Menu menu = createMenu(action); menu.getItems().addAll(children); return menu; }  public Button createIconButton(Action action, Command command) { Button button = ActionUtils.createButton(new JabRefAction(action, command, keyBindingRepository, Sources.FromButton), ActionUtils.ActionTextBehavior.HIDE);  button.getStyleClass().setAll("icon-button");  // For some reason the graphic is not set correctly, so let's fix this button.graphicProperty().unbind(); action.getIcon().ifPresent(icon -> button.setGraphic(icon.getGraphicNode()));  return button; }  public ButtonBase configureIconButton(Action action, Command command, ButtonBase button) { ActionUtils.configureButton( new JabRefAction(action, command, keyBindingRepository, Sources.FromButton), button, ActionUtils.ActionTextBehavior.HIDE);  button.getStyleClass().add("icon-button");  // For some reason the graphic is not set correctly, so let's fix this // ToDO: Find a way to reuse JabRefIconView button.graphicProperty().unbind(); action.getIcon().ifPresent(icon -> button.setGraphic(icon.getGraphicNode()));  return button; } }"
"public class FetchAndMergeEntry {  // A list of all field which are supported public static List<Field> SUPPORTED_FIELDS = Arrays.asList(StandardField.DOI, StandardField.EPRINT, StandardField.ISBN); private static final Logger LOGGER = LoggerFactory.getLogger(FetchAndMergeEntry.class); private final BasePanel panel; private final DialogService dialogService; private final TaskExecutor taskExecutor;  public FetchAndMergeEntry(BasePanel panel, TaskExecutor taskExecutor) { this.dialogService = panel.frame().getDialogService(); this.panel = panel; this.taskExecutor = taskExecutor; }  public void fetchAndMerge(BibEntry entry) { fetchAndMerge(entry, SUPPORTED_FIELDS); }  public void fetchAndMerge(BibEntry entry, Field field) { fetchAndMerge(entry, Collections.singletonList(field)); }  public void fetchAndMerge(BibEntry entry, List<Field> fields) { for (Field field : fields) { Optional<String> fieldContent = entry.getField(field); if (fieldContent.isPresent()) { Optional<IdBasedFetcher> fetcher = WebFetchers.getIdBasedFetcherForField(field, Globals.prefs.getImportFormatPreferences()); if (fetcher.isPresent()) { BackgroundTask.wrap(() -> fetcher.get().performSearchById(fieldContent.get())) .onSuccess(fetchedEntry -> { String type = field.getDisplayName(); if (fetchedEntry.isPresent()) { showMergeDialog(entry, fetchedEntry.get(), fetcher.get()); } else { dialogService.notify(Localization.lang("Cannot get info based on given %0: %1", type, fieldContent.get())); } }) .onFailure(exception -> { LOGGER.error("Error while fetching bibliographic information", exception); dialogService.showErrorDialogAndWait(exception); }) .executeWith(Globals.TASK_EXECUTOR); } } else { dialogService.notify(Localization.lang("No %0 found", field.getDisplayName())); } } }  private void showMergeDialog(BibEntry originalEntry, BibEntry fetchedEntry, WebFetcher fetcher) { MergeEntriesDialog dialog = new MergeEntriesDialog(originalEntry, fetchedEntry, panel.getBibDatabaseContext().getMode()); dialog.setTitle(Localization.lang("Merge entry with %0 information", fetcher.getName())); dialog.setLeftHeaderText(Localization.lang("Original entry")); dialog.setRightHeaderText(Localization.lang("Entry from %0", fetcher.getName())); Optional<BibEntry> mergedEntry = dialog.showAndWait(); if (mergedEntry.isPresent()) { NamedCompound ce = new NamedCompound(Localization.lang("Merge entry with %0 information", fetcher.getName()));  // Updated the original entry with the new fields Set<Field> jointFields = new TreeSet<>(Comparator.comparing(Field::getName)); jointFields.addAll(mergedEntry.get().getFields()); Set<Field> originalFields = new TreeSet<>(Comparator.comparing(Field::getName)); originalFields.addAll(originalEntry.getFields()); boolean edited = false;  // entry type EntryType oldType = originalEntry.getType(); EntryType newType = mergedEntry.get().getType();  if (!oldType.equals(newType)) { originalEntry.setType(newType); ce.addEdit(new UndoableChangeType(originalEntry, oldType, newType)); edited = true; }  // fields for (Field field : jointFields) { Optional<String> originalString = originalEntry.getField(field); Optional<String> mergedString = mergedEntry.get().getField(field); if (!originalString.isPresent() || !originalString.equals(mergedString)) { originalEntry.setField(field, mergedString.get()); // mergedString always present ce.addEdit(new UndoableFieldChange(originalEntry, field, originalString.orElse(null), mergedString.get())); edited = true; } }  // Remove fields which are not in the merged entry, unless they are internal fields for (Field field : originalFields) { if (!jointFields.contains(field) && !FieldFactory.isInternalField(field)) { Optional<String> originalString = originalEntry.getField(field); originalEntry.clearField(field); ce.addEdit(new UndoableFieldChange(originalEntry, field, originalString.get(), null)); // originalString always present edited = true; } }  if (edited) { ce.end(); panel.getUndoManager().addEdit(ce); dialogService.notify(Localization.lang("Updated entry with info from %0", fetcher.getName())); } else { dialogService.notify(Localization.lang("No information added")); } } else { dialogService.notify(Localization.lang("Canceled merging entries")); } }  public void fetchAndMerge(BibEntry entry, EntryBasedFetcher fetcher) { BackgroundTask.wrap(() -> fetcher.performSearch(entry).stream().findFirst()) .onSuccess(fetchedEntry -> { if (fetchedEntry.isPresent()) { showMergeDialog(entry, fetchedEntry.get(), fetcher); } else { dialogService.notify(Localization.lang("Could not find any bibliographic information.")); } }) .onFailure(exception -> { LOGGER.error("Error while fetching entry with " + fetcher.getName(), exception); dialogService.showErrorDialogAndWait(Localization.lang("Error while fetching from %0", fetcher.getName()), exception); }) .executeWith(taskExecutor); } }"



" public static <V> V runInJavaFXThread(Callable<V> callable) { if (Platform.isFxApplicationThread()) { try { return callable.call(); } catch (Exception e) { LOGGER.error("Problem executing call", e); return null; } }  FutureTask<V> task = new FutureTask<>(callable);  Platform.runLater(task);  try { return task.get(); } catch (InterruptedException | ExecutionException e) { LOGGER.error("Problem running in fx thread", e); return null; } }"




"public class DefaultTaskExecutor implements TaskExecutor {  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultTaskExecutor.class);  private final ExecutorService executor = Executors.newFixedThreadPool(5); private final ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(2);  /** * */ public static <V> V runInJavaFXThread(Callable<V> callable) { if (Platform.isFxApplicationThread()) { try { return callable.call(); } catch (Exception e) { LOGGER.error("Problem executing call", e); return null; } }  FutureTask<V> task = new FutureTask<>(callable);  Platform.runLater(task);  try { return task.get(); } catch (InterruptedException | ExecutionException e) { LOGGER.error("Problem running in fx thread", e); return null; } }  /** * Runs the specified {@link Runnable} on the JavaFX application thread and waits for completion. * * @param action the {@link Runnable} to run * @throws NullPointerException if {@code action} is {@code null} */ public static void runAndWaitInJavaFXThread(Runnable action) { Objects.requireNonNull(action);  // Run synchronously on JavaFX thread if (Platform.isFxApplicationThread()) { action.run(); return; }  // Queue on JavaFX thread and wait for completion final CountDownLatch doneLatch = new CountDownLatch(1); Platform.runLater(() -> { try { action.run(); } finally { doneLatch.countDown(); } });  try { doneLatch.await(); } catch (InterruptedException e) { LOGGER.error("Problem running action on JavaFX thread", e); } }  public static void runInJavaFXThread(Runnable runnable) { Platform.runLater(runnable); }  @Override public <V> Future<V> execute(BackgroundTask<V> task) { return execute(getJavaFXTask(task)); }  @Override public <V> Future<V> execute(Task<V> task) { executor.submit(task); return task; }  @Override public <V> Future<?> schedule(BackgroundTask<V> task, long delay, TimeUnit unit) { return scheduledExecutor.schedule(getJavaFXTask(task), delay, unit); }  @Override public void shutdown() { executor.shutdownNow(); scheduledExecutor.shutdownNow(); }  private <V> Task<V> getJavaFXTask(BackgroundTask<V> task) { Task<V> javaTask = new Task<V>() {  { EasyBind.subscribe(task.progressProperty(), progress -> updateProgress(progress.getWorkDone(), progress.getMax())); EasyBind.subscribe(task.messageProperty(), this::updateMessage); EasyBind.subscribe(task.isCanceledProperty(), cancelled -> { if (cancelled) { cancel(); } }); }  @Override public V call() throws Exception { return task.call(); } }; Runnable onRunning = task.getOnRunning(); if (onRunning != null) { javaTask.setOnRunning(event -> onRunning.run()); } Consumer<V> onSuccess = task.getOnSuccess(); if (onSuccess != null) { javaTask.setOnSucceeded(event -> onSuccess.accept(javaTask.getValue())); } Consumer<Exception> onException = task.getOnException(); if (onException != null) { javaTask.setOnFailed(event -> onException.accept(convertToException(javaTask.getException()))); } return javaTask; }  private Exception convertToException(Throwable throwable) { if (throwable instanceof Exception) { return (Exception) throwable; } else { return new Exception(throwable); } } }"



"public class JabRefFrame extends BorderPane {  // Frame titles. public static final String FRAME_TITLE = "JabRef";  private static final Logger LOGGER = LoggerFactory.getLogger(JabRefFrame.class);  private final SplitPane splitPane = new SplitPane(); private final JabRefPreferences prefs = Globals.prefs; private final GlobalSearchBar globalSearchBar = new GlobalSearchBar(this, Globals.stateManager);  private final ProgressBar progressBar = new ProgressBar(); private final FileHistoryMenu fileHistory;  private final Stage mainStage; private final StateManager stateManager; private final CountingUndoManager undoManager; private SidePaneManager sidePaneManager; private TabPane tabbedPane; private final PushToApplicationsManager pushToApplicationsManager; private final DialogService dialogService; private SidePane sidePane;  public JabRefFrame(Stage mainStage) { this.mainStage = mainStage; this.dialogService = new JabRefDialogService(mainStage, this); this.stateManager = Globals.stateManager; this.pushToApplicationsManager = new PushToApplicationsManager(dialogService, stateManager); this.undoManager = Globals.undoManager; this.fileHistory = new FileHistoryMenu(prefs, dialogService, getOpenDatabaseAction()); }  private static BasePanel getBasePanel(Tab tab) { return (BasePanel) tab.getContent(); }  public void initDragAndDrop() { Tab dndIndicator = new Tab(Localization.lang("Open files..."), null); dndIndicator.getStyleClass().add("drop");  EasyBind.subscribe(tabbedPane.skinProperty(), skin -> { if (!(skin instanceof TabPaneSkin)) { return; }  // We need to get the tab header, the following is a ugly workaround Node tabHeaderArea = ((TabPaneSkin) this.tabbedPane.getSkin()) .getChildren() .stream() .filter(node -> node.getStyleClass().contains("tab-header-area")) .findFirst() .orElseThrow();  tabHeaderArea.setOnDragOver(event -> { if (DragAndDropHelper.hasBibFiles(event.getDragboard())) { event.acceptTransferModes(TransferMode.ANY); if (!tabbedPane.getTabs().contains(dndIndicator)) { tabbedPane.getTabs().add(dndIndicator); } event.consume(); } else { tabbedPane.getTabs().remove(dndIndicator); } });  tabHeaderArea.setOnDragExited(event -> tabbedPane.getTabs().remove(dndIndicator));  tabHeaderArea.setOnDragDropped(event -> { tabbedPane.getTabs().remove(dndIndicator);  boolean success = false;  List<Path> bibFiles = DragAndDropHelper.getBibFiles(event.getDragboard()); if (!bibFiles.isEmpty()) { for (Path file : bibFiles) { ParserResult pr = OpenDatabase.loadDatabase(file.toString(), Globals.prefs.getImportFormatPreferences(), Globals.getFileUpdateMonitor()); addParserResult(pr, true); } success = true; }  event.setDropCompleted(success); event.consume(); }); }); }  private void initKeyBindings() { addEventFilter(KeyEvent.KEY_PRESSED, event -> { Optional<KeyBinding> keyBinding = Globals.getKeyPrefs().mapToKeyBinding(event); if (keyBinding.isPresent()) { switch (keyBinding.get()) { case FOCUS_ENTRY_TABLE: getCurrentBasePanel().getMainTable().requestFocus(); event.consume(); break; case NEXT_LIBRARY: tabbedPane.getSelectionModel().selectNext(); event.consume(); break; case PREVIOUS_LIBRARY: tabbedPane.getSelectionModel().selectPrevious(); event.consume(); break; case INCREASE_TABLE_FONT_SIZE: increaseTableFontSize(); event.consume(); break; case DECREASE_TABLE_FONT_SIZE: decreaseTableFontSize(); event.consume(); break; case DEFAULT_TABLE_FONT_SIZE: setDefaultTableFontSize(); event.consume(); break; case SEARCH: getGlobalSearchBar().focus(); break; default: } } }); }  private void initShowTrackingNotification() { if (!Globals.prefs.shouldAskToCollectTelemetry()) { JabRefExecutorService.INSTANCE.submit(new TimerTask() {  @Override public void run() { DefaultTaskExecutor.runInJavaFXThread(JabRefFrame.this::showTrackingNotification); } }, 60000); // run in one minute } }  private Void showTrackingNotification() { if (!Globals.prefs.shouldCollectTelemetry()) { boolean shouldCollect = dialogService.showConfirmationDialogAndWait( Localization.lang("Telemetry: Help make JabRef better"), Localization.lang("To improve the user experience, we would like to collect anonymous statistics on the features you use. We will only record what features you access and how often you do it. We will neither collect any personal data nor the content of bibliographic items. If you choose to allow data collection, you can later disable it via Options -> Preferences -> General."), Localization.lang("Share anonymous statistics"), Localization.lang("Don't share")); Globals.prefs.setShouldCollectTelemetry(shouldCollect); }  Globals.prefs.askedToCollectTelemetry();  return null; }  public void refreshTitleAndTabs() { DefaultTaskExecutor.runInJavaFXThread(() -> {  setWindowTitle(); updateAllTabTitles(); }); }  /** * Sets the title of the main window. */ public void setWindowTitle() { BasePanel panel = getCurrentBasePanel();  // no database open if (panel == null) { //setTitle(FRAME_TITLE); return; }  String mode = panel.getBibDatabaseContext().getMode().getFormattedName(); String modeInfo = String.format(" (%s)", Localization.lang("%0 mode", mode)); boolean isAutosaveEnabled = Globals.prefs.getBoolean(JabRefPreferences.LOCAL_AUTO_SAVE);  if (panel.getBibDatabaseContext().getLocation() == DatabaseLocation.LOCAL) { String changeFlag = panel.isModified() && !isAutosaveEnabled ? "*" : ""; String databaseFile = panel.getBibDatabaseContext() .getDatabaseFile() .map(File::getPath) .orElse(GUIGlobals.UNTITLED_TITLE); //setTitle(FRAME_TITLE + " - " + databaseFile + changeFlag + modeInfo); } else if (panel.getBibDatabaseContext().getLocation() == DatabaseLocation.SHARED) { //setTitle(FRAME_TITLE + " - " + panel.getBibDatabaseContext().getDBMSSynchronizer().getDBName() + " [" //        + Localization.lang("shared") + "]" + modeInfo); } }  /** * The MacAdapter calls this method when a "BIB" file has been double-clicked from the Finder. */ public void openAction(String filePath) { Path file = Paths.get(filePath); // all the logic is done in openIt. Even raising an existing panel getOpenDatabaseAction().openFile(file, true); }  /** * The MacAdapter calls this method when "About" is selected from the application menu. */ public void about() { HelpAction.getMainHelpPageCommand().execute(); }  public JabRefPreferences prefs() { return prefs; }  /** * Tears down all things started by JabRef * <p> * FIXME: Currently some threads remain and therefore hinder JabRef to be closed properly * * @param filenames the filenames of all currently opened files - used for storing them if prefs openLastEdited is *                  set to true */ private void tearDownJabRef(List<String> filenames) { //prefs.putBoolean(JabRefPreferences.WINDOW_MAXIMISED, getExtendedState() == Frame.MAXIMIZED_BOTH);  if (prefs.getBoolean(JabRefPreferences.OPEN_LAST_EDITED)) { // Here we store the names of all current files. If // there is no current file, we remove any // previously stored filename. if (filenames.isEmpty()) { prefs.remove(JabRefPreferences.LAST_EDITED); } else { prefs.putStringList(JabRefPreferences.LAST_EDITED, filenames); File focusedDatabase = getCurrentBasePanel().getBibDatabaseContext().getDatabaseFile().orElse(null); new LastFocusedTabPreferences(prefs).setLastFocusedTab(focusedDatabase); } }  fileHistory.storeHistory(); prefs.flush(); }  /** * General info dialog.  The MacAdapter calls this method when "Quit" is selected from the application menu, Cmd-Q * is pressed, or "Quit" is selected from the Dock. The function returns a boolean indicating if quitting is ok or * not. * <p> * Non-OSX JabRef calls this when choosing "Quit" from the menu * <p> * SIDE EFFECT: tears down JabRef * * @return true if the user chose to quit; false otherwise */ public boolean quit() { // First ask if the user really wants to close, if the library has not been saved since last save. List<String> filenames = new ArrayList<>(); for (int i = 0; i < tabbedPane.getTabs().size(); i++) { BasePanel panel = getBasePanelAt(i); BibDatabaseContext context = panel.getBibDatabaseContext();  if (panel.isModified() && (context.getLocation() == DatabaseLocation.LOCAL)) { tabbedPane.getSelectionModel().select(i); if (!confirmClose(panel)) { return false; } } else if (context.getLocation() == DatabaseLocation.SHARED) { context.convertToLocalDatabase(); context.getDBMSSynchronizer().closeSharedDatabase(); context.clearDBMSSynchronizer(); } AutosaveManager.shutdown(context); BackupManager.shutdown(context); context.getDatabaseFile().map(File::getAbsolutePath).ifPresent(filenames::add); }  WaitForSaveFinishedDialog waitForSaveFinishedDialog = new WaitForSaveFinishedDialog(dialogService); waitForSaveFinishedDialog.showAndWait(getBasePanelList());  // Good bye! tearDownJabRef(filenames); Platform.exit(); return true; }  private void initLayout() { setProgressBarVisible(false);  BorderPane head = new BorderPane(); head.setTop(createMenu()); head.setCenter(createToolbar()); setTop(head);  SplitPane.setResizableWithParent(sidePane, Boolean.FALSE); splitPane.getItems().addAll(sidePane, tabbedPane);  // We need to wait with setting the divider since it gets reset a few times during the initial set-up mainStage.showingProperty().addListener(new ChangeListener<Boolean>() {  @Override public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean showing) { if (showing) { setDividerPosition();  EasyBind.subscribe(sidePane.visibleProperty(), visible -> { if (visible) { if (!splitPane.getItems().contains(sidePane)) { splitPane.getItems().add(0, sidePane); setDividerPosition(); } } else { splitPane.getItems().remove(sidePane); } });  mainStage.showingProperty().removeListener(this); observable.removeListener(this); } } });  setCenter(splitPane); }  private void setDividerPosition() { splitPane.setDividerPositions(prefs.getDouble(JabRefPreferences.SIDE_PANE_WIDTH)); if (!splitPane.getDividers().isEmpty()) { EasyBind.subscribe(splitPane.getDividers().get(0).positionProperty(), position -> prefs.putDouble(JabRefPreferences.SIDE_PANE_WIDTH, position.doubleValue())); } }  private Node createToolbar() { Pane leftSpacer = new Pane(); HBox.setHgrow(leftSpacer, Priority.SOMETIMES); Pane rightSpacer = new Pane(); HBox.setHgrow(rightSpacer, Priority.SOMETIMES);  ActionFactory factory = new ActionFactory(Globals.getKeyPrefs());  Button newLibrary; if (Globals.prefs.getBoolean(JabRefPreferences.BIBLATEX_DEFAULT_MODE)) { newLibrary = factory.createIconButton(StandardActions.NEW_LIBRARY_BIBLATEX, new NewDatabaseAction(this, BibDatabaseMode.BIBLATEX)); } else { newLibrary = factory.createIconButton(StandardActions.NEW_LIBRARY_BIBTEX, new NewDatabaseAction(this, BibDatabaseMode.BIBTEX)); }  HBox leftSide = new HBox( newLibrary, factory.createIconButton(StandardActions.OPEN_LIBRARY, new OpenDatabaseAction(this)), factory.createIconButton(StandardActions.SAVE_LIBRARY, new OldDatabaseCommandWrapper(Actions.SAVE, this, stateManager)), leftSpacer ); leftSide.setMinWidth(100); leftSide.prefWidthProperty().bind(sidePane.widthProperty()); leftSide.maxWidthProperty().bind(sidePane.widthProperty());  final PushToApplicationAction pushToApplicationAction = getPushToApplicationsManager().getPushToApplicationAction(); final Button pushToApplicationButton = factory.createIconButton(pushToApplicationAction.getActionInformation(), pushToApplicationAction); pushToApplicationsManager.setToolBarButton(pushToApplicationButton);  HBox rightSide = new HBox( factory.createIconButton(StandardActions.NEW_ARTICLE, new NewEntryAction(this, StandardEntryType.Article, dialogService, Globals.prefs, stateManager)), factory.createIconButton(StandardActions.NEW_ENTRY, new NewEntryAction(this, dialogService, Globals.prefs, stateManager)), factory.createIconButton(StandardActions.DELETE_ENTRY, new OldDatabaseCommandWrapper(Actions.DELETE, this, stateManager)), new Separator(Orientation.VERTICAL), factory.createIconButton(StandardActions.UNDO, new OldDatabaseCommandWrapper(Actions.UNDO, this, stateManager)), factory.createIconButton(StandardActions.REDO, new OldDatabaseCommandWrapper(Actions.REDO, this, stateManager)), factory.createIconButton(StandardActions.CUT, new OldDatabaseCommandWrapper(Actions.CUT, this, stateManager)), factory.createIconButton(StandardActions.COPY, new OldDatabaseCommandWrapper(Actions.COPY, this, stateManager)), factory.createIconButton(StandardActions.PASTE, new OldDatabaseCommandWrapper(Actions.PASTE, this, stateManager)), new Separator(Orientation.VERTICAL), pushToApplicationButton, factory.createIconButton(StandardActions.GENERATE_CITE_KEYS, new OldDatabaseCommandWrapper(Actions.MAKE_KEY, this, stateManager)), factory.createIconButton(StandardActions.CLEANUP_ENTRIES, new OldDatabaseCommandWrapper(Actions.CLEANUP, this, stateManager)), new Separator(Orientation.VERTICAL), factory.createIconButton(StandardActions.FORK_ME, new OpenBrowserAction("https://github.com/JabRef/jabref")), factory.createIconButton(StandardActions.OPEN_FACEBOOK, new OpenBrowserAction("https://www.facebook.com/JabRef/")), factory.createIconButton(StandardActions.OPEN_TWITTER, new OpenBrowserAction("https://twitter.com/jabref_org")) );  HBox.setHgrow(globalSearchBar, Priority.ALWAYS);  ToolBar toolBar = new ToolBar( leftSide,  globalSearchBar,  rightSpacer, rightSide); toolBar.getStyleClass().add("mainToolbar");  return toolBar; }  /** * Returns the indexed BasePanel. * * @param i Index of base */ public BasePanel getBasePanelAt(int i) { return (BasePanel) tabbedPane.getTabs().get(i).getContent(); }  /** * Returns a list of BasePanel. */ public List<BasePanel> getBasePanelList() { List<BasePanel> returnList = new ArrayList<>(); for (int i = 0; i < getBasePanelCount(); i++) { returnList.add(getBasePanelAt(i)); } return returnList; }  public void showBasePanelAt(int i) { tabbedPane.getSelectionModel().select(i); }  public void showBasePanel(BasePanel bp) { tabbedPane.getSelectionModel().select(getTab(bp)); }  public void init() { sidePaneManager = new SidePaneManager(Globals.prefs, this); sidePane = sidePaneManager.getPane();  tabbedPane = new TabPane(); tabbedPane.setTabDragPolicy(TabPane.TabDragPolicy.REORDER);  initLayout();  initKeyBindings();  initDragAndDrop();  //setBounds(GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds()); //WindowLocation pw = new WindowLocation(this, JabRefPreferences.POS_X, JabRefPreferences.POS_Y, JabRefPreferences.SIZE_X, //        JabRefPreferences.SIZE_Y); //pw.displayWindowAtStoredLocation();  // Bind global state stateManager.activeDatabaseProperty().bind( EasyBind.map(tabbedPane.getSelectionModel().selectedItemProperty(), tab -> Optional.ofNullable(tab).map(JabRefFrame::getBasePanel).map(BasePanel::getBibDatabaseContext)));  // Subscribe to the search EasyBind.subscribe(stateManager.activeSearchQueryProperty(), query -> { if (getCurrentBasePanel() != null) { getCurrentBasePanel().setCurrentSearchQuery(query); } });  /* * The following state listener makes sure focus is registered with the * correct database when the user switches tabs. Without this, * cut/paste/copy operations would some times occur in the wrong tab. */ EasyBind.subscribe(tabbedPane.getSelectionModel().selectedItemProperty(), tab -> { if (tab == null) { return; }  BasePanel newBasePanel = getBasePanel(tab);  // Poor-mans binding to global state stateManager.setSelectedEntries(newBasePanel.getSelectedEntries());  // Update active search query when switching between databases stateManager.activeSearchQueryProperty().set(newBasePanel.getCurrentSearchQuery());  // groupSidePane.getToggleCommand().setSelected(sidePaneManager.isComponentVisible(GroupSidePane.class)); //previewToggle.setSelected(Globals.prefs.getPreviewPreferences().isPreviewPanelEnabled()); //generalFetcher.getToggleCommand().setSelected(sidePaneManager.isComponentVisible(WebSearchPane.class)); //openOfficePanel.getToggleCommand().setSelected(sidePaneManager.isComponentVisible(OpenOfficeSidePanel.class));  setWindowTitle(); // Update search autocompleter with information for the correct database: newBasePanel.updateSearchManager();  newBasePanel.getUndoManager().postUndoRedoEvent(); newBasePanel.getMainTable().requestFocus(); }); initShowTrackingNotification(); }  /** * Returns the currently viewed BasePanel. */ public BasePanel getCurrentBasePanel() { if ((tabbedPane == null) || (tabbedPane.getSelectionModel().getSelectedItem() == null)) { return null; } return getBasePanel(tabbedPane.getSelectionModel().getSelectedItem()); }  /** * @return the BasePanel count. */ public int getBasePanelCount() { return tabbedPane.getTabs().size(); }  private Tab getTab(BasePanel comp) { for (Tab tab : tabbedPane.getTabs()) { if (tab.getContent() == comp) { return tab; } } return null; }  /** * @deprecated do not operate on tabs but on BibDatabaseContexts */ @Deprecated public TabPane getTabbedPane() { return tabbedPane; }  public void setTabTitle(BasePanel comp, String title, String toolTip) { DefaultTaskExecutor.runInJavaFXThread(() -> { Tab tab = getTab(comp); tab.setText(title); tab.setTooltip(new Tooltip(toolTip)); }); }  private MenuBar createMenu() { ActionFactory factory = new ActionFactory(Globals.getKeyPrefs()); Menu file = new Menu(Localization.lang("File")); Menu edit = new Menu(Localization.lang("Edit")); Menu library = new Menu(Localization.lang("Library")); Menu quality = new Menu(Localization.lang("Quality")); Menu view = new Menu(Localization.lang("View")); Menu tools = new Menu(Localization.lang("Tools")); Menu options = new Menu(Localization.lang("Options")); Menu help = new Menu(Localization.lang("Help"));  file.getItems().addAll( factory.createSubMenu(StandardActions.NEW_LIBRARY, factory.createMenuItem(StandardActions.NEW_LIBRARY_BIBTEX, new NewDatabaseAction(this, BibDatabaseMode.BIBTEX)), factory.createMenuItem(StandardActions.NEW_LIBRARY_BIBLATEX, new NewDatabaseAction(this, BibDatabaseMode.BIBLATEX))),  factory.createMenuItem(StandardActions.OPEN_LIBRARY, getOpenDatabaseAction()), fileHistory, factory.createMenuItem(StandardActions.SAVE_LIBRARY, new OldDatabaseCommandWrapper(Actions.SAVE, this, stateManager)), factory.createMenuItem(StandardActions.SAVE_LIBRARY_AS, new OldDatabaseCommandWrapper(Actions.SAVE_AS, this, stateManager)), factory.createMenuItem(StandardActions.SAVE_ALL, new SaveAllAction(this)),  new SeparatorMenuItem(),  factory.createSubMenu(StandardActions.IMPORT, factory.createMenuItem(StandardActions.MERGE_DATABASE, new OldDatabaseCommandWrapper(Actions.MERGE_DATABASE, this, stateManager)), // TODO: merge with import factory.createMenuItem(StandardActions.IMPORT_INTO_CURRENT_LIBRARY, new ImportCommand(this, false)), factory.createMenuItem(StandardActions.IMPORT_INTO_NEW_LIBRARY, new ImportCommand(this, true))),  factory.createSubMenu(StandardActions.EXPORT, factory.createMenuItem(StandardActions.EXPORT_ALL, new ExportCommand(this, false, Globals.prefs)), factory.createMenuItem(StandardActions.EXPORT_SELECTED, new ExportCommand(this, true, Globals.prefs)), factory.createMenuItem(StandardActions.SAVE_SELECTED_AS_PLAIN_BIBTEX, new OldDatabaseCommandWrapper(Actions.SAVE_SELECTED_AS_PLAIN, this, stateManager))),  factory.createMenuItem(StandardActions.CONNECT_TO_SHARED_DB, new ConnectToSharedDatabaseCommand(this)), factory.createMenuItem(StandardActions.PULL_CHANGES_FROM_SHARED_DB, new OldDatabaseCommandWrapper(Actions.PULL_CHANGES_FROM_SHARED_DATABASE, this, stateManager)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.CLOSE_LIBRARY, new CloseDatabaseAction()), factory.createMenuItem(StandardActions.QUIT, new CloseAction()) );  edit.getItems().addAll( factory.createMenuItem(StandardActions.UNDO, new OldDatabaseCommandWrapper(Actions.UNDO, this, stateManager)), factory.createMenuItem(StandardActions.REDO, new OldDatabaseCommandWrapper(Actions.REDO, this, stateManager)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.CUT, new EditAction(Actions.CUT)),  factory.createMenuItem(StandardActions.COPY, new EditAction(Actions.COPY)), factory.createSubMenu(StandardActions.COPY_MORE, factory.createMenuItem(StandardActions.COPY_TITLE, new OldDatabaseCommandWrapper(Actions.COPY_TITLE, this, stateManager)), factory.createMenuItem(StandardActions.COPY_KEY, new OldDatabaseCommandWrapper(Actions.COPY_KEY, this, stateManager)), factory.createMenuItem(StandardActions.COPY_CITE_KEY, new OldDatabaseCommandWrapper(Actions.COPY_CITE_KEY, this, stateManager)), factory.createMenuItem(StandardActions.COPY_KEY_AND_TITLE, new OldDatabaseCommandWrapper(Actions.COPY_KEY_AND_TITLE, this, stateManager)), factory.createMenuItem(StandardActions.COPY_KEY_AND_LINK, new OldDatabaseCommandWrapper(Actions.COPY_KEY_AND_LINK, this, stateManager)), factory.createMenuItem(StandardActions.COPY_CITATION_PREVIEW, new OldDatabaseCommandWrapper(Actions.COPY_CITATION_HTML, this, stateManager)), factory.createMenuItem(StandardActions.EXPORT_SELECTED_TO_CLIPBOARD, new ExportToClipboardAction(this, dialogService))),  factory.createMenuItem(StandardActions.PASTE, new EditAction(Actions.PASTE)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.MANAGE_KEYWORDS, new ManageKeywordsAction(stateManager)) );  if (Globals.prefs.getBoolean(JabRefPreferences.SPECIALFIELDSENABLED)) { edit.getItems().addAll( SpecialFieldMenuItemFactory.createSpecialFieldMenuForActiveDatabase(SpecialField.RANKING, factory, undoManager), SpecialFieldMenuItemFactory.getSpecialFieldSingleItemForActiveDatabase(SpecialField.RELEVANCE, factory), SpecialFieldMenuItemFactory.getSpecialFieldSingleItemForActiveDatabase(SpecialField.QUALITY, factory), SpecialFieldMenuItemFactory.getSpecialFieldSingleItemForActiveDatabase(SpecialField.PRINTED, factory), SpecialFieldMenuItemFactory.createSpecialFieldMenuForActiveDatabase(SpecialField.PRIORITY, factory, undoManager), SpecialFieldMenuItemFactory.createSpecialFieldMenuForActiveDatabase(SpecialField.READ_STATUS, factory, undoManager), new SeparatorMenuItem() ); }  //@formatter:off library.getItems().addAll( factory.createMenuItem(StandardActions.NEW_ENTRY, new NewEntryAction(this, dialogService, Globals.prefs, stateManager)), factory.createMenuItem(StandardActions.DELETE_ENTRY, new OldDatabaseCommandWrapper(Actions.DELETE, this, stateManager)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.LIBRARY_PROPERTIES, new LibraryPropertiesAction(this, dialogService, stateManager)), factory.createMenuItem(StandardActions.EDIT_PREAMBLE, new PreambleEditor(stateManager, undoManager, this.getDialogService())), factory.createMenuItem(StandardActions.EDIT_STRINGS, new BibtexStringEditorAction(stateManager)), factory.createMenuItem(StandardActions.MANAGE_CITE_KEY_PATTERNS, new BibtexKeyPatternAction(this, stateManager)), factory.createMenuItem(StandardActions.MASS_SET_FIELDS, new MassSetFieldsAction(stateManager, dialogService, undoManager)) );  Menu lookupIdentifiers = factory.createSubMenu(StandardActions.LOOKUP_DOC_IDENTIFIER); for (IdFetcher<?> fetcher : WebFetchers.getIdFetchers(Globals.prefs.getImportFormatPreferences())) { LookupIdentifierAction<?> identifierAction = new LookupIdentifierAction<>(this, fetcher, stateManager, undoManager); lookupIdentifiers.getItems().add(factory.createMenuItem(identifierAction.getAction(), identifierAction)); }  quality.getItems().addAll( factory.createMenuItem(StandardActions.FIND_DUPLICATES, new DuplicateSearch(this, dialogService, stateManager)), factory.createMenuItem(StandardActions.MERGE_ENTRIES, new MergeEntriesAction(this, stateManager)), factory.createMenuItem(StandardActions.CHECK_INTEGRITY, new IntegrityCheckAction(this, stateManager, Globals.TASK_EXECUTOR)), factory.createMenuItem(StandardActions.CLEANUP_ENTRIES, new OldDatabaseCommandWrapper(Actions.CLEANUP, this, stateManager)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.SET_FILE_LINKS, new AutoLinkFilesAction(this, prefs, stateManager, undoManager, Globals.TASK_EXECUTOR)) );  // PushToApplication final PushToApplicationAction pushToApplicationAction = pushToApplicationsManager.getPushToApplicationAction(); final MenuItem pushToApplicationMenuItem = factory.createMenuItem(pushToApplicationAction.getActionInformation(), pushToApplicationAction); pushToApplicationsManager.setMenuItem(pushToApplicationMenuItem);  tools.getItems().addAll( factory.createMenuItem(StandardActions.PARSE_TEX, new ParseTexAction(stateManager)), factory.createMenuItem(StandardActions.NEW_SUB_LIBRARY_FROM_AUX, new NewSubLibraryAction(this, stateManager)), factory.createMenuItem(StandardActions.FIND_UNLINKED_FILES, new FindUnlinkedFilesAction(this, stateManager)), factory.createMenuItem(StandardActions.WRITE_XMP, new OldDatabaseCommandWrapper(Actions.WRITE_XMP, this, stateManager)), factory.createMenuItem(StandardActions.COPY_LINKED_FILES, new CopyFilesAction(stateManager, this.getDialogService())), factory.createMenuItem(StandardActions.EXTRACT_BIBTEX, new ExtractBibtexAction(stateManager)),  new SeparatorMenuItem(),  lookupIdentifiers, factory.createMenuItem(StandardActions.DOWNLOAD_FULL_TEXT, new OldDatabaseCommandWrapper(Actions.DOWNLOAD_FULL_TEXT, this, stateManager)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.GENERATE_CITE_KEYS, new OldDatabaseCommandWrapper(Actions.MAKE_KEY, this, stateManager)), factory.createMenuItem(StandardActions.REPLACE_ALL, new OldDatabaseCommandWrapper(Actions.REPLACE_ALL, this, stateManager)), factory.createMenuItem(StandardActions.SEND_AS_EMAIL, new OldDatabaseCommandWrapper(Actions.SEND_AS_EMAIL, this, stateManager)), pushToApplicationMenuItem,  factory.createSubMenu(StandardActions.ABBREVIATE, factory.createMenuItem(StandardActions.ABBREVIATE_ISO, new OldDatabaseCommandWrapper(Actions.ABBREVIATE_ISO, this, stateManager)), factory.createMenuItem(StandardActions.ABBREVIATE_MEDLINE, new OldDatabaseCommandWrapper(Actions.ABBREVIATE_MEDLINE, this, stateManager))),  factory.createMenuItem(StandardActions.UNABBREVIATE, new OldDatabaseCommandWrapper(Actions.UNABBREVIATE, this, stateManager)) );  SidePaneComponent webSearch = sidePaneManager.getComponent(SidePaneType.WEB_SEARCH); SidePaneComponent groups = sidePaneManager.getComponent(SidePaneType.GROUPS); SidePaneComponent openOffice = sidePaneManager.getComponent(SidePaneType.OPEN_OFFICE);  view.getItems().add(new SeparatorMenuItem()); view.setOnShowing(event -> { view.getItems().clear(); view.getItems().addAll( factory.createCheckMenuItem(webSearch.getToggleAction(), webSearch.getToggleCommand(), sidePaneManager.isComponentVisible(SidePaneType.WEB_SEARCH)), factory.createCheckMenuItem(groups.getToggleAction(), groups.getToggleCommand(), sidePaneManager.isComponentVisible(SidePaneType.GROUPS)), factory.createCheckMenuItem(openOffice.getToggleAction(), openOffice.getToggleCommand(), sidePaneManager.isComponentVisible(SidePaneType.OPEN_OFFICE)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.NEXT_PREVIEW_STYLE, new OldDatabaseCommandWrapper(Actions.NEXT_PREVIEW_STYLE, this, stateManager)), factory.createMenuItem(StandardActions.PREVIOUS_PREVIEW_STYLE, new OldDatabaseCommandWrapper(Actions.PREVIOUS_PREVIEW_STYLE, this, stateManager)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.SHOW_PDF_VIEWER, new ShowDocumentViewerAction()), factory.createMenuItem(StandardActions.EDIT_ENTRY, new OldDatabaseCommandWrapper(Actions.EDIT, this, stateManager)), factory.createMenuItem(StandardActions.OPEN_CONSOLE, new OldDatabaseCommandWrapper(Actions.OPEN_CONSOLE, this, stateManager)) ); });  options.getItems().addAll( factory.createMenuItem(StandardActions.SHOW_PREFS, new ShowPreferencesAction(this, Globals.TASK_EXECUTOR)),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.SETUP_GENERAL_FIELDS, new SetupGeneralFieldsAction()), factory.createMenuItem(StandardActions.MANAGE_CUSTOM_IMPORTS, new ManageCustomImportsAction()), factory.createMenuItem(StandardActions.MANAGE_CUSTOM_EXPORTS, new ManageCustomExportsAction()), factory.createMenuItem(StandardActions.MANAGE_EXTERNAL_FILETYPES, new EditExternalFileTypesAction()), factory.createMenuItem(StandardActions.MANAGE_JOURNALS, new ManageJournalsAction()), factory.createMenuItem(StandardActions.CUSTOMIZE_KEYBINDING, new CustomizeKeyBindingAction()), factory.createMenuItem(StandardActions.MANAGE_PROTECTED_TERMS, new ManageProtectedTermsAction()),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.MANAGE_CONTENT_SELECTORS, new ManageContentSelectorAction(this, stateManager)) // TODO: Reenable customize entry types feature (https://github.com/JabRef/jabref/issues/4719) //factory.createMenuItem(StandardActions.CUSTOMIZE_ENTRY_TYPES, new CustomizeEntryAction(this)), );  help.getItems().addAll( factory.createMenuItem(StandardActions.HELP, HelpAction.getMainHelpPageCommand()), factory.createMenuItem(StandardActions.OPEN_FORUM, new OpenBrowserAction("http://discourse.jabref.org/")),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.ERROR_CONSOLE, new ErrorConsoleAction()),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.SEARCH_FOR_UPDATES, new SearchForUpdateAction(Globals.BUILD_INFO, prefs.getVersionPreferences(), dialogService, Globals.TASK_EXECUTOR)), factory.createSubMenu(StandardActions.WEB_MENU, factory.createMenuItem(StandardActions.OPEN_WEBPAGE, new OpenBrowserAction("https://jabref.org/")), factory.createMenuItem(StandardActions.OPEN_BLOG, new OpenBrowserAction("https://blog.jabref.org/")), factory.createMenuItem(StandardActions.OPEN_FACEBOOK, new OpenBrowserAction("https://www.facebook.com/JabRef/")), factory.createMenuItem(StandardActions.OPEN_TWITTER, new OpenBrowserAction("https://twitter.com/jabref_org")),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.FORK_ME, new OpenBrowserAction("https://github.com/JabRef/jabref")), factory.createMenuItem(StandardActions.OPEN_DEV_VERSION_LINK, new OpenBrowserAction("https://builds.jabref.org/master/")), factory.createMenuItem(StandardActions.OPEN_CHANGELOG, new OpenBrowserAction("https://github.com/JabRef/jabref/blob/master/CHANGELOG.md")),  new SeparatorMenuItem(),  factory.createMenuItem(StandardActions.DONATE, new OpenBrowserAction("https://donations.jabref.org"))  ), factory.createMenuItem(StandardActions.ABOUT, new AboutAction()) );  //@formatter:on MenuBar menu = new MenuBar(); menu.getStyleClass().add("mainMenu"); menu.getMenus().addAll( file, edit, library, quality, tools, view, options, help); menu.setUseSystemMenuBar(true); return menu; }  public void addParserResult(ParserResult pr, boolean focusPanel) { if (pr.toOpenTab()) { // Add the entries to the open tab. BasePanel panel = getCurrentBasePanel(); if (panel == null) { // There is no open tab to add to, so we create a new tab: addTab(pr.getDatabaseContext(), focusPanel); } else { List<BibEntry> entries = new ArrayList<>(pr.getDatabase().getEntries()); addImportedEntries(panel, entries); } } else { // only add tab if DB is not already open Optional<BasePanel> panel = getBasePanelList().stream() .filter(p -> p.getBibDatabaseContext().getDatabasePath().equals(pr.getFile())) .findFirst();  if (panel.isPresent()) { tabbedPane.getSelectionModel().select(getTab(panel.get())); } else { addTab(pr.getDatabaseContext(), focusPanel); } } }  /** * This method causes all open BasePanels to set up their tables anew. When called from PrefsDialog3, this updates * to the new settings. */ public void setupAllTables() { // This action can be invoked without an open database, so // we have to check if we have one before trying to invoke // methods to execute changes in the preferences.  // We want to notify all tabs about the changes to // avoid problems when changing the column set. for (int i = 0; i < tabbedPane.getTabs().size(); i++) { BasePanel bf = getBasePanelAt(i);  // Update tables: if (bf.getDatabase() != null) { DefaultTaskExecutor.runInJavaFXThread(bf::setupMainPanel); } } }  private List<String> collectDatabaseFilePaths() { List<String> dbPaths = new ArrayList<>(getBasePanelCount());  for (BasePanel basePanel : getBasePanelList()) { try { // db file exists if (basePanel.getBibDatabaseContext().getDatabaseFile().isPresent()) { dbPaths.add(basePanel.getBibDatabaseContext().getDatabaseFile().get().getCanonicalPath()); } else { dbPaths.add(""); } } catch (IOException ex) { LOGGER.error("Invalid database file path: " + ex.getMessage()); } } return dbPaths; }  private List<String> getUniquePathParts() { List<String> dbPaths = collectDatabaseFilePaths();  return FileUtil.uniquePathSubstrings(dbPaths); }  public void updateAllTabTitles() { List<String> paths = getUniquePathParts(); for (int i = 0; i < getBasePanelCount(); i++) { String uniqPath = paths.get(i); Optional<File> file = getBasePanelAt(i).getBibDatabaseContext().getDatabaseFile();  if (file.isPresent()) { if (!uniqPath.equals(file.get().getName()) && uniqPath.contains(File.separator)) { // remove filename uniqPath = uniqPath.substring(0, uniqPath.lastIndexOf(File.separator)); tabbedPane.getTabs().get(i).setText(getBasePanelAt(i).getTabTitle() + " \u2014 " + uniqPath); } else { // set original filename (again) tabbedPane.getTabs().get(i).setText(getBasePanelAt(i).getTabTitle()); } } else { tabbedPane.getTabs().get(i).setText(getBasePanelAt(i).getTabTitle()); } tabbedPane.getTabs().get(i).setTooltip(new Tooltip(file.map(File::getAbsolutePath).orElse(null))); } }  public void addTab(BasePanel basePanel, boolean raisePanel) { DefaultTaskExecutor.runInJavaFXThread(() -> { // add tab Tab newTab = new Tab(basePanel.getTabTitle(), basePanel); tabbedPane.getTabs().add(newTab); newTab.setOnCloseRequest(event -> { closeTab((BasePanel) newTab.getContent()); event.consume(); });  // update all tab titles updateAllTabTitles();  if (raisePanel) { tabbedPane.getSelectionModel().select(newTab); }  // Register undo/redo listener basePanel.getUndoManager().registerListener(new UndoRedoEventManager());  BibDatabaseContext context = basePanel.getBibDatabaseContext();  if (readyForAutosave(context)) { AutosaveManager autosaver = AutosaveManager.start(context); autosaver.registerListener(new AutosaveUIManager(basePanel)); }  BackupManager.start(context, Globals.entryTypesManager, prefs);  // Track opening trackOpenNewDatabase(basePanel); }); }  private void trackOpenNewDatabase(BasePanel basePanel) { Map<String, String> properties = new HashMap<>(); Map<String, Double> measurements = new HashMap<>(); measurements.put("NumberOfEntries", (double) basePanel.getBibDatabaseContext().getDatabase().getEntryCount());  Globals.getTelemetryClient().ifPresent(client -> client.trackEvent("OpenNewDatabase", properties, measurements)); }  public BasePanel addTab(BibDatabaseContext databaseContext, boolean raisePanel) { Objects.requireNonNull(databaseContext);  BasePanel bp = new BasePanel(this, BasePanelPreferences.from(Globals.prefs), databaseContext, ExternalFileTypes.getInstance()); addTab(bp, raisePanel); return bp; }  private boolean readyForAutosave(BibDatabaseContext context) { return ((context.getLocation() == DatabaseLocation.SHARED) || ((context.getLocation() == DatabaseLocation.LOCAL) && Globals.prefs.getBoolean(JabRefPreferences.LOCAL_AUTO_SAVE))) && context.getDatabaseFile().isPresent(); }  /** * Opens the import inspection dialog to let the user decide which of the given entries to import. * * @param panel   The BasePanel to add to. * @param entries The entries to add. */ private void addImportedEntries(final BasePanel panel, final List<BibEntry> entries) { BackgroundTask<List<BibEntry>> task = BackgroundTask.wrap(() -> entries); ImportEntriesDialog dialog = new ImportEntriesDialog(panel.getBibDatabaseContext(), task); dialog.setTitle(Localization.lang("Import")); dialog.showAndWait(); }  public FileHistoryMenu getFileHistory() { return fileHistory; }  /** * Set the visibility of the progress bar in the right end of the status line at the bottom of the frame. */ public void setProgressBarVisible(final boolean visible) { progressBar.setVisible(visible); }  /** * Sets the indeterminate status of the progress bar. * <p> */ public void setProgressBarIndeterminate(final boolean value) { progressBar.setProgress(ProgressBar.INDETERMINATE_PROGRESS); }  /** * Return a boolean, if the selected entry have file * * @param selectEntryList A selected entries list of the current base pane * @return true, if the selected entry contains file. false, if multiple entries are selected or the selected entry * doesn't contains file */ private boolean isExistFile(List<BibEntry> selectEntryList) { if (selectEntryList.size() == 1) { BibEntry selectedEntry = selectEntryList.get(0); return selectedEntry.getField(StandardField.FILE).isPresent(); } return false; }  /** * Return a boolean, if the selected entry have url or doi * * @param selectEntryList A selected entries list of the current base pane * @return true, if the selected entry contains url or doi. false, if multiple entries are selected or the selected * entry doesn't contains url or doi */ private boolean isExistURLorDOI(List<BibEntry> selectEntryList) { if (selectEntryList.size() == 1) { BibEntry selectedEntry = selectEntryList.get(0); return (selectedEntry.getField(StandardField.URL).isPresent() || selectedEntry.getField(StandardField.DOI).isPresent()); } return false; }  /** * Ask if the user really wants to close the given database * * @return true if the user choose to close the database */ private boolean confirmClose(BasePanel panel) { String filename = panel.getBibDatabaseContext() .getDatabasePath() .map(Path::toAbsolutePath) .map(Path::toString) .orElse(GUIGlobals.UNTITLED_TITLE);  ButtonType saveChanges = new ButtonType(Localization.lang("Save changes"), ButtonBar.ButtonData.YES); ButtonType discardChanges = new ButtonType(Localization.lang("Discard changes"), ButtonBar.ButtonData.NO); ButtonType cancel = new ButtonType(Localization.lang("Return to JabRef"), ButtonBar.ButtonData.CANCEL_CLOSE);  Optional<ButtonType> response = dialogService.showCustomButtonDialogAndWait(Alert.AlertType.CONFIRMATION, Localization.lang("Save before closing"), Localization.lang("Library '%0' has changed.", filename), saveChanges, discardChanges, cancel);  if (response.isPresent() && response.get().equals(saveChanges)) { // The user wants to save. try { SaveDatabaseAction saveAction = new SaveDatabaseAction(panel, Globals.prefs, Globals.entryTypesManager); if (saveAction.save()) { // Saved, now exit. return true; } // The action was either canceled or unsuccessful. dialogService.notify(Localization.lang("Unable to save library")); } catch (Throwable ex) { LOGGER.error("A problem occurred when trying to save the file", ex); dialogService.showErrorDialogAndWait(Localization.lang("Save library"), Localization.lang("Could not save file."), ex); } // Save was cancelled or an error occurred. return false; } return !response.isPresent() || !response.get().equals(cancel); }  private void closeTab(BasePanel panel) { // empty tab without database if (panel == null) { return; }  BibDatabaseContext context = panel.getBibDatabaseContext();  if (panel.isModified() && (context.getLocation() == DatabaseLocation.LOCAL)) { if (confirmClose(panel)) { removeTab(panel); } else { return; } } else if (context.getLocation() == DatabaseLocation.SHARED) { context.convertToLocalDatabase(); context.getDBMSSynchronizer().closeSharedDatabase(); context.clearDBMSSynchronizer(); removeTab(panel); } else { removeTab(panel); } AutosaveManager.shutdown(context); BackupManager.shutdown(context); }  private void removeTab(BasePanel panel) { DefaultTaskExecutor.runInJavaFXThread(() -> { panel.cleanUp(); tabbedPane.getTabs().remove(getTab(panel)); setWindowTitle(); dialogService.notify(Localization.lang("Closed library") + '.'); // update tab titles updateAllTabTitles(); }); }  public void closeCurrentTab() { removeTab(getCurrentBasePanel()); }  public OpenDatabaseAction getOpenDatabaseAction() { return new OpenDatabaseAction(this); }  public SidePaneManager getSidePaneManager() { return sidePaneManager; }  public PushToApplicationsManager getPushToApplicationsManager() { return pushToApplicationsManager; }  public GlobalSearchBar getGlobalSearchBar() { return globalSearchBar; }  public CountingUndoManager getUndoManager() { return undoManager; }  public DialogService getDialogService() { return dialogService; }  /** * The action concerned with closing the window. */ private class CloseAction extends SimpleCommand {  @Override public void execute() { quit(); } }  /** * Class for handling general actions; cut, copy and paste. The focused component is kept track of by * Globals.focusListener, and we call the action stored under the relevant name in its action map. */ private class EditAction extends SimpleCommand {  private final Actions command;  public EditAction(Actions command) { this.command = command; }  @Override public String toString() { return this.command.toString(); }  @Override public void execute() { Node focusOwner = mainStage.getScene().getFocusOwner(); if (focusOwner != null) { if (focusOwner instanceof TextInputControl) { // Focus is on text field -> copy/paste/cut selected text TextInputControl textInput = (TextInputControl) focusOwner; switch (command) { case COPY: textInput.copy(); break; case CUT: textInput.cut(); break; case PASTE: // handled by FX in TextInputControl#paste break; default: throw new IllegalStateException("Only cut/copy/paste supported but got " + command); } } else { // Not sure what is selected -> copy/paste/cut selected entries switch (command) { case COPY: getCurrentBasePanel().copy(); break; case CUT: getCurrentBasePanel().cut(); break; case PASTE: // handled by FX in TextInputControl#paste break; default: throw new IllegalStateException("Only cut/copy/paste supported but got " + command); } } } } }  private void setDefaultTableFontSize() { GUIGlobals.setFont(Globals.prefs.getIntDefault(JabRefPreferences.FONT_SIZE)); for (BasePanel basePanel : getBasePanelList()) { basePanel.updateTableFont(); } dialogService.notify(Localization.lang("Table font size is %0", String.valueOf(GUIGlobals.currentFont.getSize()))); }  private void increaseTableFontSize() { GUIGlobals.setFont(GUIGlobals.currentFont.getSize() + 1); for (BasePanel basePanel : getBasePanelList()) { basePanel.updateTableFont(); } dialogService.notify(Localization.lang("Table font size is %0", String.valueOf(GUIGlobals.currentFont.getSize()))); }  private void decreaseTableFontSize() { double currentSize = GUIGlobals.currentFont.getSize(); if (currentSize < 2) { return; } GUIGlobals.setFont(currentSize - 1); for (BasePanel basePanel : getBasePanelList()) { basePanel.updateTableFont(); } dialogService.notify(Localization.lang("Table font size is %0", String.valueOf(GUIGlobals.currentFont.getSize()))); }  private class CloseDatabaseAction extends SimpleCommand {  @Override public void execute() { closeTab(getCurrentBasePanel()); } }  private class UndoRedoEventManager {  @Subscribe public void listen(UndoRedoEvent event) { updateTexts(event); JabRefFrame.this.getCurrentBasePanel().updateEntryEditorIfShowing(); }  @Subscribe public void listen(AddUndoableActionEvent event) { updateTexts(event); }  private void updateTexts(UndoChangeEvent event) { /* TODO SwingUtilities.invokeLater(() -> { undo.putValue(Action.SHORT_DESCRIPTION, event.getUndoDescription()); undo.setEnabled(event.isCanUndo()); redo.putValue(Action.SHORT_DESCRIPTION, event.getRedoDescription()); redo.setEnabled(event.isCanRedo()); }); */ } } }"

"public class DetectOpenOfficeInstallation {  private final OpenOfficePreferences ooPrefs; private final DialogService dialogService; private final JabRefPreferences preferences;  public DetectOpenOfficeInstallation(JabRefPreferences preferences, DialogService dialogService) { this.preferences = preferences; this.dialogService = dialogService; this.ooPrefs = preferences.getOpenOfficePreferences(); }  public boolean isInstalled() { return autoDetectPaths(); }  public boolean isExecutablePathDefined() { return checkAutoDetectedPaths(ooPrefs); }  private Optional<Path> selectInstallationPath() {  final NativeDesktop nativeDesktop = JabRefDesktop.getNativeDesktop();  dialogService.showInformationDialogAndWait(Localization.lang("Could not find OpenOffice/LibreOffice installation"), Localization.lang("Unable to autodetect OpenOffice/LibreOffice installation. Please choose the installation directory manually.")); DirectoryDialogConfiguration dirDialogConfiguration = new DirectoryDialogConfiguration.Builder() .withInitialDirectory(nativeDesktop.getApplicationDirectory()) .build(); return dialogService.showDirectorySelectionDialog(dirDialogConfiguration);  }  private boolean autoDetectPaths() { List<Path> installations = OpenOfficeFileSearch.detectInstallations();  // manually add installation path if (installations.isEmpty()) { selectInstallationPath().ifPresent(installations::add); }  // select among multiple installations Optional<Path> actualFile = chooseAmongInstallations(installations); if (actualFile.isPresent()) { return setOpenOfficePreferences(actualFile.get()); }  return false; }  /** * Checks whether the executablePath exists */ private boolean checkAutoDetectedPaths(OpenOfficePreferences openOfficePreferences) { String executablePath = openOfficePreferences.getExecutablePath(); return !StringUtil.isNullOrEmpty(executablePath) && Files.exists(Paths.get(executablePath)); }  private boolean setOpenOfficePreferences(Path installDir) { Optional<Path> execPath = Optional.empty();  if (OS.WINDOWS) { execPath = FileUtil.find(OpenOfficePreferences.WINDOWS_EXECUTABLE, installDir); } else if (OS.OS_X) { execPath = FileUtil.find(OpenOfficePreferences.OSX_EXECUTABLE, installDir); } else if (OS.LINUX) { execPath = FileUtil.find(OpenOfficePreferences.LINUX_EXECUTABLE, installDir); }  Optional<Path> jarFilePath = FileUtil.find(OpenOfficePreferences.OO_JARS.get(0), installDir);  if (execPath.isPresent() && jarFilePath.isPresent()) { ooPrefs.setInstallationPath(installDir.toString()); ooPrefs.setExecutablePath(execPath.get().toString()); ooPrefs.setJarsPath(jarFilePath.get().getParent().toString()); preferences.setOpenOfficePreferences(ooPrefs); return true; }  return false; }  private Optional<Path> chooseAmongInstallations(List<Path> installDirs) { if (installDirs.isEmpty()) { return Optional.empty(); }  if (installDirs.size() == 1) { return Optional.of(installDirs.get(0).toAbsolutePath()); }  String content = Localization.lang("Found more than one OpenOffice/LibreOffice executable.") + "\n" + Localization.lang("Please choose which one to connect to:");  Optional<Path> selectedPath = dialogService.showChoiceDialogAndWait(Localization.lang("Choose OpenOffice/LibreOffice executable"), content, Localization.lang("Use selected instance"), installDirs);  return selectedPath; }  }"



"public class ManageJournalAbbreviationsView extends BaseDialog<Void> {  @FXML public Label loadingLabel; @FXML public ProgressIndicator progressIndicator; @FXML private ButtonType saveButton; @FXML private TableView<AbbreviationViewModel> journalAbbreviationsTable; @FXML private TableColumn<AbbreviationViewModel, String> journalTableNameColumn; @FXML private TableColumn<AbbreviationViewModel, String> journalTableAbbreviationColumn; @FXML private TableColumn<AbbreviationViewModel, Boolean> journalTableEditColumn; @FXML private TableColumn<AbbreviationViewModel, Boolean> journalTableDeleteColumn; @FXML private ComboBox<AbbreviationsFileViewModel> journalFilesBox; @FXML private Button addJournalFileButton; @FXML private Button addNewJournalFileButton; @FXML private Button removeJournalAbbreviationsButton; @Inject private PreferencesService preferences; @Inject private DialogService dialogService; @Inject private TaskExecutor taskExecutor; @Inject private JournalAbbreviationLoader journalAbbreviationLoader; private ManageJournalAbbreviationsViewModel viewModel;  public ManageJournalAbbreviationsView() { this.setTitle(Localization.lang("Journal abbreviations"));  ViewLoader.view(this) .load() .setAsDialogPane(this);  ControlHelper.setAction(saveButton, getDialogPane(), event -> saveAbbreviationsAndCloseDialog()); }  @FXML private void initialize() { viewModel = new ManageJournalAbbreviationsViewModel(preferences, dialogService, taskExecutor, journalAbbreviationLoader);  setUpTable(); setBindings(); setButtonStyles(); viewModel.init(); }  private void setButtonStyles() { addJournalFileButton.setGraphic(IconTheme.JabRefIcons.OPEN.getGraphicNode()); addNewJournalFileButton.setGraphic(IconTheme.JabRefIcons.NEW.getGraphicNode()); removeJournalAbbreviationsButton.setGraphic(IconTheme.JabRefIcons.CLOSE.getGraphicNode()); }  private void setUpTable() { journalAbbreviationsTable.setOnKeyPressed(event -> { if (event.getCode() == KeyCode.DELETE) { viewModel.deleteAbbreviation(); } }); journalTableNameColumn.setCellValueFactory(cellData -> cellData.getValue().nameProperty()); journalTableNameColumn.setCellFactory(cell -> new JournalAbbreviationsNameTableEditingCell()); journalTableAbbreviationColumn.setCellValueFactory(cellData -> cellData.getValue().abbreviationProperty()); journalTableAbbreviationColumn.setCellFactory(cell -> new JournalAbbreviationsAbbreviationTableEditingCell()); journalTableEditColumn.setCellValueFactory(cellData -> cellData.getValue().isPseudoAbbreviationProperty()); journalTableDeleteColumn.setCellValueFactory(cellData -> cellData.getValue().isPseudoAbbreviationProperty()); journalTableEditColumn.setCellFactory(new ValueTableCellFactory<AbbreviationViewModel, Boolean>(). withGraphic(isPseudoAbbreviation -> { if (isPseudoAbbreviation) { return IconTheme.JabRefIcons.ADD.getGraphicNode(); } else { return viewModel.isAbbreviationEditableAndRemovable() ? IconTheme.JabRefIcons.EDIT.getGraphicNode() : null; } }). withOnMouseClickedEvent(isPseudoAbbreviation -> { if (isPseudoAbbreviation) { return evt -> addAbbreviation(); } else { return viewModel.isAbbreviationEditableAndRemovable() ? evt -> editAbbreviation() : evt -> { }; } }) );  journalTableDeleteColumn.setCellFactory(new ValueTableCellFactory<AbbreviationViewModel, Boolean>(). withGraphic(isPseudoAbbreviation -> { if (!isPseudoAbbreviation && viewModel.isAbbreviationEditableAndRemovable()) { return IconTheme.JabRefIcons.DELETE_ENTRY.getGraphicNode(); } else { return null; } }). withOnMouseClickedEvent(isPseudoAbbreviation -> { if (!isPseudoAbbreviation && viewModel.isAbbreviationEditableAndRemovable()) { return evt -> removeAbbreviation(); } else { return evt -> { }; } }) ); }  private void setBindings() { journalAbbreviationsTable.itemsProperty().bindBidirectional(viewModel.abbreviationsProperty()); journalFilesBox.itemsProperty().bindBidirectional(viewModel.journalFilesProperty()); journalFilesBox.valueProperty().bindBidirectional(viewModel.currentFileProperty());  viewModel.currentAbbreviationProperty().addListener((observable, oldvalue, newvalue) -> journalAbbreviationsTable.getSelectionModel().select(newvalue)); journalAbbreviationsTable.getSelectionModel().selectedItemProperty() .addListener((observable, oldvalue, newvalue) -> viewModel.currentAbbreviationProperty().set(newvalue));  removeJournalAbbreviationsButton.disableProperty().bind(viewModel.isFileRemovableProperty().not());  loadingLabel.visibleProperty().bind(viewModel.isLoadingProperty()); progressIndicator.visibleProperty().bind(viewModel.isLoadingProperty()); }  @FXML private void addNewFile() { viewModel.addNewFile(); }  @FXML private void openFile() { viewModel.openFile(); }  @FXML private void removeList() { viewModel.removeCurrentFile(); }  @FXML private void addAbbreviation() { viewModel.addAbbreviation(); selectNewAbbreviation(); }  @FXML private void editAbbreviation() { journalAbbreviationsTable.edit(journalAbbreviationsTable.getSelectionModel().getSelectedIndex(), journalTableNameColumn); }  private void selectNewAbbreviation() { int lastRow = viewModel.abbreviationsCountProperty().get() - 1; journalAbbreviationsTable.scrollTo(lastRow); journalAbbreviationsTable.getSelectionModel().select(lastRow); journalAbbreviationsTable.getFocusModel().focus(lastRow); }  @FXML private void removeAbbreviation() { viewModel.deleteAbbreviation(); }  @FXML private void saveAbbreviationsAndCloseDialog() { viewModel.saveEverythingAndUpdateAutoCompleter(); close(); }  /** * This class provides a editable text field that is used as table cell. * It handles the editing of the name column. */ public class JournalAbbreviationsNameTableEditingCell extends TableCell<AbbreviationViewModel, String> {  private TextField textField; private String oldName; private int editingIndex;  @Override public void startEdit() { if (!isEmpty() && viewModel.isAbbreviationEditableAndRemovableProperty().get()) { oldName = viewModel.currentAbbreviationProperty().get().getName(); super.startEdit(); createTextField(); setText(null); setGraphic(textField); editingIndex = journalAbbreviationsTable.getSelectionModel().getSelectedIndex(); textField.requestFocus(); textField.selectAll(); } }  @Override public void cancelEdit() { super.cancelEdit(); setText(getItem()); setGraphic(null); journalAbbreviationsTable.itemsProperty().get().get(editingIndex).setName(oldName); }  @Override public void updateItem(String item, boolean empty) { super.updateItem(item, empty); if (empty) { setText(null); setGraphic(null); } else { if (isEditing()) { if (textField != null) { textField.setText(getString()); } setText(null); setGraphic(textField); } else { setText(getString()); setGraphic(null); } } }  @Override public void commitEdit(String name) { journalAbbreviationsTable.getSelectionModel().select(editingIndex); AbbreviationViewModel current = viewModel.currentAbbreviationProperty().get(); super.commitEdit(name); current.setName(oldName); viewModel.editAbbreviation(name, current.getAbbreviation()); }  private void createTextField() { textField = new TextField(getString()); textField.setMinWidth(this.getWidth() - (this.getGraphicTextGap() * 2)); textField.focusedProperty().addListener((observable, oldValue, newValue) -> { if (!newValue) { commitEdit(textField.getText()); } }); textField.setOnKeyPressed(t -> { if (t.getCode() == KeyCode.ENTER) { if (isEditing()) { journalAbbreviationsTable.requestFocus(); } else { startEdit(); } } else if (t.getCode() == KeyCode.ESCAPE) { cancelEdit(); } }); }  private String getString() { return getItem() == null ? "" : getItem(); } }  /** * This class provides a editable text field that is used as table cell. * It handles the editing of the abbreviation column. */ public class JournalAbbreviationsAbbreviationTableEditingCell extends TableCell<AbbreviationViewModel, String> {  private TextField textField; private String oldAbbreviation; private int editingIndex;  @Override public void startEdit() { if (!isEmpty() && viewModel.isAbbreviationEditableAndRemovableProperty().get()) { oldAbbreviation = viewModel.currentAbbreviationProperty().get().getAbbreviation(); super.startEdit(); createTextField(); setText(null); setGraphic(textField); editingIndex = journalAbbreviationsTable.getSelectionModel().getSelectedIndex(); textField.requestFocus(); textField.selectAll(); } }  @Override public void cancelEdit() { super.cancelEdit(); setText(getItem()); setGraphic(null); journalAbbreviationsTable.itemsProperty().get().get(editingIndex).setAbbreviation(oldAbbreviation); }  @Override public void updateItem(String item, boolean empty) { super.updateItem(item, empty); if (empty) { setText(null); setGraphic(null); } else { if (isEditing()) { if (textField != null) { textField.setText(getString()); } setText(null); setGraphic(textField); } else { setText(getString()); setGraphic(null); } } }  @Override public void commitEdit(String abbreviation) { journalAbbreviationsTable.getSelectionModel().select(editingIndex); AbbreviationViewModel current = viewModel.currentAbbreviationProperty().get(); super.commitEdit(abbreviation); current.setAbbreviation(oldAbbreviation); viewModel.editAbbreviation(current.getName(), abbreviation); }  private void createTextField() { textField = new TextField(getString()); textField.setMinWidth(this.getWidth() - (this.getGraphicTextGap() * 2)); textField.focusedProperty().addListener((observable, oldValue, newValue) -> { if (!newValue) { commitEdit(textField.getText()); } }); textField.setOnKeyPressed(t -> { if (t.getCode() == KeyCode.ENTER) { if (isEditing()) { journalAbbreviationsTable.requestFocus(); } else { startEdit(); } } else if (t.getCode() == KeyCode.ESCAPE) { cancelEdit(); } }); }  private String getString() { return getItem() == null ? "" : getItem(); } } }"

"public class UndoableChangeType extends AbstractUndoableJabRefEdit { private final EntryType oldType; private final EntryType newType; private final BibEntry entry;  public UndoableChangeType(FieldChange change) { this(change.getEntry(), EntryTypeFactory.parse(change.getOldValue()), EntryTypeFactory.parse(change.getNewValue())); }  public UndoableChangeType(BibEntry entry, EntryType oldType, EntryType newType) { this.oldType = oldType; this.newType = newType; this.entry = entry; }  @Override public String getPresentationName() { return Localization.lang("change type of entry %0 from %1 to %2", StringUtil.boldHTML(entry.getCiteKeyOptional().orElse(Localization.lang("undefined"))), StringUtil.boldHTML(oldType.getDisplayName(), Localization.lang("undefined")), StringUtil.boldHTML(newType.getDisplayName())); }  @Override public void undo() { super.undo(); entry.setType(oldType); }  @Override public void redo() { super.redo(); entry.setType(newType); } }"

"public void setWindowTitle() { BasePanel panel = getCurrentBasePanel();  // no database open if (panel == null) { //setTitle(FRAME_TITLE); return; }  String mode = panel.getBibDatabaseContext().getMode().getFormattedName(); String modeInfo = String.format(" (%s)", Localization.lang("%0 mode", mode)); boolean isAutosaveEnabled = Globals.prefs.getBoolean(JabRefPreferences.LOCAL_AUTO_SAVE);  if (panel.getBibDatabaseContext().getLocation() == DatabaseLocation.LOCAL) { String changeFlag = panel.isModified() && !isAutosaveEnabled ? "*" : ""; String databaseFile = panel.getBibDatabaseContext() .getDatabaseFile() .map(File::getPath) .orElse(GUIGlobals.UNTITLED_TITLE); //setTitle(FRAME_TITLE + " - " + databaseFile + changeFlag + modeInfo); } else if (panel.getBibDatabaseContext().getLocation() == DatabaseLocation.SHARED) { //setTitle(FRAME_TITLE + " - " + panel.getBibDatabaseContext().getDBMSSynchronizer().getDBName() + " [" //        + Localization.lang("shared") + "]" + modeInfo); } }"



"public void openFiles(List<Path> filesToOpen, boolean raisePanel) { BasePanel toRaise = null; int initialCount = filesToOpen.size(); int removed = 0;  // Check if any of the files are already open: for (Iterator<Path> iterator = filesToOpen.iterator(); iterator.hasNext();) { Path file = iterator.next(); for (int i = 0; i < frame.getTabbedPane().getTabs().size(); i++) { BasePanel basePanel = frame.getBasePanelAt(i); if ((basePanel.getBibDatabaseContext().getDatabasePath().isPresent()) && basePanel.getBibDatabaseContext().getDatabasePath().get().equals(file)) { iterator.remove(); removed++; // See if we removed the final one. If so, we must perhaps // raise the BasePanel in question: if (removed == initialCount) { toRaise = basePanel; } // no more bps to check, we found a matching one break; } } }  // Run the actual open in a thread to prevent the program // locking until the file is loaded. if (!filesToOpen.isEmpty()) { final List<Path> theFiles = Collections.unmodifiableList(filesToOpen);  for (Path theFile : theFiles) { //This method will execute the concrete file opening and loading in a background thread openTheFile(theFile, raisePanel); }  for (Path theFile : theFiles) { frame.getFileHistory().newFile(theFile); } } // If no files are remaining to open, this could mean that a file was // already open. If so, we may have to raise the correct tab: else if (toRaise != null) { dialogService.notify(Localization.lang("File '%0' is already open.", toRaise.getBibDatabaseContext().getDatabasePath().get().getFileName().toString())); frame.showBasePanel(toRaise); }  dialogService.notify(Localization.lang("Files opened") + ": " + (filesToOpen.size())); }"


"private final List<Integer> m_pathToNode;"



" private List<Path> getFileListFromNode(CheckBoxTreeItem<FileNodeWrapper> node) { List<Path> filesList = new ArrayList<>(); for (TreeItem<FileNodeWrapper> childNode : node.getChildren()) { CheckBoxTreeItem<FileNodeWrapper> child = (CheckBoxTreeItem<FileNodeWrapper>) childNode; if (child.isLeaf() && child.isSelected()) { Path nodeFile = child.getValue().path; if ((nodeFile != null) && Files.isRegularFile(nodeFile)) { filesList.add(nodeFile); } } } return filesList; }"

"public String getConstant() { return constant; }"
"public class CopyDoiUrlAction extends SimpleCommand {  private TextArea component;  public CopyDoiUrlAction(TextArea component) { this.component = component; }  @Override public void execute() { String identifier = component.getText();  Optional<String> urlOptional = DOI.parse(identifier).map(DOI::getURIAsASCIIString); if (urlOptional.isPresent()) { Globals.clipboardManager.setContent(urlOptional.get()); JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("The link has been copied to the clipboard.")); } else { JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Invalid DOI: '%0'.", identifier)); } } }"


" <V> Future<V> execute(BackgroundTask<V> task);"

"private void doCleanup(CleanupPreset preset, BibEntry entry, NamedCompound ce) { // Create and run cleaner CleanupWorker cleaner = new CleanupWorker(panel.getBibDatabaseContext(), preferences.getCleanupPreferences( Globals.journalAbbreviationLoader)); List<FieldChange> changes = cleaner.cleanup(preset, entry);  if (changes.isEmpty()) { return; }  // Register undo action for (FieldChange change : changes) { ce.addEdit(new UndoableFieldChange(change)); } }"

"private void updateExternalFileTypes() { // First get a list of the default file types as a starting point: List<ExternalFileType> types = new ArrayList<>(getDefaultExternalFileTypes()); // If no changes have been stored, simply use the defaults: if (Globals.prefs.get(JabRefPreferences.EXTERNAL_FILE_TYPES, null) == null) { externalFileTypes.clear(); externalFileTypes.addAll(types); return; } // Read the prefs information for file types: String[][] vals = StringUtil .decodeStringDoubleArray(Globals.prefs.get(JabRefPreferences.EXTERNAL_FILE_TYPES, "")); for (String[] val : vals) { if ((val.length == 2) && val[1].equals(FILE_TYPE_REMOVED_FLAG)) { // This entry indicates that a default entry type should be removed: ExternalFileType toRemove = null; for (ExternalFileType type : types) { if (type.getName().equals(val[0])) { toRemove = type; break; } } // If we found it, remove it from the type list: if (toRemove != null) { types.remove(toRemove); } } else { // A new or modified entry type. Construct it from the string array: ExternalFileType type = CustomExternalFileType.buildFromArgs(val); // Check if there is a default type with the same name. If so, this is a // modification of that type, so remove the default one: ExternalFileType toRemove = null; for (ExternalFileType defType : types) { if (type.getName().equals(defType.getName())) { toRemove = defType; break; } } // If we found it, remove it from the type list: if (toRemove != null) { types.remove(toRemove); }  // Then add the new one: types.add(type); } }  // Finally, build the list of types based on the modified defaults list: externalFileTypes.addAll(types); }"
"public void notifyAboutFocus(BibEntry entry) { if (!entry.equals(currentEntry) || !entry.getType().equals(currentEntryType)) { currentEntry = entry; currentEntryType = entry.getType(); bindToEntry(entry); } handleFocus(); }"


"public void editGroup(GroupNodeViewModel oldGroup) { Optional<AbstractGroup> newGroup = dialogService .showCustomDialogAndWait(new GroupDialog(dialogService, oldGroup.getGroupNode().getGroup())); newGroup.ifPresent(group -> { // TODO: Keep assignments boolean keepPreviousAssignments = dialogService.showConfirmationDialogAndWait( Localization.lang("Change of Grouping Method"), Localization.lang("Assign the original group's entries to this group?")); //        WarnAssignmentSideEffects.warnAssignmentSideEffects(newGroup, panel.frame()); boolean removePreviousAssignments = (oldGroup.getGroupNode().getGroup() instanceof ExplicitGroup) && (group instanceof ExplicitGroup);  oldGroup.getGroupNode().setGroup( group, keepPreviousAssignments, removePreviousAssignments, stateManager.getEntriesInCurrentDatabase());  // TODO: Add undo // Store undo information. // AbstractUndoableEdit undoAddPreviousEntries = null; // UndoableModifyGroup undo = new UndoableModifyGroup(GroupSelector.this, groupsRoot, node, newGroup); // if (undoAddPreviousEntries == null) { //    panel.getUndoManager().addEdit(undo); //} else { //    NamedCompound nc = new NamedCompound("Modify Group"); //    nc.addEdit(undo); //    nc.addEdit(undoAddPreviousEntries); //    nc.end();/ //      panel.getUndoManager().addEdit(nc); //} //if (!addChange.isEmpty()) { //    undoAddPreviousEntries = UndoableChangeEntriesOfGroup.getUndoableEdit(null, addChange); //}  dialogService.notify(Localization.lang("Modified group \"%0\".", group.getName())); writeGroupChangesToMetaData();  // This is ugly but we have no proper update mechanism in place to propagate the changes, so redraw everything refresh(); }); }"

"public List<String> parseRefMarkName(String name) { List<String> keys = new ArrayList<>(); Matcher citeMatcher = CITE_PATTERN.matcher(name); if (citeMatcher.find()) { String[] keystring = citeMatcher.group(2).split(","); for (String aKeystring : keystring) { if (!keys.contains(aKeystring)) { keys.add(aKeystring); } } } return keys; }"









"protected static ClipboardContent processHtml(List<String> citations) { String result = "<!DOCTYPE html>" + OS.NEWLINE + "<html>" + OS.NEWLINE + "   <head>" + OS.NEWLINE + "      <meta charset=\"utf-8\">" + OS.NEWLINE + "   </head>" + OS.NEWLINE + "   <body>" + OS.NEWLINE + OS.NEWLINE;  result += String.join(CitationStyleOutputFormat.HTML.getLineSeparator(), citations); result += OS.NEWLINE + "   </body>" + OS.NEWLINE + "</html>" + OS.NEWLINE;  ClipboardContent content = new ClipboardContent(); content.putHtml(result); return content; }"




"public ZipFileChooser(FileSystem zipFile) throws IOException { setTitle(Localization.lang("Select file from ZIP-archive"));  TableView<Path> table = new TableView<>(getSelectableZipEntries(zipFile)); TableColumn<Path, String> nameColumn = new TableColumn<>(Localization.lang("Name")); TableColumn<Path, String> modifiedColumn = new TableColumn<>(Localization.lang("Last modified")); TableColumn<Path, Number> sizeColumn = new TableColumn<>(Localization.lang("Size")); table.getColumns().add(nameColumn); table.getColumns().add(modifiedColumn); table.getColumns().add(sizeColumn); nameColumn.setCellValueFactory(data -> new ReadOnlyStringWrapper(data.getValue().toString())); modifiedColumn.setCellValueFactory(data -> { try { return new ReadOnlyStringWrapper( ZonedDateTime.ofInstant(Files.getLastModifiedTime(data.getValue()).toInstant(), ZoneId.systemDefault()) .format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM))); } catch (IOException e) { // Ignore return new ReadOnlyStringWrapper(""); } }); sizeColumn.setCellValueFactory(data -> { try { return new ReadOnlyLongWrapper(Files.size(data.getValue())); } catch (IOException e) { // Ignore return new ReadOnlyLongWrapper(0); } }); table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);  getDialogPane().setContent(table);  getDialogPane().getButtonTypes().setAll( ButtonType.OK, ButtonType.CANCEL );  setResultConverter(button -> { if (button == ButtonType.OK) { return table.getSelectionModel().getSelectedItem(); } else { return null; } }); }"





"public void setProgressBarVisible(final boolean visible) { progressBar.setVisible(visible); }"
"private static String pathToClass(String basePath, Path path) { String className = FileUtil.relativize(path, Collections.singletonList(Paths.get(basePath))).toString(); if (className != null) { int lastDot = className.lastIndexOf('.'); if (lastDot < 0) { return className; } className = className.substring(0, lastDot); } return className; }"



"public interface GUIPostOpenAction {  /** * This method is queried in order to find out whether the action needs to be * performed or not. * @param pr The result of the BIB parse operation. * @return true if the action should be called, false otherwise. */ boolean isActionNecessary(ParserResult pr);  /** * This method is called after the new database has been added to the GUI, if * the isActionNecessary() method returned true. * * Note: if several such methods need to be called sequentially, it is *       important that all implementations of this method do not return *       until the operation is finished. * * @param panel The BasePanel where the database is shown. * @param pr The result of the BIB parse operation. */ void performAction(BasePanel panel, ParserResult pr); }"





"public abstract class SuggestionProvider<T> implements Callback<ISuggestionRequest, Collection<T>> {  private final Collection<T> possibleSuggestions = new HashSet<>(); private final Object possibleSuggestionsLock = new Object();  /** * Create a default suggestion provider based on the toString() method of the generic objects * @param possibleSuggestions All possible suggestions */ public static <T> SuggestionProvider<T> create(Collection<T> possibleSuggestions) { return create(null, possibleSuggestions); }  /** * Create a default suggestion provider based on the toString() method of the generic objects * using the provided stringConverter * * @param stringConverter A stringConverter which converts generic T into a string * @param possibleSuggestions All possible suggestions */ public static <T> SuggestionProvider<T> create(Callback<T, String> stringConverter, Collection<T> possibleSuggestions) { SuggestionProviderString<T> suggestionProvider = new SuggestionProviderString<>(stringConverter); suggestionProvider.addPossibleSuggestions(possibleSuggestions); return suggestionProvider; }  /** * Add the given new possible suggestions to this  SuggestionProvider */ public void addPossibleSuggestions(@SuppressWarnings("unchecked") T... newPossible) { addPossibleSuggestions(Arrays.asList(newPossible)); }  /** * Add the given new possible suggestions to this  SuggestionProvider */ public void addPossibleSuggestions(Collection<T> newPossible) { synchronized (possibleSuggestionsLock) { possibleSuggestions.addAll(newPossible); } }  /** * Remove all current possible suggestions */ public void clearSuggestions() { synchronized (possibleSuggestionsLock) { possibleSuggestions.clear(); } }  @Override public final Collection<T> call(final ISuggestionRequest request) { List<T> suggestions = new ArrayList<>(); if (!request.getUserText().isEmpty()) { synchronized (possibleSuggestionsLock) { for (T possibleSuggestion : possibleSuggestions) { if (isMatch(possibleSuggestion, request)) { suggestions.add(possibleSuggestion); } } } suggestions.sort(getComparator()); } return suggestions; }  /** * Get the comparator to order the suggestions */ protected abstract Comparator<T> getComparator();  /** * Check the given possible suggestion is a match (is a valid suggestion) */ protected abstract boolean isMatch(T suggestion, ISuggestionRequest request);  /** * This is a simple string based suggestion provider. * All generic suggestions T are turned into strings for processing. * */ private static class SuggestionProviderString<T> extends SuggestionProvider<T> {  private Callback<T, String> stringConverter;  private final Comparator<T> stringComparator = new Comparator<T>() { @Override public int compare(T o1, T o2) { String o1str = stringConverter.call(o1); String o2str = stringConverter.call(o2); return o1str.compareTo(o2str); } };  /** * Create a new SuggestionProviderString */ public SuggestionProviderString(Callback<T, String> stringConverter) { this.stringConverter = stringConverter;  // In case no stringConverter was provided, use the default strategy if (this.stringConverter == null) { this.stringConverter = obj -> { return obj != null ? obj.toString() : ""; //$NON-NLS-1$ }; } }  /**{@inheritDoc}*/ @Override protected Comparator<T> getComparator() { return stringComparator; }  /**{@inheritDoc}*/ @Override protected boolean isMatch(T suggestion, ISuggestionRequest request) { String userTextLower = request.getUserText().toLowerCase(); String suggestionStr = suggestion.toString().toLowerCase(); return suggestionStr.contains(userTextLower); } } }"
"private Optional<Version> getNewVersion() throws IOException { List<Version> availableVersions = Version.getAllAvailableVersions(); return installedVersion.shouldBeUpdatedTo(availableVersions); }"
"private void showConnectionError(Exception exception, boolean manualExecution) { String couldNotConnect = Localization.lang("Could not connect to the update server."); String tryLater = Localization.lang("Please try again later and/or check your network connection."); if (manualExecution) { dialogService.showErrorDialogAndWait(Localization.lang("Error"), couldNotConnect + "\n" + tryLater, exception); } LOGGER.warn(couldNotConnect + " " + tryLater, exception); }"




"public static final XComponentContext defaultBootstrap_InitialComponentContext(String ini_file, Map<String, String> bootstrap_parameters) throws Exception { // jni convenience: easier to iterate over array than calling Hashtable String pairs[] = null; if (null != bootstrap_parameters) { pairs = new String[2 * bootstrap_parameters.size()]; int n = 0; for (Map.Entry<String, String> bootstrap_parameter : bootstrap_parameters.entrySet()) { pairs[n++] = bootstrap_parameter.getKey(); pairs[n++] = bootstrap_parameter.getValue(); } }  if (!M_LOADED_JUH) { if ("The Android Project".equals(System.getProperty("java.vendor"))) { // Find out if we are configured with DISABLE_DYNLOADING or // not. Try to load the lo-bootstrap shared library which // won't exist in the DISABLE_DYNLOADING case. (And which will // be already loaded otherwise, so nothing unexpected happens // that case.) Yeah, this would be simpler if I just could be // bothered to keep a separate branch for DISABLE_DYNLOADING // on Android, merging in master periodically, until I know // for sure whether it is what I want, or not.  boolean disable_dynloading = false; try { System.loadLibrary("lo-bootstrap"); } catch (UnsatisfiedLinkError e) { disable_dynloading = true; }  if (!disable_dynloading) { NativeLibraryLoader.loadLibrary(Bootstrap.class.getClassLoader(), "juh"); } } else { NativeLibraryLoader.loadLibrary(Bootstrap.class.getClassLoader(), "juh"); } M_LOADED_JUH = true; } return UnoRuntime.queryInterface(XComponentContext.class, cppuhelper_bootstrap(ini_file, pairs, Bootstrap.class.getClassLoader())); }"



"private static UndoableEdit massAppendField(Collection<BibEntry> entries, Field field, String textToAppend) { String newValue = "";  if (textToAppend != null) { newValue = textToAppend; }  NamedCompound compoundEdit = new NamedCompound(Localization.lang("Append field")); for (BibEntry entry : entries) { Optional<String> oldValue = entry.getField(field); entry.setField(field, oldValue.orElse("") + newValue); compoundEdit.addEdit(new UndoableFieldChange(entry, field, oldValue.orElse(null), newValue)); } compoundEdit.end(); return compoundEdit; }"



"public boolean acceptableDrop(Dragboard dragboard) { // TODO: we should also check isNodeDescendant boolean canDropOtherGroup = dragboard.hasContent(DragAndDropDataFormats.GROUP); boolean canDropEntries = localDragBoard.hasBibEntries() && (groupNode.getGroup() instanceof GroupEntryChanger); return canDropOtherGroup || canDropEntries; }"

"private ScrollPane getPrivacyDialog(BibEntry entry) { ScrollPane root = new ScrollPane(); root.getStyleClass().add("related-articles-tab"); VBox vbox = new VBox(); vbox.getStyleClass().add("gdpr-dialog"); vbox.setSpacing(20.0);  Button button = new Button(Localization.lang("I Agree")); button.setDefaultButton(true);  Text line1 = new Text(Localization.lang("JabRef requests recommendations from Mr. DLib, which is an external service. To enable Mr. DLib to calculate recommendations, some of your data must be shared with Mr. DLib. Generally, the more data is shared the better recommendations can be calculated. However, we understand that some of your data in JabRef is sensitive, and you may not want to share it. Therefore, Mr. DLib offers a choice of which data you would like to share.")); line1.setWrappingWidth(1300.0); Text line2 = new Text(Localization.lang("Whatever option you choose, Mr. DLib may share its data with research partners to further improve recommendation quality as part of a 'living lab'. Mr. DLib may also release public datasets that may contain anonymized information about you and the recommendations (sensitive information such as metadata of your articles will be anonymised through e.g. hashing). Research partners are obliged to adhere to the same strict data protection policy as Mr. DLib.")); line2.setWrappingWidth(1300.0); Text line3 = new Text(Localization.lang("This setting may be changed in preferences at any time.")); Hyperlink mdlLink = new Hyperlink(Localization.lang("Further information about Mr DLib. for JabRef users.")); mdlLink.setOnAction(event -> { try { JabRefDesktop.openBrowser("http://mr-dlib.org/information-for-users/information-about-mr-dlib-for-jabref-users/"); } catch (IOException e) { LOGGER.error("Error opening the browser to Mr. DLib information page.", e); dialogService.showErrorDialogAndWait(e); } }); VBox vb = new VBox(); CheckBox cbTitle = new CheckBox(Localization.lang("Entry Title (Required to deliver recommendations.)")); cbTitle.setSelected(true); cbTitle.setDisable(true); CheckBox cbVersion = new CheckBox(Localization.lang("JabRef Version (Required to ensure backwards compatibility with Mr. DLib's Web Service)")); cbVersion.setSelected(true); cbVersion.setDisable(true); CheckBox cbLanguage = new CheckBox(Localization.lang("JabRef Language (Provides for better recommendations by giving an indication of user's preferred language.)")); CheckBox cbOS = new CheckBox(Localization.lang("Operating System (Provides for better recommendations by giving an indication of user's system set-up.)")); CheckBox cbTimezone = new CheckBox(Localization.lang("Timezone (Provides for better recommendations by indicating the time of day the request is being made.)")); vb.getChildren().addAll(cbTitle, cbVersion, cbLanguage, cbOS, cbTimezone); vb.setSpacing(10);  button.setOnAction(event -> { JabRefPreferences prefs = JabRefPreferences.getInstance(); prefs.putBoolean(JabRefPreferences.ACCEPT_RECOMMENDATIONS, true); prefs.putBoolean(JabRefPreferences.SEND_LANGUAGE_DATA, cbLanguage.isSelected()); prefs.putBoolean(JabRefPreferences.SEND_OS_DATA, cbOS.isSelected()); prefs.putBoolean(JabRefPreferences.SEND_TIMEZONE_DATA, cbTimezone.isSelected()); dialogService.showWarningDialogAndWait(Localization.lang("Restart"), Localization.lang("Please restart JabRef for preferences to take effect.")); setContent(getRelatedArticlesPane(entry)); });  vbox.getChildren().addAll(line1, line2, mdlLink, line3, vb, button); root.setContent(vbox);  return root; }"

"private void initialize() { Button buttonBrowse = new Button(Localization.lang("Browse")); buttonBrowse.setTooltip(new Tooltip(Localization.lang("Opens the file browser."))); buttonBrowse.getStyleClass().add("text-button"); buttonBrowse.setOnAction(e -> { DirectoryDialogConfiguration directoryDialogConfiguration = new DirectoryDialogConfiguration.Builder() .withInitialDirectory(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).build(); dialogService.showDirectorySelectionDialog(directoryDialogConfiguration) .ifPresent(selectedDirectory -> { textfieldDirectoryPath.setText(selectedDirectory.toAbsolutePath().toString()); preferences.put(JabRefPreferences.WORKING_DIRECTORY, selectedDirectory.toAbsolutePath().toString()); }); });  buttonScan = new Button(Localization.lang("Scan directory")); buttonScan.setTooltip(new Tooltip((Localization.lang("Searches the selected directory for unlinked files.")))); buttonScan.setOnAction(e -> startSearch()); buttonScan.setDefaultButton(true); buttonScan.setPadding(new Insets(5, 0, 0, 0));  buttonExport = new Button(Localization.lang("Export selected entries")); buttonExport.setTooltip(new Tooltip(Localization.lang("Export to text file."))); buttonExport.getStyleClass().add("text-button"); buttonExport.setDisable(true); buttonExport.setOnAction(e -> startExport());  ButtonType buttonTypeImport = new ButtonType(Localization.lang("Import"), ButtonBar.ButtonData.OK_DONE); getDialogPane().getButtonTypes().setAll( buttonTypeImport, ButtonType.CANCEL ); buttonApply = (Button) getDialogPane().lookupButton(buttonTypeImport); buttonApply.setTooltip(new Tooltip((Localization.lang("Starts the import of BibTeX entries.")))); buttonApply.setDisable(true);  /* Actions for the TreeView */ Button buttonOptionSelectAll = new Button(); buttonOptionSelectAll.setText(Localization.lang("Select all")); buttonOptionSelectAll.getStyleClass().add("text-button"); buttonOptionSelectAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); // Need to toggle a twice to make sure everything is selected root.setSelected(true); root.setSelected(false); root.setSelected(true); }); Button buttonOptionDeselectAll = new Button(); buttonOptionDeselectAll.setText(Localization.lang("Unselect all")); buttonOptionDeselectAll.getStyleClass().add("text-button"); buttonOptionDeselectAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); // Need to toggle a twice to make sure nothing is selected root.setSelected(false); root.setSelected(true); root.setSelected(false); }); Button buttonOptionExpandAll = new Button(); buttonOptionExpandAll.setText(Localization.lang("Expand all")); buttonOptionExpandAll.getStyleClass().add("text-button"); buttonOptionExpandAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); expandTree(root, true); }); Button buttonOptionCollapseAll = new Button(); buttonOptionCollapseAll.setText(Localization.lang("Collapse all")); buttonOptionCollapseAll.getStyleClass().add("text-button"); buttonOptionCollapseAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); expandTree(root, false); root.setExpanded(true); });  textfieldDirectoryPath = new TextField(); Path initialPath = databaseContext.getFirstExistingFileDir(preferences.getFilePreferences()) .orElse(preferences.getWorkingDir()); textfieldDirectoryPath.setText(initialPath.toAbsolutePath().toString());  Label labelDirectoryDescription = new Label(Localization.lang("Select a directory where the search shall start.")); Label labelFileTypesDescription = new Label(Localization.lang("Select file type:")); Label labelFilesDescription = new Label(Localization.lang("These files are not linked in the active library.")); Label labelSearchingDirectoryInfo = new Label(Localization.lang("Searching file system..."));  tree = new TreeView<>(); tree.setPrefWidth(Double.POSITIVE_INFINITY);  ScrollPane scrollPaneTree = new ScrollPane(tree); scrollPaneTree.setFitToWidth(true);  ProgressIndicator progressBarSearching = new ProgressIndicator(); progressBarSearching.setMaxSize(50, 50);  setResultConverter(buttonPressed -> { if (buttonPressed == buttonTypeImport) { startImport(); } else { if (findUnlinkedFilesTask != null) { findUnlinkedFilesTask.cancel(); } } return null; });  new ViewModelTreeCellFactory<FileNodeWrapper>() .withText(node -> { if (Files.isRegularFile(node.path)) { // File return node.path.getFileName().toString(); } else { // Directory return node.path.getFileName() + " (" + node.fileCount + " file" + (node.fileCount > 1 ? "s" : "") + ")"; } }) .install(tree); List<FileChooser.ExtensionFilter> fileFilterList = Arrays.asList( FileFilterConverter.ANY_FILE, FileFilterConverter.toExtensionFilter(StandardFileType.PDF), FileFilterConverter.toExtensionFilter(StandardFileType.BIBTEX_DB) );  comboBoxFileTypeSelection = new ComboBox<>(FXCollections.observableArrayList(fileFilterList)); comboBoxFileTypeSelection.getSelectionModel().selectFirst(); new ViewModelListCellFactory<FileChooser.ExtensionFilter>() .withText(fileFilter -> fileFilter.getDescription() + fileFilter.getExtensions().stream().collect(Collectors.joining(", ", " (", ")"))) .withIcon(fileFilter -> ExternalFileTypes.getInstance().getExternalFileTypeByExt(fileFilter.getExtensions().get(0)) .map(ExternalFileType::getIcon) .orElse(null)) .install(comboBoxFileTypeSelection);  panelSearchProgress = new VBox(5, labelSearchingDirectoryInfo, progressBarSearching); panelSearchProgress.toFront(); panelSearchProgress.setVisible(false);  //        panelDirectory.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), //                Localization.lang("Select directory"))); //        panelFiles.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), //                Localization.lang("Select files"))); //        panelEntryTypesSelection.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), //                Localization.lang("BibTeX entry creation")));  VBox panelDirectory = new VBox(5); panelDirectory.getChildren().setAll( labelDirectoryDescription, new HBox(10, textfieldDirectoryPath, buttonBrowse), new HBox(15, labelFileTypesDescription, comboBoxFileTypeSelection), buttonScan ); HBox.setHgrow(textfieldDirectoryPath, Priority.ALWAYS);  StackPane stackPaneTree = new StackPane(scrollPaneTree, panelSearchProgress); StackPane.setAlignment(panelSearchProgress, Pos.CENTER); BorderPane panelFiles = new BorderPane(); panelFiles.setTop(labelFilesDescription); panelFiles.setCenter(stackPaneTree); panelFiles.setBottom(new HBox(5, buttonOptionSelectAll, buttonOptionDeselectAll, buttonOptionExpandAll, buttonOptionCollapseAll, buttonExport));  VBox container = new VBox(20); container.getChildren().addAll( panelDirectory, panelFiles ); container.setPrefWidth(600); getDialogPane().setContent(container); }"

"private ObjectProperty<IconTheme.JabRefIcons> glyph;"

"public static final int REMOVE_NODE_AND_CHILDREN = 2;"
" public class VersionWorker {  private static final Logger LOGGER = LoggerFactory.getLogger(VersionWorker.class);  /** * The current version of the installed JabRef */ private final Version installedVersion;  /** * The version which was previously ignored by the user */ private final Version toBeIgnored; private final DialogService dialogService; private final TaskExecutor taskExecutor;  public VersionWorker(Version installedVersion, Version toBeIgnored, DialogService dialogService, TaskExecutor taskExecutor) { this.installedVersion = Objects.requireNonNull(installedVersion); this.toBeIgnored = Objects.requireNonNull(toBeIgnored); this.dialogService = Objects.requireNonNull(dialogService); this.taskExecutor = Objects.requireNonNull(taskExecutor); }  /** * Returns a newer version excluding any non-stable versions, except if the installed one is unstable too. If no * newer version was found, then an empty optional is returned. */ private Optional<Version> getNewVersion() throws IOException { List<Version> availableVersions = Version.getAllAvailableVersions(); return installedVersion.shouldBeUpdatedTo(availableVersions); }  public void checkForNewVersionAsync() { BackgroundTask.wrap(this::getNewVersion) .onSuccess(version -> showUpdateInfo(version, true)) .onFailure(exception -> showConnectionError(exception, true)) .executeWith(taskExecutor); }  public void checkForNewVersionDelayed() { BackgroundTask.wrap(this::getNewVersion) .onSuccess(version -> showUpdateInfo(version, false)) .onFailure(exception -> showConnectionError(exception, false)) .scheduleWith(taskExecutor, 30, TimeUnit.SECONDS); }  /** * Prints the connection problem to the status bar and shows a dialog if it was executed manually */ private void showConnectionError(Exception exception, boolean manualExecution) { String couldNotConnect = Localization.lang("Could not connect to the update server."); String tryLater = Localization.lang("Please try again later and/or check your network connection."); if (manualExecution) { dialogService.showErrorDialogAndWait(Localization.lang("Error"), couldNotConnect + "\n" + tryLater, exception); } LOGGER.warn(couldNotConnect + " " + tryLater, exception); }  /** * Prints up-to-date to the status bar (and shows a dialog it was executed manually) if there is now new version. * Shows a "New Version" Dialog to the user if there is. */ private void showUpdateInfo(Optional<Version> newerVersion, boolean manualExecution) { // no new version could be found, only respect the ignored version on automated version checks if (!newerVersion.isPresent() || (newerVersion.get().equals(toBeIgnored) && !manualExecution)) { if (manualExecution) { dialogService.notify(Localization.lang("JabRef is up-to-date.")); } } else { // notify the user about a newer version new NewVersionDialog(installedVersion, newerVersion.get()).showAndWait(); } } }"


"public JabRefAction(Action action, Command command, KeyBindingRepository keyBindingRepository, Sources source) { this(action, keyBindingRepository);  setEventHandler(event -> { command.execute(); if (source == null) { trackExecute(getActionName(action, command)); } else { trackUserActionSource(getActionName(action, command), source); } });  disabledProperty().bind(command.executableProperty().not());  if (command instanceof SimpleCommand) { SimpleCommand ourCommand = (SimpleCommand) command; longTextProperty().bind(Bindings.concat(action.getDescription(), ourCommand.statusMessageProperty())); } }"
"public class SaveDatabaseAction { private static final Logger LOGGER = LoggerFactory.getLogger(SaveDatabaseAction.class);  private final BasePanel panel; private final JabRefFrame frame; private final DialogService dialogService; private final JabRefPreferences prefs; private final BibEntryTypesManager entryTypesManager;  public SaveDatabaseAction(BasePanel panel, JabRefPreferences prefs, BibEntryTypesManager entryTypesManager) { this.panel = panel; this.frame = panel.frame(); this.dialogService = frame.getDialogService(); this.prefs = prefs; this.entryTypesManager = entryTypesManager; }  private boolean saveDatabase(Path file, boolean selectedOnly, Charset encoding, SavePreferences.DatabaseSaveType saveType) throws SaveException { try { SavePreferences preferences = prefs.loadForSaveFromPreferences() .withEncoding(encoding) .withSaveType(saveType);  AtomicFileWriter fileWriter = new AtomicFileWriter(file, preferences.getEncoding(), preferences.makeBackup()); BibtexDatabaseWriter databaseWriter = new BibtexDatabaseWriter(fileWriter, preferences, entryTypesManager);  if (selectedOnly) { databaseWriter.savePartOfDatabase(panel.getBibDatabaseContext(), panel.getSelectedEntries()); } else { databaseWriter.saveDatabase(panel.getBibDatabaseContext()); }  panel.registerUndoableChanges(databaseWriter.getSaveActionsFieldChanges());  if (fileWriter.hasEncodingProblems()) { saveWithDifferentEncoding(file, selectedOnly, preferences.getEncoding(), fileWriter.getEncodingProblems(), saveType); } } catch (UnsupportedCharsetException ex) { throw new SaveException(Localization.lang("Character encoding '%0' is not supported.", encoding.displayName()), ex); } catch (IOException ex) { throw new SaveException("Problems saving:", ex); }  return true; }  private void saveWithDifferentEncoding(Path file, boolean selectedOnly, Charset encoding, Set<Character> encodingProblems, SavePreferences.DatabaseSaveType saveType) throws SaveException { DialogPane pane = new DialogPane(); VBox vbox = new VBox(); vbox.getChildren().addAll( new Text(Localization.lang("The chosen encoding '%0' could not encode the following characters:", encoding.displayName())), new Text(encodingProblems.stream().map(Object::toString).collect(Collectors.joining("."))), new Text(Localization.lang("What do you want to do?")) ); pane.setContent(vbox);  ButtonType tryDifferentEncoding = new ButtonType(Localization.lang("Try different encoding"), ButtonBar.ButtonData.OTHER); ButtonType ignore = new ButtonType(Localization.lang("Ignore"), ButtonBar.ButtonData.APPLY); boolean saveWithDifferentEncoding = frame.getDialogService() .showCustomDialogAndWait(Localization.lang("Save library"), pane, ignore, tryDifferentEncoding) .filter(buttonType -> buttonType.equals(tryDifferentEncoding)) .isPresent(); if (saveWithDifferentEncoding) { Optional<Charset> newEncoding = frame.getDialogService().showChoiceDialogAndWait(Localization.lang("Save library"), Localization.lang("Select new encoding"), Localization.lang("Save library"), encoding, Encodings.getCharsets()); if (newEncoding.isPresent()) { saveDatabase(file, selectedOnly, newEncoding.get(), saveType);  // Make sure to remember which encoding we used. panel.getBibDatabaseContext().getMetaData().setEncoding(newEncoding.get(), ChangePropagation.DO_NOT_POST_EVENT); } } }  private boolean doSave() { Path targetPath = panel.getBibDatabaseContext().getDatabasePath().get(); try { // Save the database boolean success = saveDatabase(targetPath, false, panel.getBibDatabaseContext() .getMetaData() .getEncoding() .orElse(prefs.getDefaultEncoding()), SavePreferences.DatabaseSaveType.ALL);  if (success) { panel.updateTimeStamp(); panel.getUndoManager().markUnchanged(); // (Only) after a successful save the following // statement marks that the base is unchanged // since last save: panel.setNonUndoableChange(false); panel.setBaseChanged(false); panel.markExternalChangesAsResolved();  // Reset title of tab frame.setTabTitle(panel, panel.getTabTitle(), panel.getBibDatabaseContext().getDatabaseFile().get().getAbsolutePath()); frame.getDialogService().notify(Localization.lang("Saved library") + " '" + panel.getBibDatabaseContext().getDatabaseFile().get().getPath() + "'."); frame.setWindowTitle(); frame.updateAllTabTitles(); } return success; } catch (SaveException ex) { LOGGER.error("A problem occurred when trying to save the file " + targetPath, ex); frame.getDialogService().showErrorDialogAndWait(Localization.lang("Save library"), Localization.lang("Could not save file."), ex); return false; } finally { // release panel from save status panel.setSaving(false); } }  public boolean save() { if (panel.getBibDatabaseContext().getDatabasePath().isPresent()) { panel.frame().getDialogService().notify(Localization.lang("Saving library") + "..."); panel.setSaving(true); return doSave(); } else { Optional<Path> savePath = getSavePath(); if (savePath.isPresent()) { saveAs(savePath.get()); return true; } }  return false; }  public void saveAs() { getSavePath().ifPresent(this::saveAs); }  private Optional<Path> getSavePath() { FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .addExtensionFilter(StandardFileType.BIBTEX_DB) .withDefaultExtension(StandardFileType.BIBTEX_DB) .withInitialDirectory(prefs.get(JabRefPreferences.WORKING_DIRECTORY)) .build(); Optional<Path> selectedPath = dialogService.showFileSaveDialog(fileDialogConfiguration); selectedPath.ifPresent(path -> prefs.setWorkingDir(path.getParent())); return selectedPath; }  public void saveAs(Path file) { BibDatabaseContext context = panel.getBibDatabaseContext();  // Close AutosaveManager and BackupManager for original library Optional<Path> databasePath = context.getDatabasePath(); if (databasePath.isPresent()) { final Path oldFile = databasePath.get(); context.setDatabaseFile(oldFile.toFile()); AutosaveManager.shutdown(context); BackupManager.shutdown(context); }  // Set new location if (context.getLocation() == DatabaseLocation.SHARED) { // Save all properties dependent on the ID. This makes it possible to restore them. new SharedDatabasePreferences(context.getDatabase().generateSharedDatabaseID()) .putAllDBMSConnectionProperties(context.getDBMSSynchronizer().getConnectionProperties()); } context.setDatabaseFile(file);  // Save save();  // Reinstall AutosaveManager and BackupManager panel.resetChangeMonitorAndChangePane(); if (readyForAutosave(context)) { AutosaveManager autosaver = AutosaveManager.start(context); autosaver.registerListener(new AutosaveUIManager(panel)); } if (readyForBackup(context)) { BackupManager.start(context, entryTypesManager, prefs); }  context.getDatabasePath().ifPresent(presentFile -> frame.getFileHistory().newFile(presentFile)); }  private boolean readyForAutosave(BibDatabaseContext context) { return ((context.getLocation() == DatabaseLocation.SHARED) || ((context.getLocation() == DatabaseLocation.LOCAL) && prefs.getBoolean(JabRefPreferences.LOCAL_AUTO_SAVE))) && context.getDatabasePath().isPresent(); }  private boolean readyForBackup(BibDatabaseContext context) { return (context.getLocation() == DatabaseLocation.LOCAL) && context.getDatabasePath().isPresent(); }  public void saveSelectedAsPlain() { getSavePath().ifPresent(path -> { try { saveDatabase(path, true, prefs.getDefaultEncoding(), SavePreferences.DatabaseSaveType.PLAIN_BIBTEX); frame.getFileHistory().newFile(path); frame.getDialogService().notify(Localization.lang("Saved selected to '%0'.", path.toString())); } catch (SaveException ex) { LOGGER.error("A problem occurred when trying to save the file", ex); frame.getDialogService().showErrorDialogAndWait(Localization.lang("Save library"), Localization.lang("Could not save file."), ex); } }); } }"
"public static Supplier<List<MenuItem>> getDefaultMenu(final TextInputControl textInput) { return () -> { List<MenuItem> menuItems = new ArrayList<>(6); menuItems.add(new CaseChangeMenu(textInput.textProperty())); menuItems.add(new ConversionMenu(textInput.textProperty())); menuItems.add(new SeparatorMenuItem()); menuItems.add(new ProtectedTermsMenu(textInput)); menuItems.add(new SeparatorMenuItem()); menuItems.add(new ClearField(textInput)); return menuItems; }; }"

"List<String> getRestartWarnings();"
"private AutoCompletionTextInputBinding(final TextInputControl textInputControl, Callback<ISuggestionRequest, Collection<T>> suggestionProvider) { this(textInputControl, suggestionProvider, AutoCompletionTextInputBinding.defaultStringConverter(), new ReplaceStrategy()); }"




"@SuppressWarnings("unused") protected String[] getCommandLine(String keyString) { return new String[0]; }"
"private static void setGraphic(MenuItem node, Action action) { node.graphicProperty().unbind(); action.getIcon().ifPresent(icon -> node.setGraphic(icon.getGraphicNode())); }"

"public static final int REMOVE_NODE_KEEP_CHILDREN = 1; public static final int REMOVE_NODE_KEEP_CHILDREN = 1;"
"package org.jabref.gui.autocompleter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Comparator; import @SuppressWarnings("unused") protected String[] getCommandLine(String keyString) { return new String[0]; } package org.jabref.gui.autocompleter; import java.util.Collection; import javafx.beans.value.ChangeListener; import javafx.scene.control.TextInputControl; import javafx.util.Callback; import javafx.util.StringConverter; import org.controlsfx.control.textfield.AutoCompletionBinding; /** * Represents a binding between a text input control and a auto-completion popup * This class is a slightly modified version of {@link impl.org.controlsfx.autocompletion.AutoCompletionTextFieldBinding}* that works with general text input controls instead of just text fields. * @param <T> * */ public class AutoCompletionTextInputBinding<T> extends AutoCompletionBinding<T> { /*** String converter to be used to convert suggestions to strings. */ private StringConverter<T> converter; private AutoCompletionStrategy inputAnalyzer; private final ChangeListener<String> textChangeListener = (obs, oldText, newText) -> { if (getCompletionTarget().isFocused()) { setUserInputText(newText); } }; private boolean showOnFocus; private final ChangeListener<Boolean> focusChangedListener = (obs, oldFocused, newFocused) -> { if (newFocused) { if (showOnFocus) { setUserInputText(getCompletionTarget().getText());}} else { hidePopup(); }}; /*** Creates a new auto-completion binding between the given textInputControl * and the given suggestion provider. */ private AutoCompletionTextInputBinding(final TextInputControl textInputControl, Callback<ISuggestionRequest, Collection<T>> suggestionProvider) { this(textInputControl, suggestionProvider, AutoCompletionTextInputBinding.defaultStringConverter(), new ReplaceStrategy()); } private AutoCompletionTextInputBinding(final TextInputControl textInputControl, final Callback<ISuggestionRequest, Collection<T>> suggestionProvider, final StringConverter<T> converter) { this(textInputControl, suggestionProvider, converter, new ReplaceStrategy());} private AutoCompletionTextInputBinding(final TextInputControl textInputControl, final Callback<ISuggestionRequest, Collection<T>> suggestionProvider, final StringConverter<T> converter, final AutoCompletionStrategy inputAnalyzer) { super(textInputControl, suggestionProvider, converter); this.converter = converter; this.inputAnalyzer = inputAnalyzer; getCompletionTarget().textProperty().addListener(textChangeListener); getCompletionTarget().focusedProperty().addListener(focusChangedListener); } private static <T> StringConverter<T> defaultStringConverter() { return new StringConverter<T>() { @Override public String toString(T t) { return t == null ? null : t.toString(); } @SuppressWarnings("unchecked") @Override public T fromString(String string) { return (T) string; } }; } public static <T> void autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider) { new AutoCompletionTextInputBinding<>(textArea, suggestionProvider);} public static <T> void autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider, StringConverter<T> converter) { new AutoCompletionTextInputBinding<>(textArea, suggestionProvider, converter); } public static <T> AutoCompletionTextInputBinding<T> autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider, StringConverter<T> converter, AutoCompletionStrategy inputAnalyzer) { return new AutoCompletionTextInputBinding<>(textArea, suggestionProvider, converter, inputAnalyzer); } public static <T> AutoCompletionTextInputBinding<T> autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider, AutoCompletionStrategy inputAnalyzer) { return autoComplete(textArea, suggestionProvider, AutoCompletionTextInputBinding.defaultStringConverter(), inputAnalyzer);} private void setUserInputText(String newText) { if (newText == null) { newText = ""; } AutoCompletionInput input = inputAnalyzer.analyze(newText); setUserInput(input.getUnfinishedPart()); } @Override public TextInputControl getCompletionTarget() { return (TextInputControl) super.getCompletionTarget(); } @Override public void dispose() { getCompletionTarget().textProperty().removeListener(textChangeListener); getCompletionTarget().focusedProperty().removeListener(focusChangedListener); } @Override protected void completeUserInput(T completion) { String completionText = converter.toString(completion); String inputText = getCompletionTarget().getText(); if (inputText == null) { inputText = ""; } AutoCompletionInput input = inputAnalyzer.analyze(inputText); String newText = input.getPrefix() + completionText; getCompletionTarget().setText(newText); getCompletionTarget().positionCaret(newText.length()); } public void setShowOnFocus(boolean showOnFocus) { this.showOnFocus = showOnFocus; }}"


"private void setupClearButtonField(CustomTextField customTextField) { try { // TODO: reflective access, should be removed Method m = TextFields.class.getDeclaredMethod("setupClearButtonField", TextField.class, ObjectProperty.class); m.setAccessible(true); m.invoke(null, customTextField, customTextField.rightProperty()); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) { LOGGER.error("Failed to decorate text field with clear button", ex); } }"









"public void newFile(Path file) { history.newFile(file); setItems(); setDisable(false); }"
"public class CreateModifyExporterDialogViewModel extends AbstractViewModel {  private static final Logger LOGGER = LoggerFactory.getLogger(CreateModifyExporterDialogViewModel.class);  private final DialogService dialogService; private final PreferencesService preferences;  private final StringProperty name = new SimpleStringProperty(""); private final StringProperty layoutFile = new SimpleStringProperty(""); private final StringProperty extension = new SimpleStringProperty("");  private final JournalAbbreviationLoader loader;  public CreateModifyExporterDialogViewModel(ExporterViewModel exporter, DialogService dialogService, PreferencesService preferences, JournalAbbreviationLoader loader) { this.dialogService = dialogService; this.preferences = preferences; this.loader = loader;  //Set text of each of the boxes if (exporter != null) { name.setValue(exporter.name().get()); layoutFile.setValue(exporter.layoutFileName().get()); extension.setValue(exporter.extension().get()); } }  public ExporterViewModel saveExporter() { Path layoutFileDir = Paths.get(layoutFile.get()).getParent(); if (layoutFileDir != null) { String layoutFileDirString = layoutFileDir.toString(); preferences.setExportWorkingDirectory(layoutFileDirString); }  // Check that there are no empty strings. if (layoutFile.get().isEmpty() || name.get().isEmpty() || extension.get().isEmpty() || !layoutFile.get().endsWith(".layout")) {  LOGGER.info("One of the fields is empty or invalid!"); return null; }  // Create a new exporter to be returned to ExportCustomizationDialogViewModel, which requested it LayoutFormatterPreferences layoutPreferences = preferences.getLayoutFormatterPreferences(loader); SavePreferences savePreferences = preferences.loadForExportFromPreferences(); TemplateExporter format = new TemplateExporter(name.get(), layoutFile.get(), extension.get(), layoutPreferences, savePreferences); format.setCustomExport(true); return new ExporterViewModel(format); }  public String getExportWorkingDirectory() { return preferences.getExportWorkingDirectory(); }  public void browse() { FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .addExtensionFilter(Localization.lang("Custom layout file"), StandardFileType.LAYOUT) .withDefaultExtension(Localization.lang("Custom layout file"), StandardFileType.LAYOUT) .withInitialDirectory(getExportWorkingDirectory()).build(); dialogService.showFileOpenDialog(fileDialogConfiguration).ifPresent(f -> layoutFile.set(f.toAbsolutePath().toString())); }  public StringProperty getName() { return name; }  public StringProperty getLayoutFileName() { return layoutFile; }  public StringProperty getExtension() { return extension; } }"


"public class SmartConstrainedResizePolicy implements Callback<TableView.ResizeFeatures, Boolean> {  private static final Logger LOGGER = LoggerFactory.getLogger(SmartConstrainedResizePolicy.class);  @Override public Boolean call(TableView.ResizeFeatures prop) { if (prop.getColumn() == null) { return initColumnSize(prop.getTable()); } else { return constrainedResize(prop); } }  private Boolean initColumnSize(TableView<?> table) { double tableWidth = getContentWidth(table); List<? extends TableColumnBase<?, ?>> visibleLeafColumns = table.getVisibleLeafColumns(); double totalWidth = visibleLeafColumns.stream().mapToDouble(TableColumnBase::getWidth).sum();  if (Math.abs(totalWidth - tableWidth) > 1) { double totalPrefWidth = visibleLeafColumns.stream().mapToDouble(TableColumnBase::getPrefWidth).sum(); if (totalPrefWidth > 0) { for (TableColumnBase col : visibleLeafColumns) { double share = col.getPrefWidth() / totalPrefWidth; double newSize = tableWidth * share; resize(col, newSize - col.getWidth()); } } }  return false; }  private void resize(TableColumnBase column, double delta) { // We have to use reflection since TableUtil is not visible to us try { // TODO: reflective access, should be removed Class<?> clazz = Class.forName("javafx.scene.control.TableUtil"); Method constrainedResize = clazz.getDeclaredMethod("resize", TableColumnBase.class, double.class); constrainedResize.setAccessible(true); constrainedResize.invoke(null, column, delta); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | ClassNotFoundException e) { LOGGER.error("Could not invoke resize in TableUtil", e); } }  private Boolean constrainedResize(TableView.ResizeFeatures<?> prop) { TableView<?> table = prop.getTable(); List<? extends TableColumnBase<?, ?>> visibleLeafColumns = table.getVisibleLeafColumns(); return constrainedResize(prop, false, getContentWidth(table), visibleLeafColumns); }  private Boolean constrainedResize(TableView.ResizeFeatures prop, Boolean isFirstRun, Double contentWidth, List<? extends TableColumnBase<?, ?>> visibleLeafColumns) { // We have to use reflection since TableUtil is not visible to us try { // TODO: reflective access, should be removed Class<?> clazz = Class.forName("javafx.scene.control.TableUtil"); Method constrainedResize = clazz.getDeclaredMethod("constrainedResize", ResizeFeaturesBase.class, Boolean.TYPE, Double.TYPE, List.class); constrainedResize.setAccessible(true); Object returnValue = constrainedResize.invoke(null, prop, isFirstRun, contentWidth, visibleLeafColumns); return (Boolean) returnValue; } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | ClassNotFoundException e) { LOGGER.error("Could not invoke constrainedResize in TableUtil", e); return false; } }  private Double getContentWidth(TableView<?> table) { try { // TODO: reflective access, should be removed Field privateStringField = TableView.class.getDeclaredField("contentWidth"); privateStringField.setAccessible(true); return (Double) privateStringField.get(table); } catch (IllegalAccessException | NoSuchFieldException e) { return 0d; } } }"

"public void putBibEntries(List<BibEntry> entries) { putValue(BIB_ENTRIES, entries); }"
"public class OldCommandWrapperForActiveDatabase extends CommandBase {  private static final Logger LOGGER = LoggerFactory.getLogger(OldCommandWrapperForActiveDatabase.class);  private final Actions command;  public OldCommandWrapperForActiveDatabase(Actions command) { this.command = command; }  @Override public void execute() { try { JabRefGUI.getMainFrame().getCurrentBasePanel().runCommand(command); } catch (Throwable ex) { LOGGER.debug("Cannot execute command " + command + ".", ex); } }  @Override public double getProgress() { return 0; }  @Override public ReadOnlyDoubleProperty progressProperty() { return null; }  public void setExecutable(boolean executable) { this.executable.bind(BindingsHelper.constantOf(executable)); } }"





"public class AutoCompletionTextInputBinding<T> extends AutoCompletionBinding<T> {  /** * String converter to be used to convert suggestions to strings. */ private StringConverter<T> converter; private AutoCompletionStrategy inputAnalyzer; private final ChangeListener<String> textChangeListener = (obs, oldText, newText) -> { if (getCompletionTarget().isFocused()) { setUserInputText(newText); } }; private boolean showOnFocus; private final ChangeListener<Boolean> focusChangedListener = (obs, oldFocused, newFocused) -> { if (newFocused) { if (showOnFocus) { setUserInputText(getCompletionTarget().getText()); } } else { hidePopup(); } };  /** * Creates a new auto-completion binding between the given textInputControl * and the given suggestion provider. */ private AutoCompletionTextInputBinding(final TextInputControl textInputControl, Callback<ISuggestionRequest, Collection<T>> suggestionProvider) {  this(textInputControl, suggestionProvider, AutoCompletionTextInputBinding.defaultStringConverter(), new ReplaceStrategy()); }  private AutoCompletionTextInputBinding(final TextInputControl textInputControl, final Callback<ISuggestionRequest, Collection<T>> suggestionProvider, final StringConverter<T> converter) { this(textInputControl, suggestionProvider, converter, new ReplaceStrategy()); }  private AutoCompletionTextInputBinding(final TextInputControl textInputControl, final Callback<ISuggestionRequest, Collection<T>> suggestionProvider, final StringConverter<T> converter, final AutoCompletionStrategy inputAnalyzer) {  super(textInputControl, suggestionProvider, converter); this.converter = converter; this.inputAnalyzer = inputAnalyzer;  getCompletionTarget().textProperty().addListener(textChangeListener); getCompletionTarget().focusedProperty().addListener(focusChangedListener); }  private static <T> StringConverter<T> defaultStringConverter() { return new StringConverter<T>() { @Override public String toString(T t) { return t == null ? null : t.toString(); }  @SuppressWarnings("unchecked") @Override public T fromString(String string) { return (T) string; } }; }  public static <T> void autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider) { new AutoCompletionTextInputBinding<>(textArea, suggestionProvider); }  public static <T> void autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider, StringConverter<T> converter) { new AutoCompletionTextInputBinding<>(textArea, suggestionProvider, converter); }  public static <T> AutoCompletionTextInputBinding<T> autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider, StringConverter<T> converter, AutoCompletionStrategy inputAnalyzer) { return new AutoCompletionTextInputBinding<>(textArea, suggestionProvider, converter, inputAnalyzer); }  public static <T> AutoCompletionTextInputBinding<T> autoComplete(TextInputControl textArea, Callback<ISuggestionRequest, Collection<T>> suggestionProvider, AutoCompletionStrategy inputAnalyzer) { return autoComplete(textArea, suggestionProvider, AutoCompletionTextInputBinding.defaultStringConverter(), inputAnalyzer); }  private void setUserInputText(String newText) { if (newText == null) { newText = ""; } AutoCompletionInput input = inputAnalyzer.analyze(newText); setUserInput(input.getUnfinishedPart()); }  @Override public TextInputControl getCompletionTarget() { return (TextInputControl) super.getCompletionTarget(); }  @Override public void dispose() { getCompletionTarget().textProperty().removeListener(textChangeListener); getCompletionTarget().focusedProperty().removeListener(focusChangedListener); }  @Override protected void completeUserInput(T completion) { String completionText = converter.toString(completion); String inputText = getCompletionTarget().getText(); if (inputText == null) { inputText = ""; } AutoCompletionInput input = inputAnalyzer.analyze(inputText); String newText = input.getPrefix() + completionText; getCompletionTarget().setText(newText); getCompletionTarget().positionCaret(newText.length()); }  public void setShowOnFocus(boolean showOnFocus) { this.showOnFocus = showOnFocus; } }"
"public static LinkedFile fromFile(Path file, List<Path> fileDirectories, ExternalFileTypes externalFileTypesFile) { String fileExtension = FileHelper.getFileExtension(file).orElse(""); ExternalFileType suggestedFileType = externalFileTypesFile .getExternalFileTypeByExt(fileExtension) .orElse(new UnknownExternalFileType(fileExtension)); Path relativePath = FileUtil.relativize(file, fileDirectories); return new LinkedFile("", relativePath.toString(), suggestedFileType.getName()); }"
"public static <T> SuggestionProvider<T> create(Callback<T, String> stringConverter, Collection<T> possibleSuggestions) { SuggestionProviderString<T> suggestionProvider = new SuggestionProviderString<>(stringConverter); suggestionProvider.addPossibleSuggestions(possibleSuggestions); return suggestionProvider; }"

" public void updateFont() { // TODO: Font & padding customization // setFont(GUIGlobals.currentFont); }"
" class UpdateTimestampListener { private final JabRefPreferences jabRefPreferences;  UpdateTimestampListener(JabRefPreferences jabRefPreferences) { this.jabRefPreferences = jabRefPreferences; }  @Subscribe public void listen(EntryChangedEvent event) { if (jabRefPreferences.getTimestampPreferences().includeTimestamps()) { event.getBibEntry().setField(jabRefPreferences.getTimestampPreferences().getTimestampField(), jabRefPreferences.getTimestampPreferences().now()); } } }"


" public class CurrentThreadTaskExecutor implements TaskExecutor {  private static final Logger LOGGER = LoggerFactory.getLogger(CurrentThreadTaskExecutor.class);  /** * Executes the task on the current thread. The code is essentially taken from {@link * javafx.concurrent.Task.TaskCallable#call()}, but adapted to run sequentially. */ @Override public <V> Future<V> execute(BackgroundTask<V> task) { Runnable onRunning = task.getOnRunning(); if (onRunning != null) { onRunning.run(); } try { final V result = task.call(); Consumer<V> onSuccess = task.getOnSuccess(); if (onSuccess != null) { onSuccess.accept(result); } return CompletableFuture.completedFuture(result); } catch (Exception exception) { Consumer<Exception> onException = task.getOnException(); if (onException != null) { onException.accept(exception); } else { LOGGER.error("Unhandled exception", exception); } return new FailedFuture<>(exception); } }  @Override public <V> Future<V> execute(Task<V> task) { return task; }  @Override public <V> Future<?> schedule(BackgroundTask<V> task, long delay, TimeUnit unit) { return execute(task); }  @Override public void shutdown() { // Nothing to do here }  private class FailedFuture<T> implements Future<T> { private final Throwable exception;  FailedFuture(Throwable exception) { this.exception = exception; }  @Override public T get() throws ExecutionException { throw new ExecutionException(exception); }  @Override public T get(long timeout, TimeUnit unit) throws ExecutionException { return get(); }  @Override public boolean cancel(boolean mayInterruptIfRunning) { return false; }  @Override public boolean isCancelled() { return false; }  @Override public boolean isDone() { return true; } } }"

"private class DocumentViewerPage implements Cell<DocumentPageViewModel, StackPane> { private final ImageView imageView; private final StackPane imageHolder; private final Rectangle background; private DocumentPageViewModel page;  public DocumentViewerPage(DocumentPageViewModel initialPage) { page = initialPage;  imageView = new ImageView(); imageHolder = new StackPane(); imageHolder.getStyleClass().add("page");  // Show progress indicator ProgressIndicator progress = new ProgressIndicator(); progress.setMaxSize(50, 50);  // Set empty background and create proper rendering in background (for smoother loading) background = new Rectangle(getDesiredWidth(), getDesiredHeight()); background.setStyle("-fx-fill: WHITE"); //imageView.setImage(new WritableImage(getDesiredWidth(), getDesiredHeight())); BackgroundTask<Image> generateImage = BackgroundTask .wrap(() -> renderPage(initialPage)) .onSuccess(image -> { imageView.setImage(image); progress.setVisible(false); background.setVisible(false); }); taskExecutor.execute(generateImage);  imageHolder.getChildren().setAll(background, progress, imageView); }  private int getDesiredHeight() { return desiredPageDimension.getHeight(page.getAspectRatio()); }  private int getDesiredWidth() { return desiredPageDimension.getWidth(page.getAspectRatio()); }  @Override public StackPane getNode() { return imageHolder; }  @Override public boolean isReusable() { return true; }  @Override public void updateItem(DocumentPageViewModel page) { this.page = page;  // First hide old page and show background instead (recalculate size of background to make sure its correct) background.setWidth(getDesiredWidth()); background.setHeight(getDesiredHeight()); background.setVisible(true); imageView.setOpacity(0);  BackgroundTask<Image> generateImage = BackgroundTask .wrap(() -> renderPage(page)) .onSuccess(image -> { imageView.setImage(image);  // Fade new page in for smoother transition FadeTransition fadeIn = new FadeTransition(Duration.millis(100), imageView); fadeIn.setFromValue(0); fadeIn.setToValue(1); fadeIn.play(); }); taskExecutor.execute(generateImage); }  private Image renderPage(DocumentPageViewModel page) { return page.render(getDesiredWidth(), getDesiredHeight()); }  public int getPageNumber() { return page.getPageNumber(); }  public void updateSize() { background.setWidth(getDesiredWidth()); background.setHeight(getDesiredWidth()); updateItem(page); imageHolder.requestLayout(); } }"
"private static UndoableEdit massSetField(Collection<BibEntry> entries, Field field, String textToSet, boolean overwriteValues) { NamedCompound compoundEdit = new NamedCompound(Localization.lang("Set field")); for (BibEntry entry : entries) { Optional<String> oldValue = entry.getField(field); // If we are not allowed to overwrite values, check if there is a // nonempty // value already for this entry: if (!overwriteValues && (oldValue.isPresent()) && !oldValue.get().isEmpty()) { continue; } if (textToSet == null) { entry.clearField(field); } else { entry.setField(field, textToSet); } compoundEdit.addEdit(new UndoableFieldChange(entry, field, oldValue.orElse(null), textToSet)); } compoundEdit.end(); return compoundEdit; }"

"public class PreviewViewer extends ScrollPane implements InvalidationListener {  private static final Logger LOGGER = LoggerFactory.getLogger(PreviewViewer.class);  private static final String JS_HIGHLIGHT_FUNCTION = " <script type=\"text/javascript\">\r\n" + "        function highlight(text) {\r\n" + "            var innertxt = document.body.innerText;\r\n" + "            var response = innertxt.replace(new RegExp(text, 'gi'), str => `<span style='background-color:red'>${str}</span>`);\r\n" + "            document.body.innerHTML = response;\r\n" + "        }\r\n" + "    </script>";  private final ClipBoardManager clipBoardManager; private final DialogService dialogService;  private final TaskExecutor taskExecutor = Globals.TASK_EXECUTOR; private final WebView previewView; private PreviewLayout layout;  /** * The entry currently shown */ private Optional<BibEntry> entry = Optional.empty(); private Optional<Pattern> searchHighlightPattern = Optional.empty();  private BibDatabaseContext database; private boolean registered;  private ChangeListener<Optional<SearchQuery>> listener = (queryObservable, queryOldValue, queryNewValue) -> { searchHighlightPattern = queryNewValue.flatMap(SearchQuery::getPatternForWords); highlightSearchPattern(); };  /** * @param database Used for resolving strings and pdf directories for links. */ public PreviewViewer(BibDatabaseContext database, DialogService dialogService, StateManager stateManager) { this.database = Objects.requireNonNull(database); this.dialogService = dialogService; this.clipBoardManager = Globals.clipboardManager;  setFitToHeight(true); setFitToWidth(true); previewView = new WebView(); setContent(previewView); previewView.setContextMenuEnabled(false);  previewView.getEngine().getLoadWorker().stateProperty().addListener((observable, oldValue, newValue) -> {  if (newValue != Worker.State.SUCCEEDED) { return; } if (!registered) { stateManager.activeSearchQueryProperty().addListener(listener); registered = true; } highlightSearchPattern(); });  }  private void highlightSearchPattern() { if (searchHighlightPattern.isPresent()) { String pattern = searchHighlightPattern.get().pattern().replace("\\Q", "").replace("\\E", "");  previewView.getEngine().executeScript("highlight('" + pattern + "');"); } }  public void setLayout(PreviewLayout newLayout) { layout = newLayout; update(); }  public void setEntry(BibEntry newEntry) { // Remove update listener for old entry entry.ifPresent(oldEntry -> { for (Observable observable : oldEntry.getObservables()) { observable.removeListener(this); } });  entry = Optional.of(newEntry);  // Register for changes for (Observable observable : newEntry.getObservables()) { observable.addListener(this); } update();  }  private void update() { if (!entry.isPresent() || layout == null) { // Nothing to do return; }  ExporterFactory.entryNumber = 1; // Set entry number in case that is included in the preview layout.  BackgroundTask .wrap(() -> layout.generatePreview(entry.get(), database.getDatabase())) .onRunning(() -> setPreviewText("<i>" + Localization.lang("Processing %0", Localization.lang("Citation Style")) + ": " + layout.getName() + " ..." + "</i>")) .onSuccess(this::setPreviewText) .onFailure(exception -> { LOGGER.error("Error while generating citation style", exception); setPreviewText(Localization.lang("Error while generating citation style")); }) .executeWith(taskExecutor); }  private void setPreviewText(String text) { String myText = JS_HIGHLIGHT_FUNCTION + "<div id=\"content\"" + text + "</div>"; previewView.getEngine().setJavaScriptEnabled(true); previewView.getEngine().loadContent(myText);  this.setHvalue(0); }  public void print() { PrinterJob job = PrinterJob.createPrinterJob(); boolean proceed = dialogService.showPrintDialog(job); if (!proceed) { return; }  BackgroundTask .wrap(() -> { job.getJobSettings().setJobName(entry.flatMap(BibEntry::getCiteKeyOptional).orElse("NO ENTRY")); previewView.getEngine().print(job); job.endJob(); }) .onFailure(exception -> dialogService.showErrorDialogAndWait(Localization.lang("Could not print preview"), exception)) .executeWith(taskExecutor); }  public void copyPreviewToClipBoard() { StringBuilder previewStringContent = new StringBuilder(); Document document = previewView.getEngine().getDocument();  NodeList nodeList = document.getElementsByTagName("html");  //Nodelist does not implement iterable for (int i = 0; i < nodeList.getLength(); i++) { Element element = (Element) nodeList.item(i); previewStringContent.append(element.getTextContent()); }  ClipboardContent content = new ClipboardContent(); content.putString(previewStringContent.toString()); content.putHtml((String) previewView.getEngine().executeScript("document.documentElement.outerHTML"));  clipBoardManager.setContent(content); }  @Override public void invalidated(Observable observable) { update(); }  public String getSelectionHtmlContent() { return (String) previewView.getEngine().executeScript("window.getSelection().toString()"); } }"






"void setValues();"

"public class ValueTableCellFactory<S, T> implements Callback<TableColumn<S, T>, TableCell<S, T>> {  private Function<T, String> toText; private BiFunction<S, T, Node> toGraphic; private BiFunction<S, T, EventHandler<? super MouseEvent>> toOnMouseClickedEvent; private BiFunction<S, T, String> toTooltip; private Function<T, ContextMenu> contextMenuFactory; private BiFunction<S, T, ContextMenu> menuFactory;  public ValueTableCellFactory<S, T> withText(Function<T, String> toText) { this.toText = toText; return this; }  public ValueTableCellFactory<S, T> withGraphic(Function<T, Node> toGraphic) { this.toGraphic = (rowItem, value) -> toGraphic.apply(value); return this; }  public ValueTableCellFactory<S, T> withGraphic(BiFunction<S, T, Node> toGraphic) { this.toGraphic = toGraphic; return this; }  public ValueTableCellFactory<S, T> withTooltip(BiFunction<S, T, String> toTooltip) { this.toTooltip = toTooltip; return this; }  public ValueTableCellFactory<S, T> withTooltip(Function<T, String> toTooltip) { this.toTooltip = (rowItem, value) -> toTooltip.apply(value); return this; }  public ValueTableCellFactory<S, T> withOnMouseClickedEvent(BiFunction<S, T, EventHandler<? super MouseEvent>> toOnMouseClickedEvent) { this.toOnMouseClickedEvent = toOnMouseClickedEvent; return this; }  public ValueTableCellFactory<S, T> withOnMouseClickedEvent(Function<T, EventHandler<? super MouseEvent>> toOnMouseClickedEvent) { this.toOnMouseClickedEvent = (rowItem, value) -> toOnMouseClickedEvent.apply(value); return this; }  public ValueTableCellFactory<S, T> withContextMenu(Function<T, ContextMenu> contextMenuFactory) { this.contextMenuFactory = contextMenuFactory; return this; }  public ValueTableCellFactory<S, T> withMenu(BiFunction<S, T, ContextMenu> menuFactory) { this.menuFactory = menuFactory; return this; }  @Override public TableCell<S, T> call(TableColumn<S, T> param) {  return new TableCell<S, T>() {  @Override protected void updateItem(T item, boolean empty) { super.updateItem(item, empty);  if (empty || (item == null) || (getTableRow() == null) || (getTableRow().getItem() == null)) { setText(null); setGraphic(null); setOnMouseClicked(null); setTooltip(null); } else { S rowItem = ((TableRow<S>) getTableRow()).getItem();  if (toText != null) { setText(toText.apply(item)); } if (toGraphic != null) { setGraphic(toGraphic.apply(rowItem, item)); } if (toTooltip != null) { String tooltipText = toTooltip.apply(rowItem, item); if (StringUtil.isNotBlank(tooltipText)) { setTooltip(new Tooltip(tooltipText)); } }  if (contextMenuFactory != null) { // We only create the context menu when really necessary setOnContextMenuRequested(event -> { if (!isEmpty()) { setContextMenu(contextMenuFactory.apply(item)); getContextMenu().show(this, event.getScreenX(), event.getScreenY()); } event.consume(); }); }  setOnMouseClicked(event -> { if (toOnMouseClickedEvent != null) { toOnMouseClickedEvent.apply(rowItem, item).handle(event); }  if ((menuFactory != null) && !event.isConsumed()) { if (event.getButton() == MouseButton.PRIMARY) { ContextMenu menu = menuFactory.apply(rowItem, item); if (menu != null) { menu.show(this, event.getScreenX(), event.getScreenY()); event.consume(); } } } }); } } }; }  public void install(TableColumn<S, T> column) { column.setCellFactory(this); } }"

"private final GroupTreeNode m_groupRoot;"
"public final class MappedList<A, B> extends TransformationList<A, B> {  private final Function<B, A> mapper; private final List<A> backingList;  public MappedList(ObservableList<? extends B> sourceList, Function<B, A> mapper) { super(sourceList); this.mapper = mapper; this.backingList = new ArrayList<>(sourceList.size()); sourceList.stream().map(mapper::apply).forEach(backingList::add); }  @Override protected void sourceChanged(ListChangeListener.Change<? extends B> change) { beginChange(); while (change.next()) { if (change.wasPermutated()) { int from = change.getFrom(); int to = change.getTo();  // get permutation array int[] permutation = new int[to - from]; for (int i = 0; i < to - from; i++) { permutation[i] = change.getPermutation(i); }  // perform permutation Object[] permutedPart = new Object[to - from]; for (int i = from; i < to; i++) { permutedPart[permutation[i]] = backingList.get(i); }  // update backingList for (int i = 0; i < to; i++) { backingList.set(i + from, (A) permutedPart[i]); } nextPermutation(from, to, permutation); } else if (change.wasUpdated()) { backingList.set(change.getFrom(), mapper.apply(getSource().get(change.getFrom()))); nextUpdate(change.getFrom()); } else { if (change.wasRemoved()) { int removePosition = change.getFrom(); List<A> removed = new ArrayList<>(change.getRemovedSize()); for (int i = 0; i < change.getRemovedSize(); i++) { removed.add(backingList.remove(removePosition)); } nextRemove(change.getFrom(), removed); } if (change.wasAdded()) { int addStart = change.getFrom(); int addEnd = change.getTo(); for (int i = addStart; i < addEnd; i++) { backingList.add(i, mapper.apply(change.getList().get(i))); } nextAdd(addStart, addEnd); } } } endChange(); }  @Override public int getSourceIndex(int index) { return index; }  @Override public int getViewIndex(int index) { return index; }  @Override public A get(int index) { return backingList.get(index); }  @Override public int size() { return backingList.size(); } }"






"Path getApplicationDirectory();"
"public class ConnectToSharedDatabaseCommand extends SimpleCommand {  private final JabRefFrame jabRefFrame;  public ConnectToSharedDatabaseCommand(JabRefFrame jabRefFrame) { this.jabRefFrame = jabRefFrame; }  @Override public void execute() { new SharedDatabaseLoginDialogView(jabRefFrame).showAndWait(); } }"

"void addBuiltInLists() { BackgroundTask .wrap(JournalAbbreviationLoader::getBuiltInAbbreviations) .onRunning(() -> isLoadingBuiltIn.setValue(true)) .onSuccess(result -> { isLoadingBuiltIn.setValue(false); addList(Localization.lang("JabRef built in list"), result); selectLastJournalFile(); }) .onFailure(dialogService::showErrorDialogAndWait) .executeWith(taskExecutor);  BackgroundTask .wrap(() -> { if (abbreviationsPreferences.useIEEEAbbreviations()) { return JournalAbbreviationLoader.getOfficialIEEEAbbreviations(); } else { return JournalAbbreviationLoader.getStandardIEEEAbbreviations(); } }) .onRunning(() -> isLoadingIeee.setValue(true)) .onSuccess(result -> { isLoadingIeee.setValue(false); addList(Localization.lang("IEEE built in list"), result); }) .onFailure(dialogService::showErrorDialogAndWait) .executeWith(taskExecutor); }"




"public class UnknownExternalFileType implements ExternalFileType {  private final String name; private final String extension;  public UnknownExternalFileType(String name) { this(name, ""); }  public UnknownExternalFileType(String name, String extension) { this.name = name; this.extension = extension; }  @Override public String getName() { return name; }  @Override public String getExtension() { return extension; }  @Override public String getMimeType() { return ""; }  @Override public String getOpenWithApplication() { return ""; }  @Override public JabRefIcon getIcon() { return IconTheme.JabRefIcons.FILE; } }"

"public static TextFormatter<String> getIntegerTextFormatter() { UnaryOperator<TextFormatter.Change> filter = change -> { String text = change.getText();  if (text.matches("[0-9]*")) { return change; }  return null; }; return new TextFormatter<>(filter); }"
"public static String formatName(final String nameToFormat) { if (nameToFormat == null) { return null; }  // Read name format options: final boolean namesNatbib = Globals.prefs.getBoolean(JabRefPreferences.NAMES_NATBIB); //MK: final boolean namesLastOnly = Globals.prefs.getBoolean(JabRefPreferences.NAMES_LAST_ONLY); final boolean namesAsIs = Globals.prefs.getBoolean(JabRefPreferences.NAMES_AS_IS); final boolean namesFf = Globals.prefs.getBoolean(JabRefPreferences.NAMES_FIRST_LAST);  final boolean abbrAuthorNames = Globals.prefs.getBoolean(JabRefPreferences.ABBR_AUTHOR_NAMES); //MK:  if (namesAsIs) { return nameToFormat; } else if (namesNatbib) { return AuthorList.fixAuthorNatbib(nameToFormat); } else if (namesLastOnly) { return AuthorList.fixAuthorLastNameOnlyCommas(nameToFormat, false); } else if (namesFf) { return AuthorList.fixAuthorFirstNameFirstCommas(nameToFormat, abbrAuthorNames, false); }  // None of namesAsIs, namesNatbib, namesAsIs, namesFf return AuthorList.fixAuthorLastNameFirstCommas(nameToFormat, abbrAuthorNames, false); }"



"public class BackupUIManager {  private BackupUIManager() {  }  public static void showRestoreBackupDialog(DialogService dialogService, Path originalPath) { String content = new StringBuilder() .append(Localization.lang("A backup file for '%0' was found.", originalPath.getFileName().toString())) .append("\n") .append(Localization.lang("This could indicate that JabRef did not shut down cleanly last time the file was used.")) .append("\n\n") .append(Localization.lang("Do you want to recover the library from the backup file?")) .toString();  boolean restoreClicked = DefaultTaskExecutor.runInJavaFXThread(()-> dialogService.showConfirmationDialogAndWait( Localization.lang("Backup found"), content, Localization.lang("Restore from backup"), Localization.lang("Ignore backup")));  if (restoreClicked) { BackupManager.restoreBackup(originalPath); }  } }"


"class NoDocumentException extends Exception {  public NoDocumentException(String message) { super(message); }  }"


" private boolean isExistURLorDOI(List<BibEntry> selectEntryList) { if (selectEntryList.size() == 1) { BibEntry selectedEntry = selectEntryList.get(0); return (selectedEntry.getField(StandardField.URL).isPresent() || selectedEntry.getField(StandardField.DOI).isPresent()); } return false; }"
"public class UiThreadStringProperty extends StringProperty {  private final StringProperty delegate;  public UiThreadStringProperty(StringProperty delegate) { this.delegate = delegate; }  @Override public void bind(ObservableValue<? extends String> observable) { delegate.bind(observable); }  @Override public void unbind() { delegate.unbind(); }  @Override public boolean isBound() { return delegate.isBound(); }  @Override public Object getBean() { return delegate.getBean(); }  @Override public String getName() { return delegate.getName(); }  @Override public String get() { return delegate.get(); }  @Override public void set(String value) { delegate.set(value); }  @Override public void addListener(ChangeListener<? super String> listener) { delegate.addListener(new UiThreadChangeListener(listener)); }  @Override public void removeListener(ChangeListener<? super String> listener) { delegate.removeListener(listener); }  @Override public void addListener(InvalidationListener listener) { delegate.addListener(new UiThreadInvalidationListener(listener)); }  @Override public void removeListener(InvalidationListener listener) { delegate.removeListener(listener); } }"

"public class ManageProtectedTermsDialog extends BaseDialog<Void> {  @FXML private TableView<ProtectedTermsList> filesTable; @FXML private TableColumn<ProtectedTermsList, Boolean> filesTableEnabledColumn; @FXML private TableColumn<ProtectedTermsList, String> filesTableDescriptionColumn; @FXML private TableColumn<ProtectedTermsList, String> filesTableFileColumn; @FXML private TableColumn<ProtectedTermsList, Boolean> filesTableEditColumn; @FXML private TableColumn<ProtectedTermsList, Boolean> filesTableDeleteColumn;  @Inject private ProtectedTermsLoader termsLoader; @Inject private DialogService dialogService; @Inject private PreferencesService preferences; private ManageProtectedTermsViewModel viewModel;  public ManageProtectedTermsDialog() { this.setTitle(Localization.lang("Manage protected terms files"));  ViewLoader.view(this) .load() .setAsDialogPane(this);  setResultConverter(button -> { if (button == ButtonType.APPLY) { viewModel.save(); } return null; }); }  @FXML public void initialize() { viewModel = new ManageProtectedTermsViewModel(termsLoader, dialogService, preferences);  filesTable.setItems(viewModel.getTermsFiles()); new ViewModelTableRowFactory<ProtectedTermsList>() .withContextMenu(this::createContextMenu) .install(filesTable); filesTableEnabledColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().isEnabled())); filesTableEnabledColumn.setCellFactory(CheckBoxTableCell.forTableColumn(filesTableEnabledColumn)); filesTableDescriptionColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().getDescription())); filesTableFileColumn.setCellValueFactory(data -> { ProtectedTermsList list = data.getValue(); if (list.isInternalList()) { return BindingsHelper.constantOf(Localization.lang("Internal list")); } else { return BindingsHelper.constantOf(data.getValue().getLocation()); } }); filesTableEditColumn.setCellValueFactory(data -> BindingsHelper.constantOf(true)); filesTableDeleteColumn.setCellValueFactory(data -> BindingsHelper.constantOf(true));  new ValueTableCellFactory<ProtectedTermsList, Boolean>() .withGraphic(none -> IconTheme.JabRefIcons.EDIT.getGraphicNode()) .withOnMouseClickedEvent((file, none) -> event -> viewModel.edit(file)) .install(filesTableEditColumn); new ValueTableCellFactory<ProtectedTermsList, Boolean>() .withGraphic(none -> IconTheme.JabRefIcons.REMOVE.getGraphicNode()) .withTooltip(none -> Localization.lang("Remove protected terms file")) .withOnMouseClickedEvent((file, none) -> event -> viewModel.removeFile(file)) .install(filesTableDeleteColumn); }  private ContextMenu createContextMenu(ProtectedTermsList file) { MenuItem edit = new MenuItem(Localization.lang("Edit")); edit.setOnAction(event -> viewModel.edit(file)); MenuItem show = new MenuItem(Localization.lang("View")); show.setOnAction(event -> viewModel.displayContent(file)); MenuItem remove = new MenuItem(Localization.lang("Remove")); remove.setOnAction(event -> viewModel.removeFile(file)); MenuItem reload = new MenuItem(Localization.lang("Reload")); reload.setOnAction(event -> viewModel.reloadFile(file));  // Enable/disable context menu items if (file.isInternalList()) { edit.setDisable(true); show.setDisable(false); remove.setDisable(true); reload.setDisable(true); } else { edit.setDisable(false); show.setDisable(false); remove.setDisable(false); reload.setDisable(false); }  final ContextMenu contextMenu = new ContextMenu(); contextMenu.getItems().addAll(edit, show, remove, reload); return contextMenu; }  @FXML private void addFile() { viewModel.addFile(); }  @FXML private void createNewFile() { viewModel.createNewFile(); } }"







"public void activeReferenceChanged(ReferenceViewModel reference) { if (reference == null) { citationList.clear(); } else { citationList.setAll(reference.getCitationList()); } }"




"public static void openBrowser(String url) throws IOException { Optional<ExternalFileType> fileType = ExternalFileTypes.getInstance().getExternalFileTypeByExt("html"); openExternalFilePlatformIndependent(fileType, url); }"
"public MergeEntries(BibEntry entryLeft, BibEntry entryRight, BibDatabaseMode type) { leftEntry = entryLeft; rightEntry = entryRight; initialize(); }"



"public String getDisplayText() { if (path.toFile().isDirectory()) { return String.format("%s (%s %s)", path.getFileName(), fileCount, fileCount == 1 ? Localization.lang("file") : Localization.lang("files")); } return path.getFileName().toString(); }"

"private void setupKeyBindings() { this.addEventHandler(KeyEvent.KEY_PRESSED, event -> { Optional<KeyBinding> keyBinding = entryEditorPreferences.getKeyBindings().mapToKeyBinding(event); if (keyBinding.isPresent()) { switch (keyBinding.get()) { case ENTRY_EDITOR_NEXT_PANEL: case ENTRY_EDITOR_NEXT_PANEL_2: tabbed.getSelectionModel().selectNext(); event.consume(); break; case ENTRY_EDITOR_PREVIOUS_PANEL: case ENTRY_EDITOR_PREVIOUS_PANEL_2: tabbed.getSelectionModel().selectPrevious(); event.consume(); break; case ENTRY_EDITOR_NEXT_ENTRY: panel.selectNextEntry(); event.consume(); break; case ENTRY_EDITOR_PREVIOUS_ENTRY: panel.selectPreviousEntry(); event.consume(); break; case HELP: HelpAction.openHelpPage(HelpFile.ENTRY_EDITOR); event.consume(); break; case CLOSE: case CLOSE_ENTRY: close(); event.consume(); break; default: // Pass other keys to parent } } }); }"
"public static XMultiServiceFactory createSimpleServiceManager() throws Exception { return UnoRuntime.queryInterface(XMultiServiceFactory.class, createInitialComponentContext((Map<String, Object>) null).getServiceManager()); }"







"private void applyPreferences() { Optional<String> sharedDatabaseType = prefs.getType(); Optional<String> sharedDatabaseHost = prefs.getHost(); Optional<String> sharedDatabasePort = prefs.getPort(); Optional<String> sharedDatabaseName = prefs.getName(); Optional<String> sharedDatabaseUser = prefs.getUser(); Optional<String> sharedDatabasePassword = prefs.getPassword(); boolean sharedDatabaseRememberPassword = prefs.getRememberPassword(); Optional<String> sharedDatabaseKeystoreFile = prefs.getKeyStoreFile();  if (sharedDatabaseType.isPresent()) { Optional<DBMSType> dbmsType = DBMSType.fromString(sharedDatabaseType.get()); dbmsType.ifPresent(selectedDBMSType::set); }  sharedDatabaseHost.ifPresent(host::set); sharedDatabasePort.ifPresent(port::set); sharedDatabaseName.ifPresent(database::set); sharedDatabaseUser.ifPresent(user::set); sharedDatabaseKeystoreFile.ifPresent(keystore::set); useSSL.setValue(prefs.isUseSSL());  if (sharedDatabasePassword.isPresent() && sharedDatabaseUser.isPresent()) { try { password.setValue(new Password(sharedDatabasePassword.get().toCharArray(), sharedDatabaseUser.get()).decrypt()); } catch (GeneralSecurityException | UnsupportedEncodingException e) { LOGGER.error("Could not read the password due to decryption problems.", e); } }  rememberPassword.set(sharedDatabaseRememberPassword); }"
"class CreationException extends Exception {  public CreationException(String message) { super(message); }  }"

"public void setProgressBarIndeterminate(final boolean value) { progressBar.setProgress(ProgressBar.INDETERMINATE_PROGRESS); }"





"public void setIconName(String name) { this.iconName = name; }"

"public AbbreviationsFileViewModel(List<AbbreviationViewModel> abbreviations, String name) { this.abbreviations.addAll(abbreviations); this.name = name; this.path = Optional.empty(); this.isBuiltInList = new SimpleBooleanProperty(true); }"



"public static void openExternalViewer(BibDatabaseContext databaseContext, String initialLink, Field initialField) throws IOException { String link = initialLink; Field field = initialField; if (StandardField.PS.equals(field) || StandardField.PDF.equals(field)) { // Find the default directory for this field type: List<String> dir = databaseContext.getFileDirectories(field, Globals.prefs.getFilePreferences()); Optional<Path> file = FileHelper.expandFilename(link, dir); // Check that the file exists: if (!file.isPresent() || !Files.exists(file.get())) { throw new IOException("File not found (" + field + "): '" + link + "'."); } link = file.get().toAbsolutePath().toString(); // Use the correct viewer even if pdf and ps are mixed up: String[] split = file.get().getFileName().toString().split("\\."); if (split.length >= 2) { if ("pdf".equalsIgnoreCase(split[split.length - 1])) { field = StandardField.PDF; } else if ("ps".equalsIgnoreCase(split[split.length - 1]) || ((split.length >= 3) && "ps".equalsIgnoreCase(split[split.length - 2]))) { field = StandardField.PS; } } } else if (StandardField.DOI.equals(field)) { openDoi(link); return; } else if (StandardField.EPRINT.equals(field)) { link = Eprint.build(link).map(Eprint::getURIAsASCIIString).orElse(link); // should be opened in browser field = StandardField.URL; } if (StandardField.URL.equals(field)) { openBrowser(link); } else if (StandardField.PS.equals(field)) { try { NATIVE_DESKTOP.openFile(link, StandardField.PS.getName()); } catch (IOException e) { LOGGER.error("An error occurred on the command: " + link, e); } } else if (StandardField.PDF.equals(field)) { try { NATIVE_DESKTOP.openFile(link, StandardField.PDF.getName()); } catch (IOException e) { LOGGER.error("An error occurred on the command: " + link, e); } } else { LOGGER.info("Message: currently only PDF, PS and HTML files can be opened by double clicking");}}"

"private void populateTable() { KeyBindingViewModel root = new KeyBindingViewModel(keyBindingRepository, KeyBindingCategory.FILE); for (KeyBindingCategory category : KeyBindingCategory.values()) { KeyBindingViewModel categoryItem = new KeyBindingViewModel(keyBindingRepository, category); keyBindingRepository.getKeyBindings().forEach((keyBinding, bind) -> { if (keyBinding.getCategory() == category) { KeyBindingViewModel keyBindViewModel = new KeyBindingViewModel(keyBindingRepository, keyBinding, bind); categoryItem.getChildren().add(keyBindViewModel); } }); root.getChildren().add(categoryItem); } rootKeyBinding.set(root); }"



"public enum Actions {  ABBREVIATE_ISO, ABBREVIATE_MEDLINE, ADD_FILE_LINK, CLEANUP, COPY, COPY_CITATION_ASCII_DOC, COPY_CITATION_XSLFO, COPY_CITATION_HTML, COPY_CITATION_RTF, COPY_CITATION_TEXT, COPY_KEY, COPY_CITE_KEY, COPY_KEY_AND_TITLE, COPY_KEY_AND_LINK, COPY_TITLE, CUT, DELETE, DOWNLOAD_FULL_TEXT, EDIT, EDIT_PREAMBLE, EDIT_STRINGS, EXPORT_TO_CLIPBOARD, MAKE_KEY, MANAGE_SELECTORS, MERGE_DATABASE, MERGE_ENTRIES, MERGE_WITH_FETCHED_ENTRY, NEXT_PREVIEW_STYLE, OPEN_CONSOLE, OPEN_EXTERNAL_FILE, OPEN_FOLDER, OPEN_URL, PASTE, PREVIOUS_PREVIEW_STYLE, PULL_CHANGES_FROM_SHARED_DATABASE, REDO, REPLACE_ALL, SAVE, SAVE_AS, SAVE_SELECTED_AS_PLAIN, SELECT_ALL, SEND_AS_EMAIL, TOGGLE_GROUPS, UNABBREVIATE, UNDO, WRITE_XMP, PRINT_PREVIEW, TOGGLE_PRINTED, CLEAR_PRIORITY, SET_PRIORITY_1, SET_PRIORITY_2, SET_PRIORITY_3, TOGGLE_QUALITY_ASSURED, CLEAR_RANK, SET_RANK_1, SET_RANK_2, SET_RANK_3, SET_RANK_4, SET_RANK_5, CLEAR_READ_STATUS, SET_READ_STATUS_TO_READ, SET_READ_STATUS_TO_SKIMMED, TOGGLE_RELEVANCE }"



"public abstract void makeChange(BibDatabaseContext database, NamedCompound undoEdit);"



"public static void openBrowserShowPopup(String url) { try { openBrowser(url); } catch (IOException exception) { Globals.clipboardManager.setContent(url); LOGGER.error("Could not open browser", exception); String couldNotOpenBrowser = Localization.lang("Could not open browser."); String openManually = Localization.lang("Please open %0 manually.", url); String copiedToClipboard = Localization.lang("The link has been copied to the clipboard."); JabRefGUI.getMainFrame().getDialogService().notify(couldNotOpenBrowser); JabRefGUI.getMainFrame().getDialogService().showErrorDialogAndWait(couldNotOpenBrowser, couldNotOpenBrowser + "\n" + openManually + "\n" + copiedToClipboard); } }"
"public BackgroundTask<V> onFinished(Runnable onFinished) { this.onFinished = onFinished; return this; }"
"public class TagBar<T> extends HBox {  private final ListProperty<T> tags; private StringConverter<T> stringConverter; @FXML private TextField inputTextField; @FXML private HBox tagList; private BiConsumer<T, MouseEvent> onTagClicked;  public TagBar() { tags = new SimpleListProperty<>(FXCollections.observableArrayList()); tags.addListener(this::onTagsChanged);  // Load FXML ViewLoader.view(this) .root(this) .load(); getStylesheets().add(0, TagBar.class.getResource("TagBar.css").toExternalForm()); }  public TextField getInputTextField() { return inputTextField; }  public ObservableList<T> getTags() { return tags.get(); }  public void setTags(Collection<T> newTags) { this.tags.setAll(tags); }  public ListProperty<T> tagsProperty() { return tags; }  private void onTagsChanged(ListChangeListener.Change<? extends T> change) { while (change.next()) { if (change.wasRemoved()) { tagList.getChildren().subList(change.getFrom(), change.getFrom() + change.getRemovedSize()).clear(); } else if (change.wasAdded()) { tagList.getChildren().addAll(change.getFrom(), change.getAddedSubList().stream().map(this::createTag).collect(Collectors.toList())); } } }  private Tag<T> createTag(T item) { Tag<T> tag = new Tag<>(stringConverter::toString); tag.setOnTagRemoved(tags::remove); tag.setValue(item); if (onTagClicked != null) { tag.setOnMouseClicked(event -> onTagClicked.accept(item, event)); } return tag; }  @FXML private void addTextAsNewTag(ActionEvent event) { String inputText = inputTextField.getText(); if (StringUtil.isNotBlank(inputText)) { T newTag = stringConverter.fromString(inputText); if ((newTag != null) && !tags.contains(newTag)) { tags.add(newTag); inputTextField.clear(); } } }  public void setStringConverter(StringConverter<T> stringConverter) { this.stringConverter = stringConverter; }  public void setOnTagClicked(BiConsumer<T, MouseEvent> onTagClicked) { this.onTagClicked = onTagClicked; } }"
"private void saveExternalFilesList() { List<String> extFiles = new ArrayList<>(); journalFiles.forEach(file -> { if (!file.isBuiltInListProperty().get()) { file.getAbsolutePath().ifPresent(path -> extFiles.add(path.toAbsolutePath().toString())); } }); abbreviationsPreferences.setExternalJournalLists(extFiles); }"




"public BasePanel getCurrentBasePanel() { if ((tabbedPane == null) || (tabbedPane.getSelectionModel().getSelectedItem() == null)) { return null; } return getBasePanel(tabbedPane.getSelectionModel().getSelectedItem()); }"

"public class IconValidationDecorator extends GraphicValidationDecoration {  private final Pos position;  public IconValidationDecorator() { this(Pos.BOTTOM_LEFT); }  public IconValidationDecorator(Pos position) { this.position = position; }  @Override protected Node createErrorNode() { return IconTheme.JabRefIcons.ERROR.getGraphicNode(); }  @Override protected Node createWarningNode() { return IconTheme.JabRefIcons.WARNING.getGraphicNode(); }  @Override public Node createDecorationNode(ValidationMessage message) { Node graphic = Severity.ERROR == message.getSeverity() ? createErrorNode() : createWarningNode(); graphic.getStyleClass().add(Severity.ERROR == message.getSeverity() ? "error-icon" : "warning-icon"); Label label = new Label(); label.setGraphic(graphic); label.setTooltip(createTooltip(message)); label.setAlignment(position); return label; }  @Override protected Tooltip createTooltip(ValidationMessage message) { Tooltip tooltip = new Tooltip(message.getText()); tooltip.getStyleClass().add(Severity.ERROR == message.getSeverity() ? "tooltip-error" : "tooltip-warning"); return tooltip; }  @Override protected Collection<Decoration> createValidationDecorations(ValidationMessage message) { return Arrays.asList(new GraphicDecoration(createDecorationNode(message), position)); } }"
"public abstract Node description();"






"public static void showParserResultWarningDialog(final ParserResult parserResult, final JabRefFrame jabRefFrame) { Objects.requireNonNull(parserResult); Objects.requireNonNull(jabRefFrame); showParserResultWarningDialog(parserResult, jabRefFrame, -1); }"
"@SuppressWarnings("unchecked") private <T> AutoCompletePopup<T> getPopup(AutoCompletionBinding<T> autoCompletionBinding) { try { // TODO: reflective access, should be removed Field privatePopup = AutoCompletionBinding.class.getDeclaredField("autoCompletionPopup"); privatePopup.setAccessible(true); return (AutoCompletePopup<T>) privatePopup.get(autoCompletionBinding); } catch (IllegalAccessException | NoSuchFieldException e) { LOGGER.error("Could not get access to auto completion popup", e); return new AutoCompletePopup<>(); }}"



"public class Tag<T> extends HBox {  private ObjectProperty<T> value; private Consumer<T> tagRemovedConsumer; @FXML private Label text;  public Tag(Function<T, String> toString) { Objects.requireNonNull(toString);  ViewLoader.view(this) .root(this) .load();  value = new SimpleObjectProperty<>(); text.textProperty().bind(EasyBind.map(value, toString)); }  public Tag(Function<T, String> toString, T value) { this(toString); setValue(value); }  public T getValue() { return value.get(); }  public void setValue(T value) { this.value.set(value); }  public ObjectProperty<T> valueProperty() { return value; }  @FXML private void removeButtonClicked(ActionEvent event) { if (tagRemovedConsumer != null) { tagRemovedConsumer.accept(value.get()); } }  public final void setOnTagRemoved(Consumer<T> tagRemovedConsumer) { this.tagRemovedConsumer = tagRemovedConsumer; } }"


"public class CopyBibTeXKeyAndLinkAction implements BaseAction {  private final MainTable mainTable; private final ClipBoardManager clipboardManager;  public CopyBibTeXKeyAndLinkAction(MainTable mainTable, ClipBoardManager clipboardManager) { this.mainTable = mainTable; this.clipboardManager = clipboardManager; }  @Override public void action() throws Exception { List<BibEntry> entries = mainTable.getSelectedEntries(); if (!entries.isEmpty()) { StringBuilder sb = new StringBuilder();  List<BibEntry> entriesWithKey = entries.stream().filter(BibEntry::hasCiteKey).collect(Collectors.toList());  if (entriesWithKey.isEmpty()) { JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("None of the selected entries have BibTeX keys.")); return; }  for (BibEntry entry : entriesWithKey) { String key = entry.getCiteKeyOptional().get(); String url = entry.getField(StandardField.URL).orElse(""); sb.append(url.isEmpty() ? key : String.format("<a href=\"%s\">%s</a>", url, key)); sb.append(OS.NEWLINE); } final String keyAndLink = sb.toString(); DefaultTaskExecutor.runInJavaFXThread(() -> clipboardManager.setHtmlContent(keyAndLink));  int copied = entriesWithKey.size(); int toCopy = entries.size(); if (copied == toCopy) { // All entries had keys. JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Copied") + " '" + JabRefDialogService.shortenDialogMessage(keyAndLink) + "'."); } else { JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Warning: %0 out of %1 entries have undefined BibTeX key.", Long.toString(toCopy - copied), Integer.toString(toCopy))); } } } }"


"private String getLogMessagesAsString(List<LogEventViewModel> messages) { return messages.stream() .map(LogEventViewModel::getDetailedText) .collect(Collectors.joining(OS.NEWLINE)); }"
"public <T> BackgroundTask<T> then(Function<V, BackgroundTask<T>> nextTaskFactory) { return new BackgroundTask<T>() { @Override protected T call() throws Exception { V result = BackgroundTask.this.call(); BackgroundTask<T> nextTask = nextTaskFactory.apply(result); EasyBind.subscribe(nextTask.progressProperty(), this::updateProgress); return nextTask.call(); } }; }"
"public void addNewSubgroup(GroupNodeViewModel parent) { Optional<AbstractGroup> newGroup = dialogService.showCustomDialogAndWait(new GroupDialog(dialogService)); newGroup.ifPresent(group -> { parent.addSubgroup(group);  // TODO: Add undo //UndoableAddOrRemoveGroup undo = new UndoableAddOrRemoveGroup(parent, new GroupTreeNodeViewModel(newGroupNode), UndoableAddOrRemoveGroup.ADD_NODE); //panel.getUndoManager().addEdit(undo);  // TODO: Expand parent to make new group visible //parent.expand();  dialogService.notify(Localization.lang("Added group \"%0\".", group.getName())); writeGroupChangesToMetaData(); }); }"



"public AppearancePrefsTab(DialogService dialogService, JabRefPreferences prefs) { this.dialogService = dialogService; this.prefs = prefs; builder.setVgap(8);  overrideFonts = new CheckBox(Localization.lang("Override default font settings")); fontSize = new TextField(); fontSize.setTextFormatter(ControlHelper.getIntegerTextFormatter()); Label fontSizeLabel = new Label(Localization.lang("Font size:")); fontTweaksLAF = new CheckBox(Localization.lang("Tweak font rendering for entry editor on Linux"));  ToggleGroup themeGroup = new ToggleGroup(); lightTheme = new RadioButton("Light theme"); lightTheme.setToggleGroup(themeGroup); darkTheme = new RadioButton("Dark theme"); darkTheme.setToggleGroup(themeGroup);  String cssFileName = prefs.get(JabRefPreferences.FX_THEME); if (StringUtil.isBlank(cssFileName) || ThemeLoader.MAIN_CSS.equalsIgnoreCase(cssFileName)) { lightTheme.setSelected(true); } else if (ThemeLoader.DARK_CSS.equals(cssFileName)) { darkTheme.setSelected(true); }  // Font configuration HBox fontBox = new HBox(); fontBox.setSpacing(10); fontBox.setAlignment(Pos.CENTER_LEFT); fontBox.getChildren().setAll(overrideFonts, fontSizeLabel, fontSize); builder.add(fontBox, 1, 2);  // Theme configuration HBox themeBox = new HBox(); themeBox.setSpacing(10); themeBox.setAlignment(Pos.CENTER_LEFT); themeBox.getChildren().setAll(lightTheme, darkTheme); builder.add(themeBox, 1, 4); }"

"public void clearSuggestions() { synchronized (possibleSuggestionsLock) { possibleSuggestions.clear(); } }"

"public void saveEverythingAndUpdateAutoCompleter() { BackgroundTask.wrap(() -> { saveExternalFilesList();  if (shouldWriteLists) { saveJournalAbbreviationFiles(); shouldWriteLists = false; }  // Update journal abbreviation loader journalAbbreviationLoader.update(abbreviationsPreferences);  preferences.storeJournalAbbreviationPreferences(abbreviationsPreferences); }).executeWith(taskExecutor); }"

"private static BibEntry bestFit(BibEntry targetEntry, List<BibEntry> entries) { return entries.stream() .max(Comparator.comparingDouble(candidate -> DuplicateCheck.compareEntriesStrictly(targetEntry, candidate))) .orElse(null); }"



"protected String getCommandName() { return null; }"

"protected boolean isMatch(T suggestion, ISuggestionRequest request) { String userTextLower = request.getUserText().toLowerCase(); String suggestionStr = suggestion.toString().toLowerCase(); return suggestionStr.contains(userTextLower); }"












"public void toggle(SidePaneType type) { if (isComponentVisible(type)) { hide(type); } else { show(type); } }"
"@FunctionalInterface public interface PasteActionHandler { void handle(); }"



"public Optional<ExternalFileType> getExternalFileTypeByName(String name) { Optional<ExternalFileType> externalFileType = externalFileTypes.stream().filter(type -> type.getExtension().equals(name)).findFirst(); if (externalFileType.isPresent()) { return externalFileType; } // Return an instance that signifies an unknown file type: return Optional.of(new UnknownExternalFileType(name)); }"

"public class NewSubLibraryAction extends SimpleCommand {  private final JabRefFrame jabRefFrame;  public NewSubLibraryAction(JabRefFrame jabRefFrame, StateManager stateManager) { this.jabRefFrame = jabRefFrame;  this.executable.bind(needsDatabase(stateManager)); }  @Override public void execute() { FromAuxDialog dialog = new FromAuxDialog(jabRefFrame); dialog.showAndWait(); } }"
"private void startSearch() { Path directory = getSearchDirectory(); FileFilter selectedFileFilter = FileFilterConverter.toFileFilter(comboBoxFileTypeSelection.getValue());  findUnlinkedFilesTask = new UnlinkedFilesCrawler(directory, selectedFileFilter, databaseContext) .onRunning(() -> { panelSearchProgress.setVisible(true); buttonScan.setDisable(true); tree.setRoot(null); }) .onFinished(() -> { panelSearchProgress.setVisible(false); buttonScan.setDisable(false); }) .onSuccess(root -> { tree.setRoot(root); root.setSelected(true); root.setExpanded(true);  buttonApply.setDisable(false); buttonExport.setDisable(false); buttonScan.setDefaultButton(false); }); findUnlinkedFilesTask.executeWith(Globals.TASK_EXECUTOR); }"
"public boolean isGeneratedNameSameAsOriginal() { Path file = Paths.get(this.linkedFile.getLink()); String currentFileName = file.getFileName().toString(); String suggestedFileName = this.linkedFileHandler.getSuggestedFileName();  return currentFileName.equals(suggestedFileName); }"

"public class JabRefExecutorService {  public static final JabRefExecutorService INSTANCE = new JabRefExecutorService(); private static final Logger LOGGER = LoggerFactory.getLogger(JabRefExecutorService.class); private final ExecutorService executorService = Executors.newCachedThreadPool(r -> { Thread thread = new Thread(r); thread.setName("JabRef CachedThreadPool"); thread.setUncaughtExceptionHandler(new FallbackExceptionHandler()); return thread;  }); private final ExecutorService lowPriorityExecutorService = Executors.newCachedThreadPool(r -> { Thread thread = new Thread(r); thread.setName("JabRef LowPriorityCachedThreadPool"); thread.setUncaughtExceptionHandler(new FallbackExceptionHandler()); return thread; }); private final Timer timer = new Timer("timer", true); private Thread remoteThread;  private JabRefExecutorService() { }  public void execute(Runnable command) { Objects.requireNonNull(command); executorService.execute(command); }  public void executeAndWait(Runnable command) { Objects.requireNonNull(command); Future<?> future = executorService.submit(command); try { future.get(); } catch (InterruptedException ignored) { // Ignored } catch (ExecutionException e) { LOGGER.error("Problem executing command", e); } }  /** * Executes a callable task that provides a return value after the calculation is done. * * @param command The task to execute. * @return A Future object that provides the returning value. */ public <T> Future<T> execute(Callable<T> command) { Objects.requireNonNull(command); return executorService.submit(command); }  /** * Executes a collection of callable tasks and returns a List of the resulting Future objects after the calculation is done. * * @param tasks The tasks to execute * @return A List of Future objects that provide the returning values. */ public <T> List<Future<T>> executeAll(Collection<Callable<T>> tasks) { Objects.requireNonNull(tasks); try { return executorService.invokeAll(tasks); } catch (InterruptedException exception) { // Ignored return Collections.emptyList(); } }  public <T> List<Future<T>> executeAll(Collection<Callable<T>> tasks, int timeout, TimeUnit timeUnit) { Objects.requireNonNull(tasks); try { return executorService.invokeAll(tasks, timeout, timeUnit); } catch (InterruptedException exception) { // Ignored return Collections.emptyList(); } }  public void executeInterruptableTask(final Runnable runnable, String taskName) { this.lowPriorityExecutorService.execute(new NamedRunnable(taskName, runnable)); }  public void executeInterruptableTaskAndWait(Runnable runnable) { Objects.requireNonNull(runnable);  Future<?> future = lowPriorityExecutorService.submit(runnable); try { future.get(); } catch (InterruptedException ignored) { // Ignored } catch (ExecutionException e) { LOGGER.error("Problem executing command", e); } }  public void manageRemoteThread(Thread thread) { if (this.remoteThread != null) { throw new IllegalStateException("Remote thread is already attached"); } else { this.remoteThread = thread; remoteThread.start(); } }  public void stopRemoteThread() { if (remoteThread != null) { remoteThread.interrupt(); remoteThread = null; } }  public void submit(TimerTask timerTask, long millisecondsDelay) { timer.schedule(timerTask, millisecondsDelay); }  public void shutdownEverything() { // those threads will be allowed to finish this.executorService.shutdown(); //those threads will be interrupted in their current task this.lowPriorityExecutorService.shutdownNow(); // kill the remote thread stopRemoteThread(); timer.cancel(); }  private class NamedRunnable implements Runnable {  private final String name;  private final Runnable task;  private NamedRunnable(String name, Runnable runnable) { this.name = name; this.task = runnable; }  @Override public void run() { final String orgName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try { task.run(); } finally { Thread.currentThread().setName(orgName); } } }  }"

"public void requestFocus(Field fieldName) { if (editors.containsKey(fieldName)) { activeField = editors.get(fieldName); activeField.focus(); } }"
"public void setPasteActionHandler(PasteActionHandler handler) { Objects.requireNonNull(handler); this.pasteActionHandler = handler; }"
" private void onSelectedGroupChanged(ObservableList<GroupNodeViewModel> newValue) { if (!currentDatabase.equals(stateManager.activeDatabaseProperty().getValue())) { // Switch of database occurred -> do nothing return; }  currentDatabase.ifPresent(database -> { if ((newValue == null) || newValue.isEmpty()) { stateManager.clearSelectedGroups(database); } else { stateManager.setSelectedGroups(database, newValue.stream().map(GroupNodeViewModel::getGroupNode).collect(Collectors.toList())); } }); }"

"private GridPane getSelectorPanel() { GridPane builder = new GridPane(); Set<Field> fields = FieldFactory.getCommonFields(); fields.add(InternalField.KEY_FIELD); Set<String> fieldsString = fields.stream().map(Field::getDisplayName).sorted().collect(Collectors.toCollection(TreeSet::new)); selectFieldCombobox = new ComboBox<>(FXCollections.observableArrayList(fieldsString)); selectFieldCombobox.setEditable(true); builder.add(selectFieldCombobox, 1, 1);  formattersCombobox = new ComboBox<>(FXCollections.observableArrayList(availableFormatters)); new ViewModelListCellFactory<Formatter>() .withText(Formatter::getName) .withStringTooltip(Formatter::getDescription) .install(formattersCombobox); EasyBind.subscribe(formattersCombobox.valueProperty(), e -> updateDescription()); builder.add(formattersCombobox, 3, 1);  addButton = new Button(Localization.lang("Add")); addButton.setOnAction(e -> { FieldFormatterCleanup newAction = getFieldFormatterCleanup();  if (!actions.contains(newAction)) { actions.add(newAction); } }); builder.add(addButton, 5, 1);  return builder; }"
"private void onActiveDatabaseChanged(Optional<BibDatabaseContext> newDatabase) { if (newDatabase.isPresent()) { GroupNodeViewModel newRoot = newDatabase .map(BibDatabaseContext::getMetaData) .flatMap(MetaData::getGroups) .map(root -> new GroupNodeViewModel(newDatabase.get(), stateManager, taskExecutor, root, localDragboard)) .orElse(GroupNodeViewModel.getAllEntriesGroup(newDatabase.get(), stateManager, taskExecutor, localDragboard));  rootGroup.setValue(newRoot); selectedGroups.setAll( stateManager.getSelectedGroup(newDatabase.get()).stream() .map(selectedGroup -> new GroupNodeViewModel(newDatabase.get(), stateManager, taskExecutor, selectedGroup, localDragboard)) .collect(Collectors.toList())); } else { rootGroup.setValue(null); }  currentDatabase = newDatabase; }"




"private String[] getStringArrayRepresentation(ExternalFileType type) { return new String[]{type.getName(), type.getExtension(), type.getMimeType(), type.getOpenWithApplication(), type.getIcon().name()}; }"

"public void writeOrCreate() throws IOException { if (!isBuiltInList.get()) { List<Abbreviation> actualAbbreviations = abbreviations.stream().filter(abb -> !abb.isPseudoAbbreviation()) .map(abb -> abb.getAbbreviationObject()).collect(Collectors.toList()); AbbreviationWriter.writeOrCreate(path.get(), actualAbbreviations, StandardCharsets.UTF_8); } }"




"public static Supplier<List<MenuItem>> getNameMenu(final TextInputControl textInput) { return () -> { CustomMenuItem normalizeNames = new CustomMenuItem(new Label(Localization.lang("Normalize to BibTeX name format"))); normalizeNames.setOnAction(event -> textInput.setText(new NormalizeNamesFormatter().format(textInput.getText()))); Tooltip toolTip = new Tooltip(Localization.lang("If possible, normalize this list of names to conform to standard BibTeX name formatting")); Tooltip.install(normalizeNames.getContent(), toolTip); List<MenuItem> menuItems = new ArrayList<>(6); menuItems.add(normalizeNames); menuItems.addAll(getDefaultMenu(textInput).get()); return menuItems; }; }"


"public void automatedImport(List<String> filenames) { List<Path> files = filenames.stream().map(Paths::get).collect(Collectors.toList()); BackgroundTask<List<BibEntry>> task = BackgroundTask.wrap(() -> { List<ImportFormatReader.UnknownFormatImport> imports = doImport(files); // Ok, done. Then try to gather in all we have found. Since we might // have found // one or more bibtex results, it's best to gather them in a // BibDatabase. ParserResult bibtexResult = mergeImportResults(imports);  // TODO: show parserwarnings, if any (not here) // for (ImportFormatReader.UnknownFormatImport p : imports) { //    ParserResultWarningDialog.showParserResultWarningDialog(p.parserResult, frame); //} if (bibtexResult == null) { if (importError == null) { throw new JabRefException(Localization.lang("No entries found. Please make sure you are using the correct import filter.")); } else { throw importError; } }  return bibtexResult.getDatabase().getEntries(); });  if (openInNew) { task.onSuccess(entries -> { frame.addTab(new BibDatabaseContext(new BibDatabase(entries)), true); dialogService.notify(Localization.lang("Imported entries") + ": " + entries.size()); }) .executeWith(taskExecutor); } else { final BasePanel panel = frame.getCurrentBasePanel();  ImportEntriesDialog dialog = new ImportEntriesDialog(panel.getBibDatabaseContext(), task); dialog.setTitle(Localization.lang("Import")); dialog.showAndWait(); } }"






"private final GroupTreeNode m_subtreeBackup;"
"public void searchButtonClicked() { BackgroundTask.wrap(() -> searchDirectory(Paths.get(texDirectory.get()))) .onRunning(() -> { root.set(null); noFilesFound.set(true); searchInProgress.set(true); successfulSearch.set(false); }) .onFinished(() -> searchInProgress.set(false)) .onSuccess(newRoot -> { root.set(newRoot); noFilesFound.set(false); successfulSearch.set(true); }) .onFailure(this::handleFailure) .executeWith(taskExecutor); }"
"private static Map<String, String> readIconThemeFile(URL url, String prefix) { Objects.requireNonNull(url, "url"); Objects.requireNonNull(prefix, "prefix");  Map<String, String> result = new HashMap<>();  try (BufferedReader in = new BufferedReader( new InputStreamReader(url.openStream(), StandardCharsets.ISO_8859_1))) { String line; while ((line = in.readLine()) != null) { if (!line.contains("=")) { continue; }  int index = line.indexOf('='); String key = line.substring(0, index).trim(); String value = prefix + line.substring(index + 1).trim(); result.put(key, value); } } catch (IOException e) { LOGGER.warn("Unable to read default icon theme.", e); } return result; }"
"public boolean delete() { Optional<Path> file = linkedFile.findIn(databaseContext, filePreferences);  if (!file.isPresent()) { LOGGER.warn("Could not find file " + linkedFile.getLink()); return true; }  ButtonType removeFromEntry = new ButtonType(Localization.lang("Remove from entry"), ButtonData.YES); ButtonType deleteFromEntry = new ButtonType(Localization.lang("Delete from disk")); Optional<ButtonType> buttonType = dialogService.showCustomButtonDialogAndWait(AlertType.INFORMATION, Localization.lang("Delete '%0'", file.get().toString()), Localization.lang("Delete the selected file permanently from disk, or just remove the file from the entry? Pressing Delete will delete the file permanently from disk."), removeFromEntry, deleteFromEntry, ButtonType.CANCEL);  if (buttonType.isPresent()) { if (buttonType.get().equals(removeFromEntry)) { return true; }  if (buttonType.get().equals(deleteFromEntry)) { try { Files.delete(file.get()); return true; } catch (IOException ex) { dialogService.showErrorDialogAndWait(Localization.lang("Cannot delete file"), Localization.lang("File permission error")); LOGGER.warn("File permission error while deleting: " + linkedFile, ex); } } } return false; }"


"public class ExporterViewModel {  private final TemplateExporter exporter; private final StringProperty name = new SimpleStringProperty(); private final StringProperty layoutFileName = new SimpleStringProperty(); private final StringProperty extension = new SimpleStringProperty();  public ExporterViewModel(TemplateExporter exporter) { this.exporter = exporter; this.name.setValue(exporter.getName()); this.layoutFileName.setValue(exporter.getLayoutFileNameWithExtension()); // Only the first of the extensions gotten from FileType is saved into the class using get(0) String extensionString = exporter.getFileType().getExtensions().get(0); this.extension.setValue(extensionString); }  public TemplateExporter getLogic() { return this.exporter; }  public StringProperty name() { return this.name; }  public StringProperty layoutFileName() { return this.layoutFileName; }  public StringProperty extension() { return this.extension; } }"
"class BibtexKeyPatternPrefTab extends BibtexKeyPatternPanel implements PreferencesTab {  private final JabRefPreferences prefs; private final GridPane builder = new GridPane(); private final CheckBox dontOverwrite = new CheckBox(Localization.lang("Do not overwrite existing keys")); private final CheckBox warnBeforeOverwriting = new CheckBox(Localization.lang("Warn before overwriting existing keys")); private final CheckBox generateOnSave = new CheckBox(Localization.lang("Generate keys before saving (for entries without a key)"));  private final RadioButton letterStartA = new RadioButton(Localization.lang("Ensure unique keys using letters (a, b, ...)")); private final RadioButton letterStartB = new RadioButton(Localization.lang("Ensure unique keys using letters (b, c, ...)")); private final RadioButton alwaysAddLetter = new RadioButton(Localization.lang("Always add letter (a, b, ...) to generated keys"));  private final TextField keyPatternRegex = new TextField(); private final TextField keyPatternReplacement = new TextField();   public BibtexKeyPatternPrefTab(JabRefPreferences prefs, BasePanel panel) { super(panel); builder.add(super.getPanel(), 1, 1); builder.add(new Label(""), 1, 2); this.prefs = prefs; appendKeyGeneratorSettings(); }   /** * Store changes to table preferences. This method is called when the user clicks Ok. * */ @Override public void storeSettings() { // Set the default value: Globals.prefs.put(JabRefPreferences.DEFAULT_BIBTEX_KEY_PATTERN, defaultPat.getText()); Globals.prefs.putBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY, warnBeforeOverwriting.isSelected()); Globals.prefs.putBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY, dontOverwrite.isSelected());  Globals.prefs.put(JabRefPreferences.KEY_PATTERN_REGEX, keyPatternRegex.getText()); Globals.prefs.put(JabRefPreferences.KEY_PATTERN_REPLACEMENT, keyPatternReplacement.getText()); Globals.prefs.putBoolean(JabRefPreferences.GENERATE_KEYS_BEFORE_SAVING, generateOnSave.isSelected());  if (alwaysAddLetter.isSelected()) { Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, true); } else if (letterStartA.isSelected()) { Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A, true); Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, false); } else { Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A, false); Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, false); }  // fetch entries from GUI GlobalBibtexKeyPattern keypatterns = getKeyPatternAsGlobalBibtexKeyPattern(); // store new patterns globally prefs.putKeyPattern(keypatterns); }  private void appendKeyGeneratorSettings() { // Build a panel for checkbox settings: Label keyGeneratorSettings = new Label(Localization.lang("Key generator settings")); keyGeneratorSettings.getStyleClass().add("sectionHeader"); builder.add(keyGeneratorSettings, 1, 10); builder.add(letterStartA, 2, 11); builder.add(warnBeforeOverwriting, 1, 12); builder.add(letterStartB, 2, 12); builder.add(dontOverwrite, 1, 13); builder.add(alwaysAddLetter, 2, 13); builder.add(generateOnSave, 1, 14);  builder.add((new Label(Localization.lang("Replace (regular expression)") + ':')), 1, 15); builder.add(new Label(Localization.lang("by") + ':'), 2, 15);  builder.add(keyPatternRegex, 1, 16); builder.add(keyPatternReplacement, 2, 16);  dontOverwrite.setOnAction(e -> // Warning before overwriting is only relevant if overwriting can happen: warnBeforeOverwriting.setDisable(dontOverwrite.isSelected())); }  @Override public Node getBuilder() { return builder; }  @Override public boolean validateSettings() { return true; }  @Override public void setValues() { super.setValues(Globals.prefs.getKeyPattern()); defaultPat.setText(Globals.prefs.get(JabRefPreferences.DEFAULT_BIBTEX_KEY_PATTERN)); dontOverwrite.setSelected(Globals.prefs.getBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY)); generateOnSave.setSelected(Globals.prefs.getBoolean(JabRefPreferences.GENERATE_KEYS_BEFORE_SAVING)); warnBeforeOverwriting.setSelected(Globals.prefs.getBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY));  boolean prefAlwaysAddLetter = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER); boolean firstLetterA = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A); if (prefAlwaysAddLetter) { this.alwaysAddLetter.setSelected(true); } else if (firstLetterA) { this.letterStartA.setSelected(true); } else { this.letterStartB.setSelected(true); }  // Warning before overwriting is only relevant if overwriting can happen: warnBeforeOverwriting.setDisable(dontOverwrite.isSelected());  keyPatternRegex.setText(Globals.prefs.get(JabRefPreferences.KEY_PATTERN_REGEX)); keyPatternReplacement.setText(Globals.prefs.get(JabRefPreferences.KEY_PATTERN_REPLACEMENT));  }  @Override public String getTabName() { return Localization.lang("BibTeX key generator"); }  @Override public List<String> getRestartWarnings() { return new ArrayList<>(); } }"



"public class ThemeLoader {  public static final String MAIN_CSS = "Base.css"; public static final String DARK_CSS = "Dark.css";  private static final Logger LOGGER = LoggerFactory.getLogger(ThemeLoader.class); private final Optional<URL> additionalCssToLoad; private final FileUpdateMonitor fileUpdateMonitor;  public ThemeLoader(FileUpdateMonitor fileUpdateMonitor, JabRefPreferences jabRefPreferences) { this.fileUpdateMonitor = Objects.requireNonNull(fileUpdateMonitor);  String cssVmArgument = System.getProperty("jabref.theme.css"); String cssPreferences = jabRefPreferences.get(JabRefPreferences.FX_THEME); if (StringUtil.isNotBlank(cssVmArgument)) { // First priority: VM argument LOGGER.info("Using css from VM option: " + cssVmArgument); URL cssVmUrl = null; try { cssVmUrl = Paths.get(cssVmArgument).toUri().toURL(); } catch (MalformedURLException e) { LOGGER.warn("Cannot load css " + cssVmArgument, e); } additionalCssToLoad = Optional.ofNullable(cssVmUrl); } else if (StringUtil.isNotBlank(cssPreferences) && !MAIN_CSS.equalsIgnoreCase(cssPreferences)) { // Otherwise load css from preference URL cssResource = JabRefFrame.class.getResource(cssPreferences); if (cssResource != null) { LOGGER.debug("Using css " + cssResource); additionalCssToLoad = Optional.of(cssResource); } else { additionalCssToLoad = Optional.empty(); LOGGER.warn("Cannot load css " + cssPreferences); } } else { additionalCssToLoad = Optional.empty(); } }  /** * Installs the base css file as a stylesheet in the given scene. Changes in the css file lead to a redraw of the * scene using the new css file. */ public void installCss(Scene scene, JabRefPreferences preferences) { addAndWatchForChanges(scene, JabRefFrame.class.getResource(MAIN_CSS), 0); additionalCssToLoad.ifPresent(file -> addAndWatchForChanges(scene, file, 1));  preferences.getFontSize().ifPresent(size -> scene.getRoot().setStyle("-fx-font-size: " + size + "pt;")); }  private void addAndWatchForChanges(Scene scene, URL cssFile, int index) { scene.getStylesheets().add(index, cssFile.toExternalForm());  try {  URI cssUri = cssFile.toURI(); if (!cssUri.toString().contains("jar")) { LOGGER.debug("CSS URI {}", cssUri);  Path cssPath = Paths.get(cssUri).toAbsolutePath(); // If the file is an ordinary file (i.e. not a resource part of a .jar bundle), we watch it for changes and turn on live reloading if (!cssUri.toString().contains("jar")) { LOGGER.info("Enabling live reloading of {}", cssPath); fileUpdateMonitor.addListenerForFile(cssPath, () -> { LOGGER.info("Reload css file " + cssFile); DefaultTaskExecutor.runInJavaFXThread(() -> { scene.getStylesheets().remove(cssFile.toExternalForm()); scene.getStylesheets().add(index, cssFile.toExternalForm()); }); }); } } } catch (IOException | URISyntaxException | UnsupportedOperationException e) { LOGGER.error("Could not watch css file for changes " + cssFile, e); } } }"





"public static void openFolderAndSelectFile(Path fileLink) throws IOException { if (fileLink == null) { return; } boolean usingDefault = Globals.prefs.getBoolean(JabRefPreferences.USE_DEFAULT_FILE_BROWSER_APPLICATION);  if (usingDefault) { NATIVE_DESKTOP.openFolderAndSelectFile(fileLink); } else { String absolutePath = fileLink.toAbsolutePath().getParent().toString(); String command = Globals.prefs.get(JabRefPreferences.FILE_BROWSER_COMMAND); if (!command.isEmpty()) { command = command.replaceAll("\\s+", " "); // normalize white spaces  // replace the placeholder if used command = command.replace("%DIR", absolutePath); String[] subcommands = command.split(" ");  LOGGER.info("Executing command \"" + command + "\"...");  try { new ProcessBuilder(subcommands).start(); } catch (IOException exception) { LOGGER.error("Open File Browser", exception); JabRefGUI.getMainFrame().getDialogService().notify(Localization.lang("Error occured while executing the command \"%0\".", command)); } } } }"

"public class UndoableRemoveEntry extends AbstractUndoableJabRefEdit {  private static final Logger LOGGER = LoggerFactory.getLogger(UndoableRemoveEntry.class); private final BibDatabase base; private final BibEntry entry;  public UndoableRemoveEntry(BibDatabase base, BibEntry entry) { this.base = base; this.entry = entry; }  @Override public String getPresentationName() { return Localization.lang("remove entry %0", StringUtil.boldHTML(entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); }  @Override public void undo() { super.undo(); base.insertEntry(entry, EntryEventSource.UNDO); }  @Override public void redo() { super.redo();  // Redo the change. try { base.removeEntry(entry); } catch (Throwable ex) { LOGGER.warn("Problem to redo `remove entry`", ex); } }  }"


"public BibEntry getMergeEntry() { return mergedEntry; }"
"public void focus() { if (!searchField.isFocused()) { searchField.requestFocus(); } searchField.selectAll(); }"
"public abstract boolean shouldShow(BibEntry entry);"


"void operationCompleted();"
"public UndoableAddOrRemoveGroup(GroupTreeNodeViewModel groupsRoot, GroupTreeNodeViewModel editedNode, int editType) { m_groupsRootHandle = groupsRoot; m_editType = editType; m_subtreeRootChildCount = editedNode.getChildren().size(); // storing a backup of the whole subtree is not required when children // are kept m_subtreeBackup = editType != UndoableAddOrRemoveGroup.REMOVE_NODE_KEEP_CHILDREN ? editedNode.getNode() .copySubtree() : GroupTreeNode.fromGroup(editedNode.getNode().getGroup().deepCopy()); // remember path to edited node. this cannot be stored as a reference, // because the reference itself might change. the method below is more // robust. m_pathToNode = editedNode.getNode().getIndexedPathFromRoot(); }"






"private final int m_editType;"


"public class EntryEditor extends BorderPane {  private static final Logger LOGGER = LoggerFactory.getLogger(EntryEditor.class);  private final BasePanel panel; private final BibDatabaseContext databaseContext; private final EntryEditorPreferences entryEditorPreferences; private final ExternalFilesEntryLinker fileLinker; private final List<EntryEditorTab> tabs; private Subscription typeSubscription; private BibEntry entry;  // A reference to the entry this editor works on. private SourceTab sourceTab; @FXML private TabPane tabbed; @FXML private Button typeChangeButton; @FXML private Button fetcherButton; @FXML private Label typeLabel; @Inject private DialogService dialogService; @Inject private TaskExecutor taskExecutor; @Inject private PreferencesService preferencesService; @Inject private StateManager stateManager; @Inject private FileUpdateMonitor fileMonitor; @Inject private CountingUndoManager undoManager; private final List<EntryEditorTab> entryEditorTabs = new LinkedList<>();  public EntryEditor(BasePanel panel, ExternalFileTypes externalFileTypes) { this.panel = panel; this.databaseContext = panel.getBibDatabaseContext();  ViewLoader.view(this) .root(this) .load();  this.entryEditorPreferences = preferencesService.getEntryEditorPreferences(); this.fileLinker = new ExternalFilesEntryLinker(externalFileTypes, preferencesService.getFilePreferences(), databaseContext);  if (GUIGlobals.currentFont != null) { setStyle(String.format("text-area-background: %s;text-area-foreground: %s;text-area-highlight: %s;", ColorUtil.toHex(GUIGlobals.validFieldBackgroundColor), ColorUtil.toHex(GUIGlobals.editorTextColor), ColorUtil.toHex(GUIGlobals.activeBackgroundColor))); }  EasyBind.subscribe(tabbed.getSelectionModel().selectedItemProperty(), tab -> { EntryEditorTab activeTab = (EntryEditorTab) tab; if (activeTab != null) { activeTab.notifyAboutFocus(entry); } });  setupKeyBindings();  this.tabs = createTabs();  this.setOnDragOver(event -> { if (event.getDragboard().hasFiles()) { event.acceptTransferModes(TransferMode.COPY, TransferMode.MOVE, TransferMode.LINK); } event.consume(); });  this.setOnDragDropped(event -> { BibEntry entry = this.getEntry(); boolean success = false;  if (event.getDragboard().hasContent(DataFormat.FILES)) { List<Path> files = event.getDragboard().getFiles().stream().map(File::toPath).collect(Collectors.toList()); FileDragDropPreferenceType dragDropPreferencesType = preferencesService.getEntryEditorFileLinkPreference();  if (dragDropPreferencesType == FileDragDropPreferenceType.MOVE) { if (event.getTransferMode() == TransferMode.LINK) { // Alt on Windows LOGGER.debug("Mode LINK"); fileLinker.addFilesToEntry(entry, files); } else if (event.getTransferMode() == TransferMode.COPY) { // Ctrl on Windows, no modifier on Xubuntu LOGGER.debug("Mode COPY"); fileLinker.copyFilesToFileDirAndAddToEntry(entry, files); } else { // Shift on Windows or no modifier LOGGER.debug("Mode MOVE"); fileLinker.moveFilesToFileDirAndAddToEntry(entry, files); } success = true; }  if (dragDropPreferencesType == FileDragDropPreferenceType.COPY) { if (event.getTransferMode() == TransferMode.COPY) { // Ctrl on Windows, no modifier on Xubuntu LOGGER.debug("Mode MOVE"); fileLinker.moveFilesToFileDirAndAddToEntry(entry, files); } else if (event.getTransferMode() == TransferMode.LINK) { // Alt on Windows LOGGER.debug("Mode LINK"); fileLinker.addFilesToEntry(entry, files); } else { // Shift on Windows or no modifier LOGGER.debug("Mode COPY"); fileLinker.copyFilesToFileDirAndAddToEntry(entry, files); } success = true; }  if (dragDropPreferencesType == FileDragDropPreferenceType.LINK) { if (event.getTransferMode() == TransferMode.COPY) { // Ctrl on Windows, no modifier on Xubuntu LOGGER.debug("Mode COPY"); fileLinker.copyFilesToFileDirAndAddToEntry(entry, files); } else if (event.getTransferMode() == TransferMode.LINK) { // Alt on Windows LOGGER.debug("Mode MOVE"); fileLinker.moveFilesToFileDirAndAddToEntry(entry, files); } else { // Shift on Windows or no modifier LOGGER.debug("Mode LINK"); fileLinker.addFilesToEntry(entry, files); } success = true; } }  event.setDropCompleted(success); event.consume(); }); }  /** * Set-up key bindings specific for the entry editor. */ private void setupKeyBindings() { this.addEventHandler(KeyEvent.KEY_PRESSED, event -> { Optional<KeyBinding> keyBinding = entryEditorPreferences.getKeyBindings().mapToKeyBinding(event); if (keyBinding.isPresent()) { switch (keyBinding.get()) { case ENTRY_EDITOR_NEXT_PANEL: case ENTRY_EDITOR_NEXT_PANEL_2: tabbed.getSelectionModel().selectNext(); event.consume(); break; case ENTRY_EDITOR_PREVIOUS_PANEL: case ENTRY_EDITOR_PREVIOUS_PANEL_2: tabbed.getSelectionModel().selectPrevious(); event.consume(); break; case ENTRY_EDITOR_NEXT_ENTRY: panel.selectNextEntry(); event.consume(); break; case ENTRY_EDITOR_PREVIOUS_ENTRY: panel.selectPreviousEntry(); event.consume(); break; case HELP: HelpAction.openHelpPage(HelpFile.ENTRY_EDITOR); event.consume(); break; case CLOSE: case CLOSE_ENTRY: close(); event.consume(); break; default: // Pass other keys to parent } } }); }  @FXML public void close() { panel.entryEditorClosing(); }  @FXML private void deleteEntry() { panel.delete(entry); }  @FXML void generateCiteKeyButton() { GenerateBibtexKeySingleAction action = new GenerateBibtexKeySingleAction(getEntry(), databaseContext, dialogService, entryEditorPreferences, undoManager); action.execute(); }  @FXML private void navigateToPreviousEntry() { panel.selectPreviousEntry(); }  @FXML private void navigateToNextEntry() { panel.selectNextEntry(); }  private List<EntryEditorTab> createTabs() {  // Required fields entryEditorTabs.add(new RequiredFieldsTab(databaseContext, panel.getSuggestionProviders(), undoManager, dialogService));  // Optional fields entryEditorTabs.add(new OptionalFieldsTab(databaseContext, panel.getSuggestionProviders(), undoManager, dialogService)); entryEditorTabs.add(new OptionalFields2Tab(databaseContext, panel.getSuggestionProviders(), undoManager, dialogService)); entryEditorTabs.add(new DeprecatedFieldsTab(databaseContext, panel.getSuggestionProviders(), undoManager, dialogService));  // Other fields entryEditorTabs.add(new OtherFieldsTab(databaseContext, panel.getSuggestionProviders(), undoManager, entryEditorPreferences.getCustomTabFieldNames(), dialogService));  // General fields from preferences for (Map.Entry<String, Set<Field>> tab : entryEditorPreferences.getEntryEditorTabList().entrySet()) { entryEditorTabs.add(new UserDefinedFieldsTab(tab.getKey(), tab.getValue(), databaseContext, panel.getSuggestionProviders(), undoManager, dialogService)); }  // Special tabs entryEditorTabs.add(new MathSciNetTab()); entryEditorTabs.add(new FileAnnotationTab(panel.getAnnotationCache())); entryEditorTabs.add(new RelatedArticlesTab(this, entryEditorPreferences, dialogService));  // Source tab sourceTab = new SourceTab(databaseContext, undoManager, entryEditorPreferences.getLatexFieldFormatterPreferences(), entryEditorPreferences.getImportFormatPreferences(), fileMonitor, dialogService, stateManager); entryEditorTabs.add(sourceTab);  // LaTeX citations tab entryEditorTabs.add(new LatexCitationsTab(databaseContext, preferencesService, taskExecutor, dialogService));  return entryEditorTabs; }  private void recalculateVisibleTabs() { List<Tab> visibleTabs = tabs.stream().filter(tab -> tab.shouldShow(entry)).collect(Collectors.toList());  // Start of ugly hack: // We need to find out, which tabs will be shown and which not and remove and re-add the appropriate tabs // to the editor. We don't want to simply remove all and re-add the complete list of visible tabs, because // the tabs give an ugly animation the looks like all tabs are shifting in from the right. // This hack is required since tabbed.getTabs().setAll(visibleTabs) changes the order of the tabs in the editor  // First, remove tabs that we do not want to show List<EntryEditorTab> toBeRemoved = tabs.stream().filter(tab -> !tab.shouldShow(entry)).collect(Collectors.toList()); tabbed.getTabs().removeAll(toBeRemoved);  // Next add all the visible tabs (if not already present) at the right position for (int i = 0; i < visibleTabs.size(); i++) { Tab toBeAdded = visibleTabs.get(i); Tab shown = null;  if (i < tabbed.getTabs().size()) { shown = tabbed.getTabs().get(i); }  if (!toBeAdded.equals(shown)) { tabbed.getTabs().add(i, toBeAdded); } } }  /** * @return the currently edited entry */ public BibEntry getEntry() { return entry; }  /** * Sets the entry to edit. */ public void setEntry(BibEntry entry) { Objects.requireNonNull(entry);  // Remove subscription for old entry if existing if (typeSubscription != null) { typeSubscription.unsubscribe(); }  this.entry = entry;  recalculateVisibleTabs(); if (entryEditorPreferences.showSourceTabByDefault()) { tabbed.getSelectionModel().select(sourceTab); }  // Notify current tab about new entry getSelectedTab().notifyAboutFocus(entry);  setupToolBar();  // Subscribe to type changes for rebuilding the currently visible tab typeSubscription = EasyBind.subscribe(this.entry.typeProperty(), type -> { typeLabel.setText(new TypedBibEntry(entry, databaseContext.getMode()).getTypeForDisplay()); recalculateVisibleTabs(); getSelectedTab().notifyAboutFocus(entry); }); }  private EntryEditorTab getSelectedTab() { return (EntryEditorTab) tabbed.getSelectionModel().getSelectedItem(); }  private void setupToolBar() { // Update type label TypedBibEntry typedEntry = new TypedBibEntry(entry, databaseContext.getMode()); typeLabel.setText(typedEntry.getTypeForDisplay());  // Add type change menu ContextMenu typeMenu = new ChangeEntryTypeMenu().getChangeEntryTypePopupMenu(entry, databaseContext, undoManager); typeLabel.setOnMouseClicked(event -> typeMenu.show(typeLabel, Side.RIGHT, 0, 0)); typeChangeButton.setOnMouseClicked(event -> typeMenu.show(typeChangeButton, Side.RIGHT, 0, 0));  // Add menu for fetching bibliographic information ContextMenu fetcherMenu = new ContextMenu(); for (EntryBasedFetcher fetcher : WebFetchers.getEntryBasedFetchers(entryEditorPreferences.getImportFormatPreferences())) { MenuItem fetcherMenuItem = new MenuItem(fetcher.getName()); fetcherMenuItem.setOnAction(event -> fetchAndMerge(fetcher)); fetcherMenu.getItems().add(fetcherMenuItem); } fetcherButton.setOnMouseClicked(event -> fetcherMenu.show(fetcherButton, Side.RIGHT, 0, 0)); }  private void fetchAndMerge(EntryBasedFetcher fetcher) { new FetchAndMergeEntry(panel, taskExecutor).fetchAndMerge(entry, fetcher); }  public void setFocusToField(Field field) { DefaultTaskExecutor.runInJavaFXThread(() -> { for (Tab tab : tabbed.getTabs()) { if ((tab instanceof FieldsEditorTab) && ((FieldsEditorTab) tab).getShownFields().contains(field)) { FieldsEditorTab fieldsEditorTab = (FieldsEditorTab) tab; tabbed.getSelectionModel().select(tab); fieldsEditorTab.requestFocus(field); } } }); }  public void updatePreviewInTabs(PreviewPreferences previewPreferences) { for (Tab tab : this.entryEditorTabs) { if (tab instanceof FieldsEditorTab) { ((FieldsEditorTab) tab).previewPanel.updateLayout(previewPreferences); } } } }"




"public class ViewModelTableRowFactory<S> implements Callback<TableView<S>, TableRow<S>> {  private BiConsumer<S, ? super MouseEvent> onMouseClickedEvent; private Function<S, ContextMenu> contextMenuFactory; private TriConsumer<TableRow<S>, S, ? super MouseEvent> toOnDragDetected; private TriConsumer<TableRow<S>, S, ? super DragEvent> toOnDragDropped; private BiConsumer<S, ? super DragEvent> toOnDragEntered; private TriConsumer<TableRow<S>, S, ? super DragEvent> toOnDragExited; private TriConsumer<TableRow<S>, S, ? super DragEvent> toOnDragOver; private TriConsumer<TableRow<S>, S, ? super MouseDragEvent> toOnMouseDragEntered; private Callback<S, String> toTooltip;  public ViewModelTableRowFactory<S> withOnMouseClickedEvent(BiConsumer<S, ? super MouseEvent> onMouseClickedEvent) { this.onMouseClickedEvent = onMouseClickedEvent; return this; }  public ViewModelTableRowFactory<S> withContextMenu(Function<S, ContextMenu> contextMenuFactory) { this.contextMenuFactory = contextMenuFactory; return this; }  public ViewModelTableRowFactory<S> setOnDragDetected(TriConsumer<TableRow<S>, S, ? super MouseEvent> toOnDragDetected) { this.toOnDragDetected = toOnDragDetected; return this; }  public ViewModelTableRowFactory<S> setOnDragDetected(BiConsumer<S, ? super MouseEvent> toOnDragDetected) { this.toOnDragDetected = (row, viewModel, event) -> toOnDragDetected.accept(viewModel, event); return this; }  public ViewModelTableRowFactory<S> setOnDragDropped(TriConsumer<TableRow<S>, S, ? super DragEvent> toOnDragDropped) { this.toOnDragDropped = toOnDragDropped; return this; }  public ViewModelTableRowFactory<S> setOnDragDropped(BiConsumer<S, ? super DragEvent> toOnDragDropped) { return setOnDragDropped((row, viewModel, event) -> toOnDragDropped.accept(viewModel, event)); }  public ViewModelTableRowFactory<S> setOnDragEntered(BiConsumer<S, ? super DragEvent> toOnDragEntered) { this.toOnDragEntered = toOnDragEntered; return this; }  public ViewModelTableRowFactory<S> setOnMouseDragEntered(TriConsumer<TableRow<S>, S, ? super MouseDragEvent> toOnDragEntered) { this.toOnMouseDragEntered = toOnDragEntered; return this; }  public ViewModelTableRowFactory<S> setOnMouseDragEntered(BiConsumer<S, ? super MouseDragEvent> toOnDragEntered) { return setOnMouseDragEntered((row, viewModel, event) -> toOnDragEntered.accept(viewModel, event)); }  public ViewModelTableRowFactory<S> setOnDragExited(TriConsumer<TableRow<S>, S, ? super DragEvent> toOnDragExited) { this.toOnDragExited = toOnDragExited; return this; }  public ViewModelTableRowFactory<S> setOnDragExited(BiConsumer<S, ? super DragEvent> toOnDragExited) { return setOnDragExited((row, viewModel, event) -> toOnDragExited.accept(viewModel, event)); }  public ViewModelTableRowFactory<S> setOnDragOver(TriConsumer<TableRow<S>, S, ? super DragEvent> toOnDragOver) { this.toOnDragOver = toOnDragOver; return this; }  public ViewModelTableRowFactory<S> setOnDragOver(BiConsumer<S, ? super DragEvent> toOnDragOver) { return setOnDragOver((row, viewModel, event) -> toOnDragOver.accept(viewModel, event)); }  public ViewModelTableRowFactory<S> withTooltip(Callback<S, String> toTooltip) { this.toTooltip = toTooltip; return this; }  @Override public TableRow<S> call(TableView<S> tableView) { TableRow<S> row = new TableRow<>();  if (toTooltip != null) { String tooltipText = toTooltip.call(row.getItem()); if (StringUtil.isNotBlank(tooltipText)) { row.setTooltip(new Tooltip(tooltipText)); } }  if (onMouseClickedEvent != null) { row.setOnMouseClicked(event -> { if (!row.isEmpty()) { onMouseClickedEvent.accept(row.getItem(), event); } }); }  if (contextMenuFactory != null) { // We only create the context menu when really necessary row.setOnContextMenuRequested(event -> { if (!row.isEmpty()) { row.setContextMenu(contextMenuFactory.apply(row.getItem())); row.getContextMenu().show(row, event.getScreenX(), event.getScreenY()); } event.consume(); });  // Activate context menu if user presses the "context menu" key tableView.addEventHandler(KeyEvent.KEY_RELEASED, event -> { boolean rowFocused = !row.isEmpty() && tableView.getFocusModel().getFocusedIndex() == row.getIndex(); if (event.getCode() == KeyCode.CONTEXT_MENU && rowFocused) { // Get center of focused cell Bounds anchorBounds = row.getBoundsInParent(); double x = anchorBounds.getMinX() + anchorBounds.getWidth() / 2; double y = anchorBounds.getMinY() + anchorBounds.getHeight() / 2; Point2D screenPosition = row.getParent().localToScreen(x, y);  if (row.getContextMenu() == null) { row.setContextMenu(contextMenuFactory.apply(row.getItem())); } row.getContextMenu().show(row, screenPosition.getX(), screenPosition.getY()); } }); }  if (toOnDragDetected != null) { row.setOnDragDetected(event -> { if (!row.isEmpty()) { toOnDragDetected.accept(row, row.getItem(), event); } }); } if (toOnDragDropped != null) { row.setOnDragDropped(event -> { if (!row.isEmpty()) { toOnDragDropped.accept(row, row.getItem(), event); } }); } if (toOnDragEntered != null) { row.setOnDragEntered(event -> { if (!row.isEmpty()) { toOnDragEntered.accept(row.getItem(), event); } }); } if (toOnDragExited != null) { row.setOnDragExited(event -> { if (!row.isEmpty()) { toOnDragExited.accept(row, row.getItem(), event); } }); } if (toOnDragOver != null) { row.setOnDragOver(event -> { if (!row.isEmpty()) { toOnDragOver.accept(row, row.getItem(), event); } }); }  if (toOnMouseDragEntered != null) { row.setOnMouseDragEntered(event -> { if (!row.isEmpty()) { toOnMouseDragEntered.accept(row, row.getItem(), event); } }); } return row; }  public void install(TableView<S> table) { table.setRowFactory(this); } }"



"protected static String processPreview(List<String> citations) { return String.join(CitationStyleOutputFormat.HTML.getLineSeparator(), citations); }"


"List<String> getRestartWarnings();"



"public static XComponentContext createInitialComponentContext(Map<String, Object> context_entries) throws Exception { ServiceManager xSMgr = new ServiceManager();  XImplementationLoader xImpLoader = UnoRuntime.queryInterface(XImplementationLoader.class, new JavaLoader()); XInitialization xInit = UnoRuntime.queryInterface(XInitialization.class, xImpLoader); Object[] args = new Object[] {xSMgr}; xInit.initialize(args);  // initial component context if (context_entries == null) { context_entries = new HashMap<>(1); } // add smgr context_entries.put("/singletons/com.sun.star.lang.theServiceManager", new ComponentContextEntry(null, xSMgr)); // ... xxx todo: add standard entries XComponentContext xContext = new ComponentContext(context_entries, null);  xSMgr.setDefaultContext(xContext);  XSet xSet = UnoRuntime.queryInterface(XSet.class, xSMgr); // insert basic jurt factories insertBasicFactories(xSet, xImpLoader);  return xContext; }"

"private void generateKeys(List<BibEntry> entries) { BibtexKeyGenerator keyGenerator = new BibtexKeyGenerator( database.getMetaData().getCiteKeyPattern(Globals.prefs.getBibtexKeyPatternPreferences().getKeyPattern()), database.getDatabase(), Globals.prefs.getBibtexKeyPatternPreferences());  for (BibEntry entry : entries) { keyGenerator.generateAndSetKey(entry); } }"
"public class HelpAction extends SimpleCommand {  /** * New languages of the help have to be added here */ private static final Set<String> AVAILABLE_LANG_FILES = Stream.of("en", "de", "fr", "in", "ja") .collect(Collectors.toCollection(HashSet::new));  private HelpFile helpPage;  public HelpAction(HelpFile helpPage) { this.helpPage = helpPage; }  public static void openHelpPage(HelpFile helpPage) { String lang = Globals.prefs.get(JabRefPreferences.LANGUAGE); StringBuilder sb = new StringBuilder("https://help.jabref.org/");  if (AVAILABLE_LANG_FILES.contains(lang)) { sb.append(lang); sb.append("/"); } else { sb.append("en/"); } sb.append(helpPage.getPageName()); JabRefDesktop.openBrowserShowPopup(sb.toString()); }  public static SimpleCommand getMainHelpPageCommand() { return new SimpleCommand() { @Override public void execute() { openHelpPage(HelpFile.CONTENTS); } }; }  @Override public void execute() { openHelpPage(helpPage); } }"

"public <T> void putValue(Class<T> type, T value) { clearAll(); contents.put(type, type.cast(value)); }"


"private Optional<BibEntry> findInternalDuplicate(BibEntry entry) { for (BibEntry othEntry : entries) { if (othEntry.equals(entry)) { continue; // Don't compare the entry to itself } if (new DuplicateCheck(Globals.entryTypesManager).isDuplicate(entry, othEntry, database.getMode())) { return Optional.of(othEntry); } } return Optional.empty(); }"


"public final class EntryEditorTabList {  private EntryEditorTabList() {  }  public static Map<String, Set<Field>> create(JabRefPreferences preferences) { Map<String, Set<Field>> tabs = new LinkedHashMap<>(); int i = 0; String name; if (preferences.hasKey(JabRefPreferences.CUSTOM_TAB_NAME + 0)) { // The user has modified from the default values: while (preferences.hasKey(JabRefPreferences.CUSTOM_TAB_NAME + i)) { name = preferences.get(JabRefPreferences.CUSTOM_TAB_NAME + i); Set<Field> entry = FieldFactory.parseFieldList(preferences.get(JabRefPreferences.CUSTOM_TAB_FIELDS + i)); tabs.put(name, entry); i++; } } else { // Nothing set, so we use the default values: while (preferences.get(JabRefPreferences.CUSTOM_TAB_NAME + "_def" + i) != null) { name = preferences.get(JabRefPreferences.CUSTOM_TAB_NAME + "_def" + i); Set<Field> entry = FieldFactory.parseFieldList(preferences.get(JabRefPreferences.CUSTOM_TAB_FIELDS + "_def" + i)); tabs.put(name, entry); i++; } } return tabs; } }"



"public interface PushToApplication {  String getName();  String getApplicationName();  String getTooltip();  JabRefIcon getIcon();   /** * The actual operation. This method will not be called on the event dispatch thread, so it should not do GUI * operations without utilizing invokeLater(). */ void pushEntries(BibDatabaseContext database, List<BibEntry> entries, String keyString);  /** * Reporting etc., this method is called on the event dispatch thread after pushEntries() returns. */ void operationCompleted();  /** * Check whether this operation requires BibTeX keys to be set for the entries. If true is returned an error message * will be displayed if keys are missing. * * @return true if BibTeX keys are required for this operation. */ boolean requiresBibtexKeys();  }"
"public class OpenHyperlinksInExternalBrowser implements ChangeListener<Worker.State>, EventListener {  private static final Logger LOGGER = LoggerFactory.getLogger(OpenHyperlinksInExternalBrowser.class); private static final String CLICK_EVENT = "click"; private static final String ANCHOR_TAG = "a";  private final WebView webView;  public OpenHyperlinksInExternalBrowser(WebView webView) { this.webView = webView; }  @Override public void changed(ObservableValue<? extends State> observable, State oldValue, State newValue) { if (State.SUCCEEDED.equals(newValue)) { Document document = webView.getEngine().getDocument(); NodeList anchors = document.getElementsByTagName(ANCHOR_TAG); for (int i = 0; i < anchors.getLength(); i++) { Node node = anchors.item(i); EventTarget eventTarget = (EventTarget) node; eventTarget.addEventListener(CLICK_EVENT, this, false); } } }  @Override public void handleEvent(Event event) { HTMLAnchorElement anchorElement = (HTMLAnchorElement) event.getCurrentTarget(); String href = anchorElement.getHref();  try { JabRefDesktop.openBrowser(href); } catch (IOException e) { LOGGER.error("Problem opening browser", e); } event.preventDefault(); }  }"
"public class ViewModelTreeTableCellFactory<S> implements Callback<TreeTableColumn<S, S>, TreeTableCell<S, S>> {  private Callback<S, String> toText; private Callback<S, Node> toGraphic; private Callback<S, EventHandler<? super MouseEvent>> toOnMouseClickedEvent; private Callback<S, String> toTooltip;  public ViewModelTreeTableCellFactory<S> withText(Callback<S, String> toText) { this.toText = toText; return this; }  public ViewModelTreeTableCellFactory<S> withGraphic(Callback<S, Node> toGraphic) { this.toGraphic = toGraphic; return this; }  public ViewModelTreeTableCellFactory<S> withIcon(Callback<S, JabRefIcon> toIcon) { this.toGraphic = viewModel -> toIcon.call(viewModel).getGraphicNode(); return this; }  public ViewModelTreeTableCellFactory<S> withTooltip(Callback<S, String> toTooltip) { this.toTooltip = toTooltip; return this; }  public ViewModelTreeTableCellFactory<S> withOnMouseClickedEvent( Callback<S, EventHandler<? super MouseEvent>> toOnMouseClickedEvent) { this.toOnMouseClickedEvent = toOnMouseClickedEvent; return this; }  @Override public TreeTableCell<S, S> call(TreeTableColumn<S, S> param) {  return new TreeTableCell<S, S>() {  @Override protected void updateItem(S viewModel, boolean empty) { super.updateItem(viewModel, empty);  if (empty || viewModel == null) { setText(null); setGraphic(null); setOnMouseClicked(null); } else { if (toText != null) { setText(toText.call(viewModel)); } if (toGraphic != null) { setGraphic(toGraphic.call(viewModel)); } if (toTooltip != null) { String tooltip = toTooltip.call(viewModel); if (StringUtil.isNotBlank(tooltip)) { setTooltip(new Tooltip(tooltip)); } } if (toOnMouseClickedEvent != null) { setOnMouseClicked(toOnMouseClickedEvent.call(viewModel)); } } } }; }  public void install(TreeTableColumn<S, S> column) { column.setCellValueFactory(cellData -> cellData.getValue().valueProperty()); column.setCellFactory(this); } }"
"public static URL getIconUrl(String name) { String key = Objects.requireNonNull(name, "icon name"); if (!KEY_TO_ICON.containsKey(key)) { LOGGER.warn("Could not find icon url by name " + name + ", so falling back on default icon " + DEFAULT_ICON_PATH); } String path = KEY_TO_ICON.getOrDefault(key, DEFAULT_ICON_PATH); return Objects.requireNonNull(IconTheme.class.getResource(path), "Path must not be null for key " + key); }"



"public SuggestionProviders() {  }"
"public class NoSelectionModel<T> extends MultipleSelectionModel<T> {  @Override public ObservableList<Integer> getSelectedIndices() { return FXCollections.emptyObservableList(); }  @Override public ObservableList<T> getSelectedItems() { return FXCollections.emptyObservableList(); }  @Override public void selectIndices(int index, int... indices) { }  @Override public void selectAll() { }  @Override public void selectFirst() { }  @Override public void selectLast() { }  @Override public void clearAndSelect(int index) { }  @Override public void select(int index) { }  @Override public void select(T obj) { }  @Override public void clearSelection(int index) { }  @Override public void clearSelection() { }  @Override public boolean isSelected(int index) { return false; }  @Override public boolean isEmpty() { return true; }  @Override public void selectPrevious() { }  @Override public void selectNext() { } }"
"public void moveDown(SidePaneComponent comp) { if (visibleComponents.contains(comp)) { int currentPosition = visibleComponents.indexOf(comp); if (currentPosition < (visibleComponents.size() - 1)) { int newPosition = currentPosition + 1; visibleComponents.remove(currentPosition); visibleComponents.add(newPosition, comp);  updatePreferredPositions(); updateView(); } } }"


"public class RelatedArticlesTab extends EntryEditorTab {  private static final Logger LOGGER = LoggerFactory.getLogger(RelatedArticlesTab.class); private final EntryEditorPreferences preferences; private final EntryEditor entryEditor; private final DialogService dialogService;  public RelatedArticlesTab(EntryEditor entryEditor, EntryEditorPreferences preferences, DialogService dialogService) { setText(Localization.lang("Related articles")); setTooltip(new Tooltip(Localization.lang("Related articles"))); this.entryEditor = entryEditor; this.preferences = preferences; this.dialogService = dialogService; }  /** * Gets a StackPane of related article information to be displayed in the Related Articles tab * @param entry The currently selected BibEntry on the JabRef UI. * @return A StackPane with related article information to be displayed in the Related Articles tab. */ private StackPane getRelatedArticlesPane(BibEntry entry) { StackPane root = new StackPane(); root.getStyleClass().add("related-articles-tab"); ProgressIndicator progress = new ProgressIndicator(); progress.setMaxSize(100, 100);  MrDLibFetcher fetcher = new MrDLibFetcher(Globals.prefs.get(JabRefPreferences.LANGUAGE), Globals.BUILD_INFO.getVersion()); BackgroundTask .wrap(() -> fetcher.performSearch(entry)) .onRunning(() -> progress.setVisible(true)) .onSuccess(relatedArticles -> { progress.setVisible(false); root.getChildren().add(getRelatedArticleInfo(relatedArticles, fetcher)); }) .onFailure(exception -> { LOGGER.error("Error while fetching from Mr. DLib", exception); progress.setVisible(false); root.getChildren().add(getErrorInfo()); }) .executeWith(Globals.TASK_EXECUTOR);  root.getChildren().add(progress);  return root; }  /** * Creates a VBox of the related article information to be used in the StackPane displayed in the Related Articles tab * @param list List of BibEntries of related articles * @return VBox of related article descriptions to be displayed in the Related Articles tab */ private ScrollPane getRelatedArticleInfo(List<BibEntry> list, MrDLibFetcher fetcher) { ScrollPane scrollPane = new ScrollPane();  VBox vBox = new VBox(); vBox.setSpacing(20.0);  String heading = fetcher.getHeading(); Text headingText = new Text(heading); headingText.getStyleClass().add("recommendation-heading"); String description = fetcher.getDescription(); Text descriptionText = new Text(description); descriptionText.getStyleClass().add("recommendation-description"); vBox.getChildren().add(headingText); vBox.getChildren().add(descriptionText);  for (BibEntry entry : list) { HBox hBox = new HBox(); hBox.setSpacing(5.0); hBox.getStyleClass().add("recommendation-item");  String title = entry.getTitle().orElse(""); String journal = entry.getField(StandardField.JOURNAL).orElse(""); String authors = entry.getField(StandardField.AUTHOR).orElse(""); String year = entry.getField(StandardField.YEAR).orElse("");  Hyperlink titleLink = new Hyperlink(title); Text journalText = new Text(journal); journalText.setFont(Font.font(Font.getDefault().getFamily(), FontPosture.ITALIC, Font.getDefault().getSize())); Text authorsText = new Text(authors); Text yearText = new Text("(" + year + ")"); titleLink.setOnAction(event -> { if (entry.getField(StandardField.URL).isPresent()) { try { JabRefDesktop.openBrowser(entry.getField(StandardField.URL).get()); } catch (IOException e) { LOGGER.error("Error opening the browser to: " + entry.getField(StandardField.URL).get(), e); dialogService.showErrorDialogAndWait(e); } } });  hBox.getChildren().addAll(titleLink, journalText, authorsText, yearText); vBox.getChildren().add(hBox); } scrollPane.setContent(vBox); return scrollPane; }  /** * Gets a ScrollPane to display error info when recommendations fail. * @return ScrollPane to display in place of recommendations */ private ScrollPane getErrorInfo() { ScrollPane scrollPane = new ScrollPane();  VBox vBox = new VBox(); vBox.setSpacing(20.0);  Text descriptionText = new Text(Localization.lang("No recommendations received from Mr. DLib for this entry.")); descriptionText.getStyleClass().add("recommendation-description"); vBox.getChildren().add(descriptionText); scrollPane.setContent(vBox);  return scrollPane; }  /** * Returns a consent dialog used to ask permission to send data to Mr. DLib. * @param entry Currently selected BibEntry. (required to allow reloading of pane if accepted) * @return StackPane returned to be placed into Related Articles tab. */ private ScrollPane getPrivacyDialog(BibEntry entry) { ScrollPane root = new ScrollPane(); root.getStyleClass().add("related-articles-tab"); VBox vbox = new VBox(); vbox.getStyleClass().add("gdpr-dialog"); vbox.setSpacing(20.0);  Button button = new Button(Localization.lang("I Agree")); button.setDefaultButton(true);  Text line1 = new Text(Localization.lang("JabRef requests recommendations from Mr. DLib, which is an external service. To enable Mr. DLib to calculate recommendations, some of your data must be shared with Mr. DLib. Generally, the more data is shared the better recommendations can be calculated. However, we understand that some of your data in JabRef is sensitive, and you may not want to share it. Therefore, Mr. DLib offers a choice of which data you would like to share.")); line1.setWrappingWidth(1300.0); Text line2 = new Text(Localization.lang("Whatever option you choose, Mr. DLib may share its data with research partners to further improve recommendation quality as part of a 'living lab'. Mr. DLib may also release public datasets that may contain anonymized information about you and the recommendations (sensitive information such as metadata of your articles will be anonymised through e.g. hashing). Research partners are obliged to adhere to the same strict data protection policy as Mr. DLib.")); line2.setWrappingWidth(1300.0); Text line3 = new Text(Localization.lang("This setting may be changed in preferences at any time.")); Hyperlink mdlLink = new Hyperlink(Localization.lang("Further information about Mr DLib. for JabRef users.")); mdlLink.setOnAction(event -> { try { JabRefDesktop.openBrowser("http://mr-dlib.org/information-for-users/information-about-mr-dlib-for-jabref-users/"); } catch (IOException e) { LOGGER.error("Error opening the browser to Mr. DLib information page.", e); dialogService.showErrorDialogAndWait(e); } }); VBox vb = new VBox(); CheckBox cbTitle = new CheckBox(Localization.lang("Entry Title (Required to deliver recommendations.)")); cbTitle.setSelected(true); cbTitle.setDisable(true); CheckBox cbVersion = new CheckBox(Localization.lang("JabRef Version (Required to ensure backwards compatibility with Mr. DLib's Web Service)")); cbVersion.setSelected(true); cbVersion.setDisable(true); CheckBox cbLanguage = new CheckBox(Localization.lang("JabRef Language (Provides for better recommendations by giving an indication of user's preferred language.)")); CheckBox cbOS = new CheckBox(Localization.lang("Operating System (Provides for better recommendations by giving an indication of user's system set-up.)")); CheckBox cbTimezone = new CheckBox(Localization.lang("Timezone (Provides for better recommendations by indicating the time of day the request is being made.)")); vb.getChildren().addAll(cbTitle, cbVersion, cbLanguage, cbOS, cbTimezone); vb.setSpacing(10);  button.setOnAction(event -> { JabRefPreferences prefs = JabRefPreferences.getInstance(); prefs.putBoolean(JabRefPreferences.ACCEPT_RECOMMENDATIONS, true); prefs.putBoolean(JabRefPreferences.SEND_LANGUAGE_DATA, cbLanguage.isSelected()); prefs.putBoolean(JabRefPreferences.SEND_OS_DATA, cbOS.isSelected()); prefs.putBoolean(JabRefPreferences.SEND_TIMEZONE_DATA, cbTimezone.isSelected()); dialogService.showWarningDialogAndWait(Localization.lang("Restart"), Localization.lang("Please restart JabRef for preferences to take effect.")); setContent(getRelatedArticlesPane(entry)); });  vbox.getChildren().addAll(line1, line2, mdlLink, line3, vb, button); root.setContent(vbox);  return root; }  @Override public boolean shouldShow(BibEntry entry) { return preferences.shouldShowRecommendationsTab(); }  @Override protected void bindToEntry(BibEntry entry) { // Ask for consent to send data to Mr. DLib on first time to tab if (preferences.isMrdlibAccepted()) { setContent(getRelatedArticlesPane(entry)); } else { setContent(getPrivacyDialog(entry)); } } }"

"public class TemporalAccessorPicker extends DatePicker { private ObjectProperty<TemporalAccessor> temporalAccessorValue = new SimpleObjectProperty<>(null);  private DateTimeFormatter defaultFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"); private ObjectProperty<StringConverter<TemporalAccessor>> converter = new SimpleObjectProperty<StringConverter<TemporalAccessor>>(null);  public TemporalAccessorPicker() { setConverter(new InternalConverter());  // Synchronize changes of the underlying date value with the temporalAccessorValue BindingsHelper.bindBidirectional(valueProperty(), temporalAccessorValue, TemporalAccessorPicker::addCurrentTime, TemporalAccessorPicker::getDate); }  private static TemporalAccessor addCurrentTime(LocalDate date) { if (date == null) { return null; } return LocalDateTime.of(date, LocalTime.now()); }  private static LocalDate getDate(TemporalAccessor temporalAccessor) { if (temporalAccessor == null) { return null; }  return getLocalDate(temporalAccessor); }  private static LocalDate getLocalDate(TemporalAccessor dateTime) { // Try to get as much information from the temporal accessor LocalDate date = dateTime.query(TemporalQueries.localDate()); if (date != null) { return date; }  try { return YearMonth.from(dateTime).atDay(1); } catch (DateTimeException exception) { return Year.from(dateTime).atDay(1); } }  public final ObjectProperty<StringConverter<TemporalAccessor>> stringConverterProperty() { return converter; }  public final StringConverter<TemporalAccessor> getStringConverter() { StringConverter<TemporalAccessor> converter = stringConverterProperty().get(); if (converter != null) { return converter; } else { return new StringConverter<TemporalAccessor>() { @Override public String toString(TemporalAccessor value) { return defaultFormatter.format(value); }  @Override public TemporalAccessor fromString(String value) { return LocalDateTime.parse(value, defaultFormatter); } }; } }  public final void setStringConverter(StringConverter<TemporalAccessor> value) { stringConverterProperty().set(value); }  public TemporalAccessor getTemporalAccessorValue() { return temporalAccessorValue.get(); }  public void setTemporalAccessorValue(TemporalAccessor temporalAccessorValue) { this.temporalAccessorValue.set(temporalAccessorValue); }  public ObjectProperty<TemporalAccessor> temporalAccessorValueProperty() { return temporalAccessorValue; }  private class InternalConverter extends StringConverter<LocalDate> { public String toString(LocalDate object) { TemporalAccessor value = getTemporalAccessorValue(); return (value != null) ? getStringConverter().toString(value) : ""; }  public LocalDate fromString(String value) { if (value == null || value.isEmpty()) { temporalAccessorValue.set(null); return null; }  TemporalAccessor dateTime = getStringConverter().fromString(value); temporalAccessorValue.set(dateTime); return getLocalDate(dateTime); } } }"
"public abstract class SimpleCommand extends CommandBase {  protected ReadOnlyStringWrapper statusMessage = new ReadOnlyStringWrapper("");  public String getStatusMessage() { return statusMessage.get(); }  public ReadOnlyStringProperty statusMessageProperty() { return statusMessage.getReadOnlyProperty(); }  @Override public double getProgress() { return 0; }  @Override public ReadOnlyDoubleProperty progressProperty() { return null; }  public void setExecutable(boolean executable) { this.executable.bind(BindingsHelper.constantOf(executable)); } }"



"public class AbbreviationViewModel {  private final Abbreviation abbreviationObject; private final StringProperty name = new SimpleStringProperty(""); private final StringProperty abbreviation = new SimpleStringProperty(""); private final BooleanProperty pseudoAbbreviation = new SimpleBooleanProperty();   public AbbreviationViewModel(Abbreviation abbreviation) { this.abbreviationObject = abbreviation; pseudoAbbreviation.set(this.abbreviationObject == null); if (this.abbreviationObject != null) { this.name.bindBidirectional(this.abbreviationObject.nameProperty()); this.abbreviation.bindBidirectional(this.abbreviationObject.abbreviationProperty()); } else { this.name.set("Add new Abbreviation"); } }  public Abbreviation getAbbreviationObject() { return this.abbreviationObject; }  public void setName(String name) { this.name.set(name); }  public void setAbbreviation(String abbreviation) { this.abbreviation.set(abbreviation); }  public String getName() { return this.name.get(); }  public String getAbbreviation() { return this.abbreviation.get(); }  public boolean isPseudoAbbreviation() { return this.pseudoAbbreviation.get(); }  public StringProperty nameProperty() { return this.name; }  public StringProperty abbreviationProperty() { return this.abbreviation; }  public BooleanProperty isPseudoAbbreviationProperty() { return this.pseudoAbbreviation; }  @Override public int hashCode() { return Objects.hash(abbreviationObject); }  @Override public boolean equals(Object obj) { if (obj instanceof AbbreviationViewModel) { return Objects.equals(this.abbreviationObject, ((AbbreviationViewModel) obj).abbreviationObject); } else { return false; } } }"


"public enum DroppingMouseLocation { BOTTOM, CENTER, TOP }"
"public void storeSettings() { // Set the default value: Globals.prefs.put(JabRefPreferences.DEFAULT_BIBTEX_KEY_PATTERN, defaultPat.getText()); Globals.prefs.putBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY, warnBeforeOverwriting.isSelected()); Globals.prefs.putBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY, dontOverwrite.isSelected());  Globals.prefs.put(JabRefPreferences.KEY_PATTERN_REGEX, keyPatternRegex.getText()); Globals.prefs.put(JabRefPreferences.KEY_PATTERN_REPLACEMENT, keyPatternReplacement.getText()); Globals.prefs.putBoolean(JabRefPreferences.GENERATE_KEYS_BEFORE_SAVING, generateOnSave.isSelected());  if (alwaysAddLetter.isSelected()) { Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, true); } else if (letterStartA.isSelected()) { Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A, true); Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, false); } else { Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A, false); Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, false); }  // fetch entries from GUI GlobalBibtexKeyPattern keypatterns = getKeyPatternAsGlobalBibtexKeyPattern(); // store new patterns globally prefs.putKeyPattern(keypatterns); }"

"public class UnlinkedFilesCrawler extends BackgroundTask<CheckBoxTreeItem<FileNodeWrapper>> {  private final Path directory; private final FileFilter fileFilter; private int counter; private final BibDatabaseContext databaseContext;  public UnlinkedFilesCrawler(Path directory, FileFilter fileFilter, BibDatabaseContext databaseContext) { this.directory = directory; this.fileFilter = fileFilter; this.databaseContext = databaseContext; }  @Override protected CheckBoxTreeItem<FileNodeWrapper> call() { UnlinkedPDFFileFilter unlinkedPDFFileFilter = new UnlinkedPDFFileFilter(fileFilter, databaseContext); return searchDirectory(directory.toFile(), unlinkedPDFFileFilter); }  /** * Searches recursively all files in the specified directory. <br> * <br> * All files matched by the given {@link UnlinkedPDFFileFilter} are taken into the resulting tree. <br> * <br> * The result will be a tree structure of nodes of the type * {@link CheckBoxTreeItem}. <br> * <br> * The user objects that are attached to the nodes is the * {@link FileNodeWrapper}, which wraps the {@link File}-Object. <br> * <br> * For ensuring the capability to cancel the work of this recursive method, * the first position in the integer array 'state' must be set to 1, to keep * the recursion running. When the states value changes, the method will * resolve its recursion and return what it has saved so far. */ private CheckBoxTreeItem<FileNodeWrapper> searchDirectory(File directory, UnlinkedPDFFileFilter ff) { // Return null if the directory is not valid. if ((directory == null) || !directory.exists() || !directory.isDirectory()) { return null; }  File[] filesArray = directory.listFiles(ff); List<File> files; if (filesArray == null) { files = Collections.emptyList(); } else { files = Arrays.asList(filesArray); } CheckBoxTreeItem<FileNodeWrapper> root = new CheckBoxTreeItem<>(new FileNodeWrapper(directory.toPath(), 0));  int filesCount = 0;  filesArray = directory.listFiles(pathname -> (pathname != null) && pathname.isDirectory()); List<File> subDirectories; if (filesArray == null) { subDirectories = Collections.emptyList(); } else { subDirectories = Arrays.asList(filesArray); } for (File subDirectory : subDirectories) { if (isCanceled()) { return root; }  CheckBoxTreeItem<FileNodeWrapper> subRoot = searchDirectory(subDirectory, ff); if ((subRoot != null) && (!subRoot.getChildren().isEmpty())) { filesCount += subRoot.getValue().fileCount; root.getChildren().add(subRoot); } }  root.setValue(new FileNodeWrapper(directory.toPath(), files.size() + filesCount));  for (File file : files) { root.getChildren().add(new CheckBoxTreeItem<>(new FileNodeWrapper(file.toPath())));  counter++; if (counter == 1) { updateMessage(Localization.lang("One file found")); } else { updateMessage(Localization.lang("%0 files found", Integer.toString(counter))); } }  return root; } }"


"public List<BasePanel> getBasePanelList() { List<BasePanel> returnList = new ArrayList<>(); for (int i = 0; i < getBasePanelCount(); i++) { returnList.add(getBasePanelAt(i)); } return returnList; }"

"private ScrollPane getRelatedArticleInfo(List<BibEntry> list, MrDLibFetcher fetcher) { ScrollPane scrollPane = new ScrollPane();  VBox vBox = new VBox(); vBox.setSpacing(20.0);  String heading = fetcher.getHeading(); Text headingText = new Text(heading); headingText.getStyleClass().add("recommendation-heading"); String description = fetcher.getDescription(); Text descriptionText = new Text(description); descriptionText.getStyleClass().add("recommendation-description"); vBox.getChildren().add(headingText); vBox.getChildren().add(descriptionText);  for (BibEntry entry : list) { HBox hBox = new HBox(); hBox.setSpacing(5.0); hBox.getStyleClass().add("recommendation-item");  String title = entry.getTitle().orElse(""); String journal = entry.getField(StandardField.JOURNAL).orElse(""); String authors = entry.getField(StandardField.AUTHOR).orElse(""); String year = entry.getField(StandardField.YEAR).orElse("");  Hyperlink titleLink = new Hyperlink(title); Text journalText = new Text(journal); journalText.setFont(Font.font(Font.getDefault().getFamily(), FontPosture.ITALIC, Font.getDefault().getSize())); Text authorsText = new Text(authors); Text yearText = new Text("(" + year + ")"); titleLink.setOnAction(event -> { if (entry.getField(StandardField.URL).isPresent()) { try { JabRefDesktop.openBrowser(entry.getField(StandardField.URL).get()); } catch (IOException e) { LOGGER.error("Error opening the browser to: " + entry.getField(StandardField.URL).get(), e); dialogService.showErrorDialogAndWait(e); } } });  hBox.getChildren().addAll(titleLink, journalText, authorsText, yearText); vBox.getChildren().add(hBox); } scrollPane.setContent(vBox); return scrollPane; }"

"public List<String> refreshCiteMarkers(List<BibDatabase> databases, OOBibStyle style)"


"private void openFile(Path filePath) { AbbreviationsFileViewModel abbreviationsFile = new AbbreviationsFileViewModel(filePath); if (journalFiles.contains(abbreviationsFile)) { dialogService.showErrorDialogAndWait(Localization.lang("Duplicated Journal File"), Localization.lang("Journal file %s already added", filePath.toString())); return; } if (abbreviationsFile.exists()) { try { abbreviationsFile.readAbbreviations(); } catch (FileNotFoundException e) { logger.debug(e.getLocalizedMessage()); } } journalFiles.add(abbreviationsFile); }"


"public class ContentSelectorSuggestionProvider implements AutoCompleteSuggestionProvider<String> {  private final AutoCompleteSuggestionProvider<String> suggestionProvider; private final List<String> contentSelectorValues;  public ContentSelectorSuggestionProvider(AutoCompleteSuggestionProvider<String> suggestionProvider, List<String> contentSelectorValues) {  this.suggestionProvider = suggestionProvider; this.contentSelectorValues = contentSelectorValues; }  @Override public Collection<String> call(AutoCompletionBinding.ISuggestionRequest request) { List<String> suggestions = new ArrayList<>(); if (suggestionProvider != null) { suggestions.addAll(suggestionProvider.call(request)); } suggestions.addAll(contentSelectorValues); return suggestions; }  @Override public void indexEntry(BibEntry entry) { suggestionProvider.indexEntry(entry); } }"





"public void append(LogEvent rawEvent) { ApplicationInsightsLogEvent event = new ApplicationInsightsLogEvent(rawEvent);  Telemetry telemetry; if (event.isException()) { ExceptionTelemetry exceptionTelemetry = new ExceptionTelemetry(event.getException()); exceptionTelemetry.getProperties().put("Message", rawEvent.getMessage().getFormattedMessage()); exceptionTelemetry.setSeverityLevel(event.getNormalizedSeverityLevel()); telemetry = exceptionTelemetry; } else { TraceTelemetry traceTelemetry = new TraceTelemetry(event.getMessage()); traceTelemetry.setSeverityLevel(event.getNormalizedSeverityLevel()); telemetry = traceTelemetry; } telemetry.getContext().getProperties().putAll(event.getCustomParameters());  Globals.getTelemetryClient().ifPresent(client -> client.track(telemetry)); }"




"public class CitationStyleToClipboardWorker {  private static final Logger LOGGER = LoggerFactory.getLogger(CitationStyleToClipboardWorker.class);  private final BasePanel basePanel; private final List<BibEntry> selectedEntries; private final PreviewLayout style; private final String previewStyle; private final CitationStyleOutputFormat outputFormat; private final DialogService dialogService; private final ClipBoardManager clipBoardManager;  public CitationStyleToClipboardWorker(BasePanel basePanel, CitationStyleOutputFormat outputFormat, DialogService dialogService, ClipBoardManager clipBoardManager, PreviewPreferences previewPreferences) { this.basePanel = basePanel; this.selectedEntries = basePanel.getSelectedEntries(); this.style = previewPreferences.getCurrentPreviewStyle(); this.previewStyle = previewPreferences.getPreviewStyle(); this.outputFormat = outputFormat; this.clipBoardManager = clipBoardManager; this.dialogService = dialogService; }  public void copyCitationStyleToClipboard(TaskExecutor taskExecutor) { BackgroundTask.wrap(this::generateCitations) .onFailure(ex -> LOGGER.error("Error while copying citations to the clipboard", ex)) .onSuccess(this::setClipBoardContent) .executeWith(taskExecutor); }  private List<String> generateCitations() throws IOException { // This worker stored the style as filename. The CSLAdapter and the CitationStyleCache store the source of the // style. Therefore, we extract the style source from the file. String styleSource = null; if (style instanceof CitationStylePreviewLayout) { styleSource = ((CitationStylePreviewLayout) style).getSource(); } if (styleSource != null) { return CitationStyleGenerator.generateCitations(selectedEntries, styleSource, outputFormat); } else { StringReader sr = new StringReader(previewStyle.replace("__NEWLINE__", "\n")); LayoutFormatterPreferences layoutFormatterPreferences = Globals.prefs.getLayoutFormatterPreferences(Globals.journalAbbreviationLoader); Layout layout = new LayoutHelper(sr, layoutFormatterPreferences).getLayoutFromText();  List<String> citations = new ArrayList<>(selectedEntries.size()); for (BibEntry entry : selectedEntries) { citations.add(layout.doLayout(entry, basePanel.getDatabase())); } return citations; } }  /** * Generates a plain text string out of the preview and copies it additionally to the html to the clipboard * (WYSIWYG Editors use the HTML, plain text editors the text) */ protected static String processPreview(List<String> citations) { return String.join(CitationStyleOutputFormat.HTML.getLineSeparator(), citations); }  /** * Joins every citation with a newline and returns it. */ protected static ClipboardContent processText(List<String> citations) { ClipboardContent content = new ClipboardContent(); content.putString(String.join(CitationStyleOutputFormat.TEXT.getLineSeparator(), citations)); return content; }  /** * Converts the citations into the RTF format. */ protected static ClipboardContent processRtf(List<String> citations) { String result = "{\\rtf" + OS.NEWLINE + String.join(CitationStyleOutputFormat.RTF.getLineSeparator(), citations) + "}"; ClipboardContent content = new ClipboardContent(); content.putRtf(result); return content; }  /** * Inserts each citation into a XLSFO body and copies it to the clipboard */ protected static ClipboardContent processXslFo(List<String> citations) { String result = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + OS.NEWLINE + "<fo:root xmlns:fo=\"http://www.w3.org/1999/XSL/Format\">" + OS.NEWLINE + "   <fo:layout-master-set>" + OS.NEWLINE + "      <fo:simple-page-master master-name=\"citations\">" + OS.NEWLINE + "         <fo:region-body/>" + OS.NEWLINE + "      </fo:simple-page-master>" + OS.NEWLINE + "   </fo:layout-master-set>" + OS.NEWLINE + "   <fo:page-sequence master-reference=\"citations\">" + OS.NEWLINE + "      <fo:flow flow-name=\"xsl-region-body\">" + OS.NEWLINE + OS.NEWLINE;  result += String.join(CitationStyleOutputFormat.XSL_FO.getLineSeparator(), citations);  result += OS.NEWLINE + "      </fo:flow>" + OS.NEWLINE + "   </fo:page-sequence>" + OS.NEWLINE + "</fo:root>" + OS.NEWLINE;  ClipboardContent content = new ClipboardContent(); content.put(ClipBoardManager.XML, result); return content; }  /** * Inserts each citation into a HTML body and copies it to the clipboard */ protected static ClipboardContent processHtml(List<String> citations) { String result = "<!DOCTYPE html>" + OS.NEWLINE + "<html>" + OS.NEWLINE + "   <head>" + OS.NEWLINE + "      <meta charset=\"utf-8\">" + OS.NEWLINE + "   </head>" + OS.NEWLINE + "   <body>" + OS.NEWLINE + OS.NEWLINE;  result += String.join(CitationStyleOutputFormat.HTML.getLineSeparator(), citations); result += OS.NEWLINE + "   </body>" + OS.NEWLINE + "</html>" + OS.NEWLINE;  ClipboardContent content = new ClipboardContent(); content.putHtml(result); return content; }  private void setClipBoardContent(List<String> citations) { // if it's not a citation style take care of the preview if (!(style instanceof CitationStylePreviewLayout)) { clipBoardManager.setHtmlContent(processPreview(citations)); } else { // if it's generated by a citation style take care of each output format ClipboardContent content; switch (outputFormat) { case HTML: content = processHtml(citations); break; case RTF: content = processRtf(citations); break; case XSL_FO: content = processXslFo(citations); break; case ASCII_DOC: case TEXT: content = processText(citations); break; default: LOGGER.warn("unknown output format: '" + outputFormat + "', processing it via the default."); content = processText(citations); break; } clipBoardManager.setContent(content); }  dialogService.notify(Localization.lang("Copied %0 citations.", String.valueOf(selectedEntries.size()))); }  }"
"public class CustomExternalFileType implements ExternalFileType {  private String name; private String extension; private String openWith; private String iconName; private String mimeType; private JabRefIcon icon;  public CustomExternalFileType(String name, String extension, String mimeType, String openWith, String iconName, JabRefIcon icon) { this.name = name; this.extension = extension; this.mimeType = mimeType; this.openWith = openWith;  setIconName(iconName); setIcon(icon); }  public CustomExternalFileType(ExternalFileType type) { this(type.getName(), type.getExtension(), type.getMimeType(), type.getOpenWithApplication(), "", type.getIcon()); }  /** * Construct an ExternalFileType from a String array. This is used when * reading file type definitions from Preferences, where the available data types are * limited. We assume that the array contains the same values as the main constructor, * in the same order. * * @param val arguments. */ public static ExternalFileType buildFromArgs(String[] val) { if ((val == null) || (val.length < 4) || (val.length > 5)) { throw new IllegalArgumentException("Cannot construct ExternalFileType without four elements in String[] argument."); } String name = val[0]; String extension = val[1]; String openWith; String mimeType; String iconName;  if (val.length == 4) { // Up to version 2.4b the mime type is not included: mimeType = ""; openWith = val[2]; iconName = val[3]; } else { // When mime type is included, the array length should be 5: mimeType = val[2]; openWith = val[3]; iconName = val[4]; }  // set icon to default first JabRefIcon icon = IconTheme.JabRefIcons.FILE;  // check whether there is another icon defined for this file type for (ExternalFileType fileType : ExternalFileTypes.getDefaultExternalFileTypes()) { if (fileType.getName().equals(name)) { icon = fileType.getIcon(); break; } }  return new CustomExternalFileType(name, extension, mimeType, openWith, iconName, icon); }  @Override public String getName() { return name; }  public void setName(String name) { this.name = name; }  @Override public String getExtension() { if (extension == null) { return ""; } return extension; }  public void setExtension(String extension) { this.extension = extension; }  @Override public String getMimeType() { if (mimeType == null) { return ""; } return mimeType; }  public void setMimeType(String mimeType) { this.mimeType = mimeType; }  @Override public String getOpenWithApplication() { if (openWith == null) { return ""; } return openWith; }  public void setOpenWith(String openWith) { this.openWith = openWith; }  /** * Get the string associated with this file type's icon. * * @return The icon name. */ public String getIconName() { return iconName; }  /** * Set the string associated with this file type's icon. * * @param name The icon name to use. */ public void setIconName(String name) { this.iconName = name; }  @Override public JabRefIcon getIcon() { return icon; }  public void setIcon(JabRefIcon icon) { Objects.requireNonNull(icon); this.icon = icon; }  @Override public String toString() { return getName(); }  public ExternalFileType copy() { return new CustomExternalFileType(name, extension, mimeType, openWith, iconName, icon); }  @Override public int hashCode() { return Objects.hash(name, extension, mimeType, openWith, iconName); }  /** * We define two file type objects as equal if their name, extension, openWith and * iconName are equal. * * @param object The file type to compare with. * @return true if the file types are equal. */ @Override public boolean equals(Object object) { if (this == object) { return true; }  if (object instanceof CustomExternalFileType) { CustomExternalFileType other = (CustomExternalFileType) object; return Objects.equals(name, other.name) && Objects.equals(extension, other.extension) && Objects.equals(mimeType, other.mimeType) && Objects.equals(openWith, other.openWith) && Objects.equals(iconName, other.iconName); } return false; } }"


"public class UnlinkedPDFFileFilter implements FileFilter {  private final DatabaseFileLookup lookup; private final FileFilter fileFilter;   public UnlinkedPDFFileFilter(FileFilter fileFilter, BibDatabaseContext databaseContext) { this.fileFilter = fileFilter; this.lookup = new DatabaseFileLookup(databaseContext, Globals.prefs.getFilePreferences()); }  @Override public boolean accept(File pathname) { return fileFilter.accept(pathname) && !lookup.lookupDatabase(pathname); } }"

"public enum AutoCompleteFirstNameMode { ONLY_FULL, ONLY_ABBREVIATED, BOTH;  public static AutoCompleteFirstNameMode parse(String input) { try { return AutoCompleteFirstNameMode.valueOf(input); } catch (IllegalArgumentException ex) { // Should only occur when preferences are set directly via preferences.put and not via setFirstnameMode return AutoCompleteFirstNameMode.BOTH; } } }"
"private List<Integer> findCitedEntryIndex(String citRefName, List<String> keys) { Matcher citeMatcher = CITE_PATTERN.matcher(citRefName); if (citeMatcher.find()) { List<String> keyStrings = Arrays.asList(citeMatcher.group(2).split(",")); List<Integer> result = new ArrayList<>(keyStrings.size()); for (String key : keyStrings) { int ind = keys.indexOf(key); result.add(ind == -1 ? -1 : 1 + ind); } return result; } else { return Collections.emptyList(); } }"

"public class ManageJournalAbbreviationsViewModel extends AbstractViewModel {  private final Logger logger = LoggerFactory.getLogger(ManageJournalAbbreviationsViewModel.class); private final SimpleListProperty<AbbreviationsFileViewModel> journalFiles = new SimpleListProperty<>(FXCollections.observableArrayList()); private final SimpleListProperty<AbbreviationViewModel> abbreviations = new SimpleListProperty<>(FXCollections.observableArrayList()); private final SimpleIntegerProperty abbreviationsCount = new SimpleIntegerProperty(); private final SimpleObjectProperty<AbbreviationsFileViewModel> currentFile = new SimpleObjectProperty<>(); private final SimpleObjectProperty<AbbreviationViewModel> currentAbbreviation = new SimpleObjectProperty<>(); private final SimpleBooleanProperty isFileRemovable = new SimpleBooleanProperty(); private final SimpleBooleanProperty isLoading = new SimpleBooleanProperty(false); private final SimpleBooleanProperty isLoadingBuiltIn = new SimpleBooleanProperty(false); private final SimpleBooleanProperty isLoadingIeee = new SimpleBooleanProperty(false); private final SimpleBooleanProperty isAbbreviationEditableAndRemovable = new SimpleBooleanProperty(); private final PreferencesService preferences; private final DialogService dialogService; private final TaskExecutor taskExecutor; private final JournalAbbreviationPreferences abbreviationsPreferences; private final JournalAbbreviationLoader journalAbbreviationLoader; private boolean shouldWriteLists = false;  public ManageJournalAbbreviationsViewModel(PreferencesService preferences, DialogService dialogService, TaskExecutor taskExecutor, JournalAbbreviationLoader journalAbbreviationLoader) { this.preferences = Objects.requireNonNull(preferences); this.dialogService = Objects.requireNonNull(dialogService); this.taskExecutor = Objects.requireNonNull(taskExecutor); this.journalAbbreviationLoader = Objects.requireNonNull(journalAbbreviationLoader); this.abbreviationsPreferences = preferences.getJournalAbbreviationPreferences();  abbreviationsCount.bind(abbreviations.sizeProperty()); currentAbbreviation.addListener((observable, oldvalue, newvalue) -> { boolean isAbbreviation = (newvalue != null) && !newvalue.isPseudoAbbreviation(); boolean isEditableFile = (currentFile.get() != null) && !currentFile.get().isBuiltInListProperty().get(); isAbbreviationEditableAndRemovable.set(isAbbreviation && isEditableFile); }); currentFile.addListener((observable, oldvalue, newvalue) -> { if (oldvalue != null) { abbreviations.unbindBidirectional(oldvalue.abbreviationsProperty()); currentAbbreviation.set(null); } if (newvalue != null) { isFileRemovable.set(!newvalue.isBuiltInListProperty().get()); abbreviations.bindBidirectional(newvalue.abbreviationsProperty()); if (abbreviations.size() > 0) { currentAbbreviation.set(abbreviations.get(abbreviations.size() - 1)); } } else { isFileRemovable.set(false); if (!journalFiles.isEmpty()) { currentFile.set(journalFiles.get(0)); } else { currentAbbreviation.set(null); abbreviations.clear(); } } }); journalFiles.addListener((ListChangeListener<AbbreviationsFileViewModel>) c -> { if (c.next()) { if (!c.wasReplaced()) { if (c.wasAdded() && !c.getAddedSubList().get(0).isBuiltInListProperty().get()) { currentFile.set(c.getAddedSubList().get(0)); } } } }); isLoading.bind(isLoadingBuiltIn.or(isLoadingIeee)); }  public SimpleBooleanProperty isLoadingProperty() { return isLoading; }  public boolean isAbbreviationEditableAndRemovable() { return isAbbreviationEditableAndRemovable.get(); }  /** * This will wrap the built in and ieee abbreviations in pseudo abbreviation files * and add them to the list of journal abbreviation files. */ void addBuiltInLists() { BackgroundTask .wrap(JournalAbbreviationLoader::getBuiltInAbbreviations) .onRunning(() -> isLoadingBuiltIn.setValue(true)) .onSuccess(result -> { isLoadingBuiltIn.setValue(false); addList(Localization.lang("JabRef built in list"), result); selectLastJournalFile(); }) .onFailure(dialogService::showErrorDialogAndWait) .executeWith(taskExecutor);  BackgroundTask .wrap(() -> { if (abbreviationsPreferences.useIEEEAbbreviations()) { return JournalAbbreviationLoader.getOfficialIEEEAbbreviations(); } else { return JournalAbbreviationLoader.getStandardIEEEAbbreviations(); } }) .onRunning(() -> isLoadingIeee.setValue(true)) .onSuccess(result -> { isLoadingIeee.setValue(false); addList(Localization.lang("IEEE built in list"), result); }) .onFailure(dialogService::showErrorDialogAndWait) .executeWith(taskExecutor); }  private void addList(String name, List<Abbreviation> abbreviations) { List<AbbreviationViewModel> builtInListViewModel = new ArrayList<>(); abbreviations.forEach(abbreviation -> builtInListViewModel.add(new AbbreviationViewModel(abbreviation))); AbbreviationsFileViewModel fileViewModel = new AbbreviationsFileViewModel(builtInListViewModel, name); journalFiles.add(fileViewModel); }  /** * Read all saved file paths and read their abbreviations */ public void createFileObjects() { List<String> externalFiles = abbreviationsPreferences.getExternalJournalLists(); externalFiles.forEach(name -> openFile(Paths.get(name))); }  /** * This method shall be used to add a new journal abbreviation file to the * set of journal abbreviation files. It basically just calls the * {@link #openFile(Path)}} method"
"public void show(SidePaneType type) { SidePaneComponent component = getComponent(type); if (!visibleComponents.contains(component)) { // Add the new component visibleComponents.add(component);  // Sort the visible components by their preferred position visibleComponents.sort(new PreferredIndexSort());  updateView();  component.afterOpening(); } }"





"public void installCss(Scene scene, JabRefPreferences preferences) { addAndWatchForChanges(scene, JabRefFrame.class.getResource(MAIN_CSS), 0); additionalCssToLoad.ifPresent(file -> addAndWatchForChanges(scene, file, 1));  preferences.getFontSize().ifPresent(size -> scene.getRoot().setStyle("-fx-font-size: " + size + "pt;")); }"


"private final Version installedVersion;"

"public void setupAllTables() { // This action can be invoked without an open database, so // we have to check if we have one before trying to invoke // methods to execute changes in the preferences.  // We want to notify all tabs about the changes to // avoid problems when changing the column set. for (int i = 0; i < tabbedPane.getTabs().size(); i++) { BasePanel bf = getBasePanelAt(i);  // Update tables: if (bf.getDatabase() != null) { DefaultTaskExecutor.runInJavaFXThread(bf::setupMainPanel); } } }"









"private final int m_subtreeRootChildCount;"
"private static UndoableEdit massRenameField(Collection<BibEntry> entries, Field field, Field newField, boolean overwriteValues) { NamedCompound compoundEdit = new NamedCompound(Localization.lang("Rename field")); for (BibEntry entry : entries) { Optional<String> valToMove = entry.getField(field); // If there is no value, do nothing: if ((!valToMove.isPresent()) || valToMove.get().isEmpty()) { continue; } // If we are not allowed to overwrite values, check if there is a // non-empty value already for this entry for the new field: Optional<String> valInNewField = entry.getField(newField); if (!overwriteValues && (valInNewField.isPresent()) && !valInNewField.get().isEmpty()) { continue; } entry.setField(newField, valToMove.get()); compoundEdit.addEdit(new UndoableFieldChange(entry, newField, valInNewField.orElse(null), valToMove.get())); entry.clearField(field); compoundEdit.addEdit(new UndoableFieldChange(entry, field, valToMove.get(), null)); compoundEdit.end(); return compoundEdit; }"
"public static final int ADD_NODE = 0;"
"public boolean dragDropped(ListProperty<PreviewLayout> targetList, Dragboard dragboard) { boolean success = false;  if (dragboard.hasContent(DragAndDropDataFormats.PREVIEWLAYOUTS)) { List<PreviewLayout> draggedLayouts = localDragboard.getPreviewLayouts(); if (!draggedLayouts.isEmpty()) { dragSourceList.getValue().removeAll(draggedLayouts); targetList.getValue().addAll(draggedLayouts); success = true;  if (targetList == availableListProperty) { targetList.getValue().sort((a, b) -> a.getName().compareToIgnoreCase(b.getName())); } } }  return success; }"

"public <V> Future<V> execute(BackgroundTask<V> task) { Runnable onRunning = task.getOnRunning(); if (onRunning != null) { onRunning.run(); } try { final V result = task.call(); Consumer<V> onSuccess = task.getOnSuccess(); if (onSuccess != null) { onSuccess.accept(result); } return CompletableFuture.completedFuture(result); } catch (Exception exception) { Consumer<Exception> onException = task.getOnException(); if (onException != null) { onException.accept(exception); } else { LOGGER.error("Unhandled exception", exception); } return new FailedFuture<>(exception); } }"
"public String getDefaultKeyBinding() { return defaultBinding; }"






"public <T> BackgroundTask<T> thenRun(Function<V, T> nextOperation) { return new BackgroundTask<T>() { @Override protected T call() throws Exception { V result = BackgroundTask.this.call(); BackgroundTask<T> nextTask = BackgroundTask.wrap(() -> nextOperation.apply(result)); EasyBind.subscribe(nextTask.progressProperty(), this::updateProgress); return nextTask.call(); } }; }"
"public class CheckForNewEntryTypesAction implements GUIPostOpenAction {  @Override public boolean isActionNecessary(ParserResult parserResult) { return !getListOfUnknownAndUnequalCustomizations(parserResult).isEmpty(); }  @Override public void performAction(BasePanel panel, ParserResult parserResult) { BibDatabaseMode mode = getBibDatabaseModeFromParserResult(parserResult);  ImportCustomEntryTypesDialog importBibEntryTypesDialog = new ImportCustomEntryTypesDialog(mode, getListOfUnknownAndUnequalCustomizations(parserResult)); importBibEntryTypesDialog.showAndWait();  }  private List<BibEntryType> getListOfUnknownAndUnequalCustomizations(ParserResult parserResult) { BibDatabaseMode mode = getBibDatabaseModeFromParserResult(parserResult);  return parserResult.getEntryTypes() .stream() .filter(type -> Globals.entryTypesManager.isCustomizedType(type, mode)) .collect(Collectors.toList()); }  private BibDatabaseMode getBibDatabaseModeFromParserResult(ParserResult parserResult) { return parserResult.getMetaData().getMode().orElse(Globals.prefs.getDefaultBibDatabaseMode()); } }"
"private void openTheFile(Path file, boolean raisePanel) { Objects.requireNonNull(file); if (Files.exists(file)) {  BackgroundTask.wrap(() -> loadDatabase(file)) .onSuccess(result -> { BasePanel panel = addNewDatabase(result, file, raisePanel); OpenDatabaseAction.performPostOpenActions(panel, result); }) .onFailure(ex -> dialogService.showErrorDialogAndWait(Localization.lang("Connection error"), ex.getMessage() + "\n\n" + Localization.lang("A local copy will be opened."))) .executeWith(Globals.TASK_EXECUTOR); }  }"


"public class FindFullTextAction extends SimpleCommand {  private static final Logger LOGGER = LoggerFactory.getLogger(FindFullTextAction.class); // The minimum number of selected entries to ask the user for confirmation private static final int WARNING_LIMIT = 5;  private final BasePanel basePanel; private final DialogService dialogService;  public FindFullTextAction(BasePanel basePanel) { this.basePanel = basePanel; this.dialogService = basePanel.frame().getDialogService(); }  @Override public void execute() { if (!basePanel.getSelectedEntries().isEmpty()) { basePanel.output(Localization.lang("Looking for full text document...")); } else { LOGGER.debug("No entry selected for fulltext download."); }  if (basePanel.getSelectedEntries().size() >= WARNING_LIMIT) { boolean confirmDownload = dialogService.showConfirmationDialogAndWait( Localization.lang("Look up full text documents"), Localization.lang( "You are about to look up full text documents for %0 entries.", String.valueOf(basePanel.getSelectedEntries().size())) + "\n" + Localization.lang("JabRef will send at least one request per entry to a publisher.") + "\n" + Localization.lang("Do you still want to continue?"), Localization.lang("Look up full text documents"), Localization.lang("Cancel"));  if (!confirmDownload) { basePanel.output(Localization.lang("Operation canceled.")); return; } }  Task<Map<BibEntry, Optional<URL>>> findFullTextsTask = new Task<Map<BibEntry, Optional<URL>>>() { @Override protected Map<BibEntry, Optional<URL>> call() { Map<BibEntry, Optional<URL>> downloads = new ConcurrentHashMap<>(); int count = 0; for (BibEntry entry : basePanel.getSelectedEntries()) { FulltextFetchers fetchers = new FulltextFetchers(Globals.prefs.getImportFormatPreferences()); downloads.put(entry, fetchers.findFullTextPDF(entry)); updateProgress(++count, basePanel.getSelectedEntries().size()); } return downloads; } };  findFullTextsTask.setOnSucceeded(value -> downloadFullTexts(findFullTextsTask.getValue()));  dialogService.showProgressDialogAndWait( Localization.lang("Look up full text documents"), Localization.lang("Looking for full text document..."), findFullTextsTask);  Globals.TASK_EXECUTOR.execute(findFullTextsTask); }  private void downloadFullTexts(Map<BibEntry, Optional<URL>> downloads) { for (Map.Entry<BibEntry, Optional<URL>> download : downloads.entrySet()) { BibEntry entry = download.getKey(); Optional<URL> result = download.getValue(); if (result.isPresent()) { Optional<Path> dir = basePanel.getBibDatabaseContext().getFirstExistingFileDir(Globals.prefs.getFilePreferences());  if (!dir.isPresent()) {  dialogService.showErrorDialogAndWait(Localization.lang("Directory not found"), Localization.lang("Main file directory not set!") + " " + Localization.lang("Preferences") + " -> " + Localization.lang("File")); return; } //Download and link full text addLinkedFileFromURL(result.get(), entry, dir.get());  } else { dialogService.notify(Localization.lang("No full text document found for entry %0.", entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); } } }  /** * This method attaches a linked file from a URL (if not already linked) to an entry using the key and value pair * from the findFullTexts map and then downloads the file into the given targetDirectory * * @param url   the url "key" * @param entry the entry "value" * @param targetDirectory the target directory for the downloaded file */ private void addLinkedFileFromURL(URL url, BibEntry entry, Path targetDirectory) { LinkedFile newLinkedFile = new LinkedFile(url, "");  if (!entry.getFiles().contains(newLinkedFile)) {  LinkedFileViewModel onlineFile = new LinkedFileViewModel( newLinkedFile, entry, basePanel.getBibDatabaseContext(), Globals.TASK_EXECUTOR, dialogService, JabRefPreferences.getInstance().getXMPPreferences(), JabRefPreferences.getInstance().getFilePreferences(), ExternalFileTypes.getInstance());  try { URLDownload urlDownload = new URLDownload(newLinkedFile.getLink()); BackgroundTask<Path> downloadTask = onlineFile.prepareDownloadTask(targetDirectory, urlDownload); downloadTask.onSuccess(destination -> { LinkedFile downloadedFile = LinkedFilesEditorViewModel.fromFile( destination, basePanel.getBibDatabaseContext().getFileDirectoriesAsPaths(JabRefPreferences.getInstance().getFilePreferences()), ExternalFileTypes.getInstance()); entry.addFile(downloadedFile); dialogService.notify(Localization.lang("Finished downloading full text document for entry %0.", entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); }); Globals.TASK_EXECUTOR.execute(downloadTask); } catch (MalformedURLException exception) { dialogService.showErrorDialogAndWait(Localization.lang("Invalid URL"), exception); } } else { dialogService.notify(Localization.lang("Full text document for entry %0 already linked.", entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); } } }"
"public class CustomizeExternalFileTypesDialog extends BaseDialog<Void> {  @FXML private TableColumn<ExternalFileType, JabRefIcon> fileTypesTableIconColumn; @FXML private TableColumn<ExternalFileType, String> fileTypesTableNameColumn; @FXML private TableColumn<ExternalFileType, String> fileTypesTableExtensionColumn; @FXML private TableColumn<ExternalFileType, String> fileTypesTableTypeColumn; @FXML private TableColumn<ExternalFileType, String> fileTypesTableApplicationColumn; @FXML private TableColumn<ExternalFileType, Boolean> fileTypesTableEditColumn; @FXML private TableColumn<ExternalFileType, Boolean> fileTypesTableDeleteColumn; @FXML private TableView<ExternalFileType> fileTypesTable;  private CustomizeExternalFileTypesViewModel viewModel;  public CustomizeExternalFileTypesDialog() { this.setTitle(Localization.lang("Manage external file types"));  ViewLoader.view(this) .load() .setAsDialogPane(this);  this.setResultConverter(button -> { if (button == ButtonType.OK) { viewModel.storeSettings(); } return null; }); }  @FXML public void initialize() { viewModel = new CustomizeExternalFileTypesViewModel();  fileTypesTable.setItems(viewModel.getFileTypes());  fileTypesTableIconColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().getIcon())); fileTypesTableNameColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().getName())); fileTypesTableExtensionColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().getExtension())); fileTypesTableTypeColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().getMimeType())); fileTypesTableApplicationColumn.setCellValueFactory(data -> BindingsHelper.constantOf(data.getValue().getOpenWithApplication())); fileTypesTableEditColumn.setCellValueFactory(data -> BindingsHelper.constantOf(true)); fileTypesTableDeleteColumn.setCellValueFactory(data -> BindingsHelper.constantOf(true));  new ValueTableCellFactory<ExternalFileType, JabRefIcon>() .withGraphic(JabRefIcon::getGraphicNode) .install(fileTypesTableIconColumn); new ValueTableCellFactory<ExternalFileType, Boolean>() .withGraphic(none -> IconTheme.JabRefIcons.EDIT.getGraphicNode()) .withOnMouseClickedEvent((type, none) -> event -> viewModel.edit(type)) .install(fileTypesTableEditColumn); new ValueTableCellFactory<ExternalFileType, Boolean>() .withGraphic(none -> IconTheme.JabRefIcons.REMOVE.getGraphicNode()) .withOnMouseClickedEvent((type, none) -> event -> viewModel.remove(type)) .install(fileTypesTableDeleteColumn); }  @FXML private void addNewType() { viewModel.addNewType(); fileTypesTable.getSelectionModel().selectLast(); fileTypesTable.scrollTo(viewModel.getFileTypes().size() - 1); }  @FXML private void resetToDefault() { viewModel.resetToDefaults(); } }"

"public abstract class BackgroundTask<V> { private Runnable onRunning; private Consumer<V> onSuccess; private Consumer<Exception> onException; private Runnable onFinished; private BooleanProperty isCanceled = new SimpleBooleanProperty(false); private ObjectProperty<BackgroundProgress> progress = new SimpleObjectProperty<>(new BackgroundProgress(0, 0)); private StringProperty message = new SimpleStringProperty(""); private DoubleProperty workDonePercentage = new SimpleDoubleProperty(0);  public BackgroundTask() { workDonePercentage.bind(EasyBind.map(progress, BackgroundTask.BackgroundProgress::getWorkDonePercentage)); }  public static <V> BackgroundTask<V> wrap(Callable<V> callable) { return new BackgroundTask<V>() { @Override protected V call() throws Exception { return callable.call(); } }; }  public static BackgroundTask<Void> wrap(Runnable runnable) { return new BackgroundTask<Void>() { @Override protected Void call() throws Exception { runnable.run(); return null; } }; }  private static <T> Consumer<T> chain(Runnable first, Consumer<T> second) { if (first != null) { if (second != null) { return result -> { first.run(); second.accept(result); }; } else { return result -> first.run(); } } else { return second; } }  public boolean isCanceled() { return isCanceled.get(); }  public void cancel() { this.isCanceled.set(true); }  public BooleanProperty isCanceledProperty() { return isCanceled; }  public StringProperty messageProperty() { return message; }  public double getWorkDonePercentage() { return workDonePercentage.get(); }  public DoubleProperty workDonePercentageProperty() { return workDonePercentage; }  public BackgroundProgress getProgress() { return progress.get(); }  public ObjectProperty<BackgroundProgress> progressProperty() { return progress; }  /** * Sets the {@link Runnable} that is invoked after the task is started. */ public BackgroundTask<V> onRunning(Runnable onRunning) { this.onRunning = onRunning; return this; }  /** * Sets the {@link Consumer} that is invoked after the task is successfully finished. * The consumer always runs on the JavaFX thread. */ public BackgroundTask<V> onSuccess(Consumer<V> onSuccess) { this.onSuccess = onSuccess; return this; }  protected abstract V call() throws Exception;  Runnable getOnRunning() { return onRunning; }  Consumer<V> getOnSuccess() { return chain(onFinished, onSuccess); }  Consumer<Exception> getOnException() { return chain(onFinished, onException); }  /** * Sets the {@link Consumer} that is invoked after the task has failed with an exception. * The consumer always runs on the JavaFX thread. */ public BackgroundTask<V> onFailure(Consumer<Exception> onException) { this.onException = onException; return this; }  public Future<?> executeWith(TaskExecutor taskExecutor) { return taskExecutor.execute(this); }  public Future<?> scheduleWith(TaskExecutor taskExecutor, long delay, TimeUnit unit) { return taskExecutor.schedule(this, delay, unit); }  /** * Sets the {@link Runnable} that is invoked after the task is finished, irrespectively if it was successful or * failed with an error. */ public BackgroundTask<V> onFinished(Runnable onFinished) { this.onFinished = onFinished; return this; }  /** * Creates a {@link BackgroundTask} that first runs this task and based on the result runs a second task. * * @param nextTaskFactory the function that creates the new task * @param <T>             type of the return value of the second task */ public <T> BackgroundTask<T> then(Function<V, BackgroundTask<T>> nextTaskFactory) { return new BackgroundTask<T>() { @Override protected T call() throws Exception { V result = BackgroundTask.this.call(); BackgroundTask<T> nextTask = nextTaskFactory.apply(result); EasyBind.subscribe(nextTask.progressProperty(), this::updateProgress); return nextTask.call(); } }; }  /** * Creates a {@link BackgroundTask} that first runs this task and based on the result runs a second task. * * @param nextOperation the function that performs the next operation * @param <T>           type of the return value of the second task */ public <T> BackgroundTask<T> thenRun(Function<V, T> nextOperation) { return new BackgroundTask<T>() { @Override protected T call() throws Exception { V result = BackgroundTask.this.call(); BackgroundTask<T> nextTask = BackgroundTask.wrap(() -> nextOperation.apply(result)); EasyBind.subscribe(nextTask.progressProperty(), this::updateProgress); return nextTask.call(); } }; }  /** * Creates a {@link BackgroundTask} that first runs this task and based on the result runs a second task. * * @param nextOperation the function that performs the next operation */ public BackgroundTask<Void> thenRun(Consumer<V> nextOperation) { return new BackgroundTask<Void>() { @Override protected Void call() throws Exception { V result = BackgroundTask.this.call(); BackgroundTask<Void> nextTask = BackgroundTask.wrap(() -> nextOperation.accept(result)); EasyBind.subscribe(nextTask.progressProperty(), this::updateProgress); return nextTask.call(); } }; }  protected void updateProgress(BackgroundProgress newProgress) { progress.setValue(newProgress); }  protected void updateProgress(double workDone, double max) { updateProgress(new BackgroundProgress(workDone, max)); }  protected void updateMessage(String newMessage) { message.setValue(newMessage); }  public BackgroundTask<V> withInitialMessage(String message) { updateMessage(message); return this; }  class BackgroundProgress {  private final double workDone; private final double max;  public BackgroundProgress(double workDone, double max) { this.workDone = workDone; this.max = max; }  public double getWorkDone() { return workDone; }  public double getMax() { return max; }  public double getWorkDonePercentage() { if (max == 0) { return 0; } else { return workDone / max; } } } }"
" protected abstract void bindToEntry(BibEntry entry);"



"public class AutosaveUIManager {  private static final Logger LOGGER = LoggerFactory.getLogger(AutosaveUIManager.class); private final BasePanel panel;   public AutosaveUIManager(BasePanel panel) { this.panel = panel; }  @Subscribe public void listen(@SuppressWarnings("unused") AutosaveEvent event) { try { new SaveDatabaseAction(panel, Globals.prefs, Globals.entryTypesManager).save(); } catch (Throwable e) { LOGGER.error("Problem occured while saving.", e); } } }"



"private static void ensureCorrectJavaVersion() { // Check if we are running an acceptable version of Java final BuildInfo buildInfo = Globals.BUILD_INFO; JavaVersion checker = new JavaVersion(); final boolean java9Fail = !buildInfo.isAllowJava9() && checker.isJava9(); final boolean versionFail = !checker.isAtLeast(buildInfo.getMinRequiredJavaVersion());  if (java9Fail || versionFail) { StringBuilder versionError = new StringBuilder( Localization.lang("Your current Java version (%0) is not supported. Please install version %1 or higher.", checker.getJavaVersion(), buildInfo.getMinRequiredJavaVersion()));  versionError.append("\n"); versionError.append(Localization.lang("Your Java Runtime Environment is located at %0.", checker.getJavaInstallationDirectory()));  if (!buildInfo.isAllowJava9()) { versionError.append("\n"); versionError.append(Localization.lang("Note that currently, JabRef does not run with Java 9.")); }  FXDialog alert = new FXDialog(Alert.AlertType.ERROR, Localization.lang("Error"), true); alert.setHeaderText(null); alert.setContentText(versionError.toString());  // We exit on Java 9 error since this will definitely not work if (java9Fail) { System.exit(0); } } }"


"public static Optional<String> getSuffix(final String link) { String strippedLink = link; try { // Try to strip the query string, if any, to get the correct suffix: URL url = new URL(link); if ((url.getQuery() != null) && (url.getQuery().length() < (link.length() - 1))) { strippedLink = link.substring(0, link.length() - url.getQuery().length() - 1); } } catch (MalformedURLException e) { // Don't report this error, since this getting the suffix is a non-critical // operation, and this error will be triggered and reported elsewhere. } // First see if the stripped link gives a reasonable suffix: String suffix; int strippedLinkIndex = strippedLink.lastIndexOf('.'); if ((strippedLinkIndex <= 0) || (strippedLinkIndex == (strippedLink.length() - 1))) { suffix = null; } else { suffix = strippedLink.substring(strippedLinkIndex + 1); } if (!ExternalFileTypes.getInstance().isExternalFileTypeByExt(suffix)) { // If the suffix doesn't seem to give any reasonable file type, try // with the non-stripped link: int index = link.lastIndexOf('.'); if ((index <= 0) || (index == (link.length() - 1))) { // No occurrence, or at the end // Check if there are path separators in the suffix - if so, it is definitely // not a proper suffix, so we should give up: if (strippedLink.substring(strippedLinkIndex + 1).indexOf('/') >= 1) { return Optional.empty(); } else { return Optional.of(suffix); // return the first one we found, anyway. } } else { // Check if there are path separators in the suffix - if so, it is definitely // not a proper suffix, so we should give up: if (link.substring(index + 1).indexOf('/') >= 1) { return Optional.empty(); } else { return Optional.of(link.substring(index + 1)); } } } else { return Optional.ofNullable(suffix); } }"



"public void editAbbreviation(String name, String abbreviation) { if (isAbbreviationEditableAndRemovable.get()) { Abbreviation abbreviationObject = new Abbreviation(name, abbreviation); AbbreviationViewModel abbViewModel = new AbbreviationViewModel(abbreviationObject); if (abbreviations.contains(abbViewModel)) { if (!abbViewModel.equals(currentAbbreviation.get())) { dialogService.showErrorDialogAndWait(Localization.lang("Duplicated Journal Abbreviation"), Localization.lang("Abbreviation %s for journal %s already defined.", abbreviation, name)); } else { setCurrentAbbreviationNameAndAbbreviationIfValid(name, abbreviation); } } else { setCurrentAbbreviationNameAndAbbreviationIfValid(name, abbreviation); } } }"
"private void updateMergedEntry() { // Check if the type has changed if (!identicalTypes && !typeRadioButtons.isEmpty() && typeRadioButtons.get(0).isSelected()) { mergedEntry.setType(leftEntry.getType()); } else { mergedEntry.setType(rightEntry.getType()); }  // Check the potentially different fields for (Field field : differentFields) { if (!radioButtons.containsKey(field)) { // May happen during initialization -> just ignore continue; } if (radioButtons.get(field).get(0).isSelected()) { mergedEntry.setField(field, leftEntry.getField(field).get()); // Will only happen if field exists } else if (radioButtons.get(field).get(2).isSelected()) { mergedEntry.setField(field, rightEntry.getField(field).get()); // Will only happen if field exists } else { mergedEntry.clearField(field); } } }"



"public class UndoableInsertEntry extends AbstractUndoableJabRefEdit {  private static final Logger LOGGER = LoggerFactory.getLogger(UndoableInsertEntry.class); private final BibDatabase base; private final BibEntry entry;  public UndoableInsertEntry(BibDatabase base, BibEntry entry) { this.base = base; this.entry = entry; }  @Override public String getPresentationName() { return Localization.lang("insert entry %0", StringUtil.boldHTML(entry.getCiteKeyOptional().orElse(Localization.lang("undefined")))); }  @Override public void undo() { super.undo();  // Revert the change. try { base.removeEntry(entry); } catch (Throwable ex) { LOGGER.warn("Problem to undo `insert entry`", ex); } }  @Override public void redo() { super.redo(); base.insertEntry(entry); }  }"
"public void storeSettings() { Globals.prefs.put(application.commandPathPreferenceKey, path.getText()); }"
"protected abstract boolean isMatch(T suggestion, ISuggestionRequest request);"

"public void insertEntry(List<BibEntry> entries, BibDatabase database, List<BibDatabase> allBases, OOBibStyle style, boolean inParenthesis, boolean withText, String pageInfo, boolean sync) throws IllegalArgumentException, UnknownPropertyException, NotRemoveableException, PropertyExistException, IllegalTypeException, UndefinedCharacterFormatException, WrappedTargetException, NoSuchElementException, PropertyVetoException, IOException, CreationException, BibEntryNotFoundException, UndefinedParagraphFormatException { try { XTextViewCursor xViewCursor = xViewCursorSupplier.getViewCursor(); if (entries.size() > 1) { if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) { entries.sort(yearAuthorTitleComparator); } else { entries.sort(entryComparator); } } String keyString = String.join(",", entries.stream().map(entry -> entry.getCiteKeyOptional().orElse("")).collect(Collectors.toList())); // Insert bookmark: String bName = getUniqueReferenceMarkName(keyString, withText ? inParenthesis ? OOBibBase.AUTHORYEAR_PAR : OOBibBase.AUTHORYEAR_INTEXT : OOBibBase.INVISIBLE_CIT); // If we should store metadata for page info, do that now: if (pageInfo != null) { LOGGER.info("Storing page info: " + pageInfo); setCustomProperty(bName, pageInfo); } xViewCursor.getText().insertString(xViewCursor, " ", false); if (style.isFormatCitations()) { XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, xViewCursor); String charStyle = style.getCitationCharacterFormat(); try { xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle); } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException | WrappedTargetException ex) { // Setting the character format failed, so we throw an exception that // will result in an error message for the user. Before that, // delete the space we inserted: xViewCursor.goLeft((short) 1, true); xViewCursor.setString(""); throw new UndefinedCharacterFormatException(charStyle); } } xViewCursor.goLeft((short) 1, false); Map<BibEntry, BibDatabase> databaseMap = new HashMap<>(); for (BibEntry entry : entries) { databaseMap.put(entry, database);} String citeText = style.isNumberEntries() ? "-" : style.getCitationMarker(entries, databaseMap, inParenthesis, null, null); insertReferenceMark(bName, citeText, xViewCursor, withText, style); xViewCursor.collapseToEnd(); xViewCursor.goRight((short) 1, false); XTextRange position = xViewCursor.getEnd(); if (sync) { // To account for numbering and for uniqiefiers, we must refresh the cite markers: updateSortedReferenceMarks(); refreshCiteMarkers(allBases, style); // Insert it at the current position: rebuildBibTextSection(allBases, style); } // Go back to the relevant position: xViewCursor.gotoRange(position, false); } catch (DisposedException ex) { // We need to catch this one here because the OpenOfficePanel class is // loaded before connection, and therefore cannot directly reference // or catch a DisposedException (which is in a OO JAR file). throw new ConnectionLostException(ex.getMessage()); } }"




"class OOBibBase {  private static final OOPreFormatter POSTFORMATTER = new OOPreFormatter();  private static final String BIB_SECTION_NAME = "JR_bib"; private static final String BIB_SECTION_END_NAME = "JR_bib_end"; private static final String BIB_CITATION = "JR_cite"; private static final Pattern CITE_PATTERN = Pattern.compile(OOBibBase.BIB_CITATION + "\\d*_(\\d*)_(.*)");  private static final String CHAR_STYLE_NAME = "CharStyleName";  private static final int AUTHORYEAR_PAR = 1; private static final int AUTHORYEAR_INTEXT = 2; private static final int INVISIBLE_CIT = 3;  private static final Logger LOGGER = LoggerFactory.getLogger(OOBibBase.class); private XMultiServiceFactory mxDocFactory; private XTextDocument mxDoc; private XText text; private final XDesktop xDesktop; private XTextViewCursorSupplier xViewCursorSupplier; private XComponent xCurrentComponent; private XPropertySet propertySet;  private XPropertyContainer userProperties; private final boolean atEnd; private final Comparator<BibEntry> entryComparator; private final Comparator<BibEntry> yearAuthorTitleComparator; private final FieldComparator authComp = new FieldComparator(StandardField.AUTHOR); private final FieldComparator yearComp = new FieldComparator(StandardField.YEAR);  private final FieldComparator titleComp = new FieldComparator(StandardField.TITLE); private final List<Comparator<BibEntry>> authorYearTitleList = new ArrayList<>(3);  private final List<Comparator<BibEntry>> yearAuthorTitleList = new ArrayList<>(3); private final Map<String, String> uniquefiers = new HashMap<>(); private List<String> sortedReferenceMarks;  private final DialogService dialogService;  public OOBibBase(List<URL> jarUrls, boolean atEnd, DialogService dialogService) throws IllegalAccessException, InvocationTargetException, BootstrapException, CreationException, IOException, ClassNotFoundException {  this.dialogService = dialogService;  authorYearTitleList.add(authComp); authorYearTitleList.add(yearComp); authorYearTitleList.add(titleComp);  yearAuthorTitleList.add(yearComp); yearAuthorTitleList.add(authComp); yearAuthorTitleList.add(titleComp);  entryComparator = new FieldComparatorStack<>(authorYearTitleList); yearAuthorTitleComparator = new FieldComparatorStack<>(yearAuthorTitleList);  this.atEnd = atEnd;  xDesktop = simpleBootstrap(jarUrls); }  public boolean isConnectedToDocument() { return xCurrentComponent != null; }  public XTextDocument selectComponent(List<XTextDocument> list) { List<DocumentTitleViewModel> viewModel = list.stream().map(DocumentTitleViewModel::new).collect(Collectors.toList()); //this whole method is part of a background task when autodecting instances, so we need to show dialog in FX thread Optional<DocumentTitleViewModel> selectedDocument = dialogService.showChoiceDialogAndWait(Localization.lang("Select document"), Localization.lang("Found documents:"), Localization.lang("Use selected document"), viewModel); return selectedDocument.map(DocumentTitleViewModel::getXtextDocument).orElse(null); }  public Optional<String> getCurrentDocumentTitle() { return getDocumentTitle(mxDoc); }  private Optional<String> getDocumentTitle(XTextDocument doc) { if (doc == null) { return Optional.empty(); } else { try { return Optional.of(String.valueOf(OOUtil.getProperty(doc.getCurrentController().getFrame(), "Title"))); } catch (UnknownPropertyException | WrappedTargetException e) { LOGGER.warn("Could not get document title", e); return Optional.empty(); } } }  public void selectDocument() throws NoDocumentException, NoSuchElementException, WrappedTargetException { List<XTextDocument> textDocumentList = getTextDocuments(); XTextDocument selected; if (textDocumentList.isEmpty()) { // No text documents found. throw new NoDocumentException("No Writer documents found"); } else if (textDocumentList.size() == 1) { // Get the only one selected = textDocumentList.get(0); } else { // Bring up a dialog selected = selectComponent(textDocumentList); }  if (selected == null) { return; } xCurrentComponent = UnoRuntime.queryInterface(XComponent.class, selected); mxDoc = selected;  UnoRuntime.queryInterface(XDocumentIndexesSupplier.class, xCurrentComponent);  XModel xModel = UnoRuntime.queryInterface(XModel.class, xCurrentComponent); XController xController = xModel.getCurrentController(); xViewCursorSupplier = UnoRuntime.queryInterface(XTextViewCursorSupplier.class, xController);  // get a reference to the body text of the document text = mxDoc.getText();  // Access the text document's multi service factory: mxDocFactory = UnoRuntime.queryInterface(XMultiServiceFactory.class, mxDoc);  XDocumentPropertiesSupplier supp = UnoRuntime.queryInterface(XDocumentPropertiesSupplier.class, mxDoc); userProperties = supp.getDocumentProperties().getUserDefinedProperties(); propertySet = UnoRuntime.queryInterface(XPropertySet.class, userProperties);  }  private List<XTextDocument> getTextDocuments() throws NoSuchElementException, WrappedTargetException { List<XTextDocument> result = new ArrayList<>(); XEnumerationAccess enumAccess = xDesktop.getComponents(); XEnumeration componentEnumeration = enumAccess.createEnumeration();  // TODO: http://api.openoffice.org/docs/DevelopersGuide/OfficeDev/OfficeDev.xhtml#1_1_3_2_1_2_Frame_Hierarchies  while (componentEnumeration.hasMoreElements()) { Object nextElement = componentEnumeration.nextElement(); XComponent component = UnoRuntime.queryInterface(XComponent.class, nextElement); XTextDocument document = UnoRuntime.queryInterface(XTextDocument.class, component); if (document != null) { result.add(document); } } return result; }  private XDesktop simpleBootstrap(List<URL> jarUrls) throws CreationException, BootstrapException {  URL[] urls = jarUrls.toArray(new URL[1]); URLClassLoader loader = new URLClassLoader(urls, null);  //Get the office component context: XComponentContext xContext = org.jabref.gui.openoffice.Bootstrap.bootstrap(loader); //Get the office service manager: XMultiComponentFactory xServiceManager = xContext.getServiceManager(); //Create the desktop, which is the root frame of the //hierarchy of frames that contain viewable components: Object desktop; try { desktop = xServiceManager.createInstanceWithContext("com.sun.star.frame.Desktop", xContext); } catch (Exception e) { throw new CreationException(e.getMessage()); } XDesktop resultDesktop = UnoRuntime.queryInterface(XDesktop.class, desktop);  UnoRuntime.queryInterface(XComponentLoader.class, desktop);  return resultDesktop; }  public Optional<String> getCustomProperty(String property) throws UnknownPropertyException, WrappedTargetException { if (propertySet.getPropertySetInfo().hasPropertyByName(property)) { return Optional.ofNullable(propertySet.getPropertyValue(property).toString()); } return Optional.empty(); }  public void updateSortedReferenceMarks() throws WrappedTargetException, NoSuchElementException { sortedReferenceMarks = getSortedReferenceMarks(getReferenceMarks()); }  public void setCustomProperty(String property, String value) throws UnknownPropertyException, NotRemoveableException, PropertyExistException, IllegalTypeException, IllegalArgumentException { if (propertySet.getPropertySetInfo().hasPropertyByName(property)) { userProperties.removeProperty(property); } if (value != null) { userProperties.addProperty(property, com.sun.star.beans.PropertyAttribute.REMOVEABLE, new Any(Type.STRING, value)); } }  /** * This method inserts a cite marker in the text for the given BibEntry, * and may refresh the bibliography. * @param entries The entries to cite. * @param database The database the entry belongs to. * @param style The bibliography style we are using. * @param inParenthesis Indicates whether it is an in-text citation or a citation in parenthesis. *   This is not relevant if numbered citations are used. * @param withText Indicates whether this should be a normal citation (true) or an empty *   (invisible) citation (false). * @param sync Indicates whether the reference list should be refreshed. * @throws IllegalTypeException * @throws PropertyExistException * @throws NotRemoveableException * @throws UnknownPropertyException * @throws UndefinedCharacterFormatException * @throws NoSuchElementException * @throws WrappedTargetException * @throws IOException * @throws PropertyVetoException * @throws CreationException * @throws BibEntryNotFoundException * @throws UndefinedParagraphFormatException */ public void insertEntry(List<BibEntry> entries, BibDatabase database, List<BibDatabase> allBases, OOBibStyle style, boolean inParenthesis, boolean withText, String pageInfo, boolean sync) throws IllegalArgumentException, UnknownPropertyException, NotRemoveableException, PropertyExistException, IllegalTypeException, UndefinedCharacterFormatException, WrappedTargetException, NoSuchElementException, PropertyVetoException, IOException, CreationException, BibEntryNotFoundException, UndefinedParagraphFormatException {  try {  XTextViewCursor xViewCursor = xViewCursorSupplier.getViewCursor();  if (entries.size() > 1) { if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) { entries.sort(yearAuthorTitleComparator); } else { entries.sort(entryComparator); } }  String keyString = String.join(",", entries.stream().map(entry -> entry.getCiteKeyOptional().orElse("")).collect(Collectors.toList())); // Insert bookmark: String bName = getUniqueReferenceMarkName(keyString, withText ? inParenthesis ? OOBibBase.AUTHORYEAR_PAR : OOBibBase.AUTHORYEAR_INTEXT : OOBibBase.INVISIBLE_CIT);  // If we should store metadata for page info, do that now: if (pageInfo != null) { LOGGER.info("Storing page info: " + pageInfo); setCustomProperty(bName, pageInfo); }  xViewCursor.getText().insertString(xViewCursor, " ", false); if (style.isFormatCitations()) { XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, xViewCursor); String charStyle = style.getCitationCharacterFormat(); try { xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle); } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException | WrappedTargetException ex) { // Setting the character format failed, so we throw an exception that // will result in an error message for the user. Before that, // delete the space we inserted: xViewCursor.goLeft((short) 1, true); xViewCursor.setString(""); throw new UndefinedCharacterFormatException(charStyle); } } xViewCursor.goLeft((short) 1, false); Map<BibEntry, BibDatabase> databaseMap = new HashMap<>(); for (BibEntry entry : entries) { databaseMap.put(entry, database); } String citeText = style.isNumberEntries() ? "-" : style.getCitationMarker(entries, databaseMap, inParenthesis, null, null); insertReferenceMark(bName, citeText, xViewCursor, withText, style);  xViewCursor.collapseToEnd(); xViewCursor.goRight((short) 1, false);  XTextRange position = xViewCursor.getEnd();  if (sync) { // To account for numbering and for uniqiefiers, we must refresh the cite markers: updateSortedReferenceMarks(); refreshCiteMarkers(allBases, style);  // Insert it at the current position: rebuildBibTextSection(allBases, style); }  // Go back to the relevant position: xViewCursor.gotoRange(position, false); } catch (DisposedException ex) { // We need to catch this one here because the OpenOfficePanel class is // loaded before connection, and therefore cannot directly reference // or catch a DisposedException (which is in a OO JAR file). throw new ConnectionLostException(ex.getMessage()); } }  public List<String> getJabRefReferenceMarks(XNameAccess nameAccess) { String[] names = nameAccess.getElementNames(); // Remove all reference marks that don't look like JabRef citations: List<String> result = new ArrayList<>(); if (names != null) { for (String name : names) { if (CITE_PATTERN.matcher(name).find()) { result.add(name); } } } return result; }  /** * Refresh all cite markers in the document. * @param databases The databases to get entries from. * @param style The bibliography style to use. * @return A list of those referenced BibTeX keys that could not be resolved. * @throws UndefinedCharacterFormatException * @throws NoSuchElementException * @throws IllegalArgumentException * @throws WrappedTargetException * @throws BibEntryNotFoundException * @throws CreationException * @throws IOException * @throws PropertyVetoException * @throws UnknownPropertyException */ public List<String> refreshCiteMarkers(List<BibDatabase> databases, OOBibStyle style) throws WrappedTargetException, IllegalArgumentException, NoSuchElementException, UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException, IOException, CreationException, BibEntryNotFoundException { try { return refreshCiteMarkersInternal(databases, style); } catch (DisposedException ex) { // We need to catch this one here because the OpenOfficePanel class is // loaded before connection, and therefore cannot directly reference // or catch a DisposedException (which is in a OO JAR file). throw new ConnectionLostException(ex.getMessage()); } }  private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style) throws WrappedTargetException, IllegalArgumentException, NoSuchElementException, UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException, CreationException, BibEntryNotFoundException {  List<String> cited = findCitedKeys(); Map<String, BibDatabase> linkSourceBase = new HashMap<>(); Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);  XNameAccess xReferenceMarks = getReferenceMarks();  List<String> names; if (style.isSortByPosition()) { // We need to sort the reference marks according to their order of appearance: names = sortedReferenceMarks; } else if (style.isNumberEntries()) { // We need to sort the reference marks according to the sorting of the bibliographic // entries: SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator); for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) { newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue()); } entries = newMap; // Rebuild the list of cited keys according to the sort order: cited.clear(); for (BibEntry entry : entries.keySet()) { cited.add(entry.getCiteKeyOptional().orElse(null)); } names = Arrays.asList(xReferenceMarks.getElementNames()); } else { names = sortedReferenceMarks; }  // Remove all reference marks that don't look like JabRef citations: List<String> tmp = new ArrayList<>(); for (String name : names) { if (CITE_PATTERN.matcher(name).find()) { tmp.add(name); } } names = tmp;  Map<String, Integer> numbers = new HashMap<>(); int lastNum = 0; // First compute citation markers for all citations: String[] citMarkers = new String[names.size()]; String[][] normCitMarkers = new String[names.size()][]; String[][] bibtexKeys = new String[names.size()][];  int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);  int[] types = new int[names.size()]; for (int i = 0; i < names.size(); i++) { Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i)); if (citeMatcher.find()) { String typeStr = citeMatcher.group(1); int type = Integer.parseInt(typeStr); types[i] = type; // Remember the type in case we need to uniquefy. String[] keys = citeMatcher.group(2).split(","); bibtexKeys[i] = keys; BibEntry[] cEntries = new BibEntry[keys.length]; for (int j = 0; j < cEntries.length; j++) { BibDatabase database = linkSourceBase.get(keys[j]); Optional<BibEntry> tmpEntry = Optional.empty(); if (database != null) { tmpEntry = database.getEntryByKey(keys[j]); } if (tmpEntry.isPresent()) { cEntries[j] = tmpEntry.get(); } else { LOGGER.info("BibTeX key not found: '" + keys[j] + '\''); LOGGER.info("Problem with reference mark: '" + names.get(i) + '\''); throw new BibEntryNotFoundException(names.get(i), Localization .lang("Could not resolve BibTeX entry for citation marker '%0'.", names.get(i))); } }  String[] normCitMarker = new String[keys.length]; String citationMarker; if (style.isBibtexKeyCiteMarkers()) { StringBuilder sb = new StringBuilder(); normCitMarkers[i] = new String[keys.length]; for (int j = 0; j < keys.length; j++) { normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null); sb.append(cEntries[j].getCiteKeyOptional().orElse("")); if (j < (keys.length - 1)) { sb.append(','); } } citationMarker = sb.toString(); } else if (style.isNumberEntries()) { if (style.isSortByPosition()) { // We have sorted the citation markers according to their order of appearance, // so we simply count up for each marker referring to a new entry: List<Integer> num = new ArrayList<>(keys.length); for (int j = 0; j < keys.length; j++) { if (cEntries[j] instanceof UndefinedBibtexEntry) { num.add(j, -1); } else { num.add(j, lastNum + 1); if (numbers.containsKey(keys[j])) { num.set(j, numbers.get(keys[j])); } else { numbers.put(keys[j], num.get(j)); lastNum = num.get(j); } } } citationMarker = style.getNumCitationMarker(num, minGroupingCount, false); for (int j = 0; j < keys.length; j++) { normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)), minGroupingCount, false); } } else { // We need to find the number of the cited entry in the bibliography, // and use that number for the cite marker: List<Integer> num = findCitedEntryIndex(names.get(i), cited);  if (num.isEmpty()) { throw new BibEntryNotFoundException(names.get(i), Localization .lang("Could not resolve BibTeX entry for citation marker '%0'.", names.get(i))); } else { citationMarker = style.getNumCitationMarker(num, minGroupingCount, false); }  for (int j = 0; j < keys.length; j++) { List<Integer> list = new ArrayList<>(1); list.add(num.get(j)); normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false); } } } else {  if (cEntries.length > 1) { if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) { Arrays.sort(cEntries, yearAuthorTitleComparator); } else { Arrays.sort(cEntries, entryComparator); } // Update key list to match the new sorting: for (int j = 0; j < cEntries.length; j++) { bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null); } }  citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries, type == OOBibBase.AUTHORYEAR_PAR, null, null); // We need "normalized" (in parenthesis) markers for uniqueness checking purposes: for (int j = 0; j < cEntries.length; j++) { normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries, true, null, new int[] {-1}); } } citMarkers[i] = citationMarker; normCitMarkers[i] = normCitMarker;  }  }  uniquefiers.clear(); if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) { // See if there are duplicate citations marks referring to different entries. If so, we need to // use uniquefiers: Map<String, List<String>> refKeys = new HashMap<>(); Map<String, List<Integer>> refNums = new HashMap<>(); for (int i = 0; i < citMarkers.length; i++) { String[] markers = normCitMarkers[i]; // compare normalized markers, since the actual markers can be different for (int j = 0; j < markers.length; j++) { String marker = markers[j]; String currentKey = bibtexKeys[i][j]; if (refKeys.containsKey(marker)) { // Ok, we have seen this exact marker before. if (!refKeys.get(marker).contains(currentKey)) { // ... but not for this entry. refKeys.get(marker).add(currentKey); refNums.get(marker).add(i); } } else { List<String> l = new ArrayList<>(1); l.add(currentKey); refKeys.put(marker, l); List<Integer> l2 = new ArrayList<>(1); l2.add(i); refNums.put(marker, l2); } } } // Go through the collected lists and see where we need to uniquefy: for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) { List<String> keys = stringListEntry.getValue(); if (keys.size() > 1) { // This marker appears for more than one unique entry: int uniq = 'a'; for (String key : keys) { // Update the map of uniquefiers for the benefit of both the following generation of new // citation markers, and for the method that builds the bibliography: uniquefiers.put(key, String.valueOf((char) uniq)); uniq++; } } }  // Finally, go through all citation markers, and update those referring to entries in our current list: int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST); Set<String> seenBefore = new HashSet<>(); for (int j = 0; j < bibtexKeys.length; j++) { boolean needsChange = false; int[] firstLimAuthors = new int[bibtexKeys[j].length]; String[] uniquif = new String[bibtexKeys[j].length]; BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length]; for (int k = 0; k < bibtexKeys[j].length; k++) { String currentKey = bibtexKeys[j][k]; firstLimAuthors[k] = -1; if (maxAuthorsFirst > 0) { if (!seenBefore.contains(currentKey)) { firstLimAuthors[k] = maxAuthorsFirst; } seenBefore.add(currentKey); } String uniq = uniquefiers.get(currentKey); Optional<BibEntry> tmpEntry = Optional.empty(); if (uniq == null) { if (firstLimAuthors[k] > 0) { needsChange = true; BibDatabase database = linkSourceBase.get(currentKey); if (database != null) { tmpEntry = database.getEntryByKey(currentKey); } } else { BibDatabase database = linkSourceBase.get(currentKey); if (database != null) { tmpEntry = database.getEntryByKey(currentKey); } } uniquif[k] = ""; } else { needsChange = true; BibDatabase database = linkSourceBase.get(currentKey); if (database != null) { tmpEntry = database.getEntryByKey(currentKey); } uniquif[k] = uniq; } if (tmpEntry.isPresent()) { cEntries[k] = tmpEntry.get(); } } if (needsChange) { citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries, types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors); } } }  // Refresh all reference marks with the citation markers we computed: boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null; // Check if we are supposed to set a character format for citations: boolean mustTestCharFormat = style.isFormatCitations(); for (int i = 0; i < names.size(); i++) { Object referenceMark = xReferenceMarks.getByName(names.get(i)); XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);  XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());  if (mustTestCharFormat) { // If we are supposed to set character format for citations, must run a test before we // delete old citation markers. Otherwise, if the specified character format doesn't // exist, we end up deleting the markers before the process crashes due to a the missing // format, with catastrophic consequences for the user. mustTestCharFormat = false; // need to do this only once XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor); String charStyle = style.getCitationCharacterFormat(); try { xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle); } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException | WrappedTargetException ex) { throw new UndefinedCharacterFormatException(charStyle); } }  text.removeTextContent(bookmark);  insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style); if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) { // We have overwritten the marker for the start of the reference list. // We need to add it again. cursor.collapseToEnd(); OOUtil.insertParagraphBreak(text, cursor); insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor); } }  List<String> unresolvedKeys = new ArrayList<>(); for (BibEntry entry : entries.keySet()) { if (entry instanceof UndefinedBibtexEntry) { String key = ((UndefinedBibtexEntry) entry).getKey(); if (!unresolvedKeys.contains(key)) { unresolvedKeys.add(key); } } } return unresolvedKeys; }  private List<String> getSortedReferenceMarks(final XNameAccess nameAccess) throws WrappedTargetException, NoSuchElementException { XTextViewCursorSupplier cursorSupplier = UnoRuntime.queryInterface(XTextViewCursorSupplier.class, mxDoc.getCurrentController());  XTextViewCursor viewCursor = cursorSupplier.getViewCursor(); XTextRange initialPos = viewCursor.getStart(); List<String> names = Arrays.asList(nameAccess.getElementNames()); List<Point> positions = new ArrayList<>(names.size()); for (String name : names) { XTextContent textContent = UnoRuntime.queryInterface(XTextContent.class, nameAccess.getByName(name)); XTextRange range = textContent.getAnchor(); // Check if we are inside a footnote: if (UnoRuntime.queryInterface(XFootnote.class, range.getText()) != null) { // Find the linking footnote marker: XFootnote footer = UnoRuntime.queryInterface(XFootnote.class, range.getText()); // The footnote's anchor gives the correct position in the text: range = footer.getAnchor(); }  positions.add(findPosition(viewCursor, range)); } Set<ComparableMark> set = new TreeSet<>(); for (int i = 0; i < positions.size(); i++) { set.add(new ComparableMark(names.get(i), positions.get(i))); }  List<String> result = new ArrayList<>(set.size()); for (ComparableMark mark : set) { result.add(mark.getName()); } viewCursor.gotoRange(initialPos, false);  return result; }  public XNameAccess getReferenceMarks() { XReferenceMarksSupplier supplier = UnoRuntime.queryInterface(XReferenceMarksSupplier.class, xCurrentComponent); return supplier.getReferenceMarks(); }  private String getUniqueReferenceMarkName(String bibtexKey, int type) { XNameAccess xNamedRefMarks = getReferenceMarks(); int i = 0; String name = OOBibBase.BIB_CITATION + '_' + type + '_' + bibtexKey; while (xNamedRefMarks.hasByName(name)) { name = OOBibBase.BIB_CITATION + i + '_' + type + '_' + bibtexKey; i++; } return name; }  public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style) throws NoSuchElementException, WrappedTargetException, IllegalArgumentException, CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException { List<String> cited = findCitedKeys(); Map<String, BibDatabase> linkSourceBase = new HashMap<>(); Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); // Although entries are redefined without use, this also updates linkSourceBase  List<String> names = sortedReferenceMarks;  if (style.isSortByPosition()) { // We need to sort the entries according to their order of appearance: entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase); } else { SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator); for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited, linkSourceBase).entrySet()) { newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue()); } entries = newMap; } clearBibTextSectionContent2(); populateBibTextSection(entries, style); }  private List<String> findCitedKeys() throws NoSuchElementException, WrappedTargetException { XNameAccess xNamedMarks = getReferenceMarks(); String[] names = xNamedMarks.getElementNames(); List<String> keys = new ArrayList<>(); for (String name1 : names) { Object bookmark = xNamedMarks.getByName(name1); UnoRuntime.queryInterface(XTextContent.class, bookmark);  List<String> newKeys = parseRefMarkName(name1); for (String key : newKeys) { if (!keys.contains(key)) { keys.add(key); } } }  return keys; }  private Map<BibEntry, BibDatabase> findCitedEntries(List<BibDatabase> databases, List<String> keys, Map<String, BibDatabase> linkSourceBase) { Map<BibEntry, BibDatabase> entries = new LinkedHashMap<>(); for (String key : keys) { boolean found = false; for (BibDatabase database : databases) { Optional<BibEntry> entry = database.getEntryByKey(key); if (entry.isPresent()) { entries.put(entry.get(), database); linkSourceBase.put(key, database); found = true; break; } }  if (!found) { entries.put(new UndefinedBibtexEntry(key), null); } } return entries; }  private Point findPosition(XTextViewCursor cursor, XTextRange range) { cursor.gotoRange(range, false); return cursor.getPosition(); }  /** * Extract the list of bibtex keys from a reference mark name. * @param name The reference mark name. * @return The list of bibtex keys encoded in the name. */ public List<String> parseRefMarkName(String name) { List<String> keys = new ArrayList<>(); Matcher citeMatcher = CITE_PATTERN.matcher(name); if (citeMatcher.find()) { String[] keystring = citeMatcher.group(2).split(","); for (String aKeystring : keystring) { if (!keys.contains(aKeystring)) { keys.add(aKeystring); } } } return keys; }  /** * Resolve the bibtex key from a citation reference marker name, and look up * the index of the key in a list of keys. * @param citRefName The name of the ReferenceMark representing the citation. * @param keys A List of bibtex keys representing the entries in the bibliography. * @return the indices of the cited keys, -1 if a key is not found. Returns null if the ref name *   could not be resolved as a citation. */  private List<Integer> findCitedEntryIndex(String citRefName, List<String> keys) { Matcher citeMatcher = CITE_PATTERN.matcher(citRefName); if (citeMatcher.find()) { List<String> keyStrings = Arrays.asList(citeMatcher.group(2).split(",")); List<Integer> result = new ArrayList<>(keyStrings.size()); for (String key : keyStrings) { int ind = keys.indexOf(key); result.add(ind == -1 ? -1 : 1 + ind); } return result; } else { return Collections.emptyList(); } }  private Map<BibEntry, BibDatabase> getSortedEntriesFromSortedRefMarks(List<String> names, Map<String, BibDatabase> linkSourceBase) {  Map<BibEntry, BibDatabase> newList = new LinkedHashMap<>(); for (String name : names) { Matcher citeMatcher = CITE_PATTERN.matcher(name); if (citeMatcher.find()) { String[] keys = citeMatcher.group(2).split(","); for (String key : keys) { BibDatabase database = linkSourceBase.get(key); Optional<BibEntry> origEntry = Optional.empty(); if (database != null) { origEntry = database.getEntryByKey(key); } if (origEntry.isPresent()) { if (!newList.containsKey(origEntry.get())) { newList.put(origEntry.get(), database); } } else { LOGGER.info("BibTeX key not found: '" + key + "'"); LOGGER.info("Problem with reference mark: '" + name + "'"); newList.put(new UndefinedBibtexEntry(key), null); } } } }  return newList; }  public String getCitationContext(XNameAccess nameAccess, String refMarkName, int charBefore, int charAfter, boolean htmlMarkup) throws NoSuchElementException, WrappedTargetException { Object referenceMark = nameAccess.getByName(refMarkName); XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);  XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor()); String citPart = cursor.getString(); int flex = 8; for (int i = 0; i < charBefore; i++) { try { cursor.goLeft((short) 1, true); if ((i >= (charBefore - flex)) && Character.isWhitespace(cursor.getString().charAt(0))) { break; } } catch (IndexOutOfBoundsException ex) { LOGGER.warn("Problem going left", ex); } } int length = cursor.getString().length(); int added = length - citPart.length(); cursor.collapseToStart(); for (int i = 0; i < (charAfter + length); i++) { try { cursor.goRight((short) 1, true); if (i >= ((charAfter + length) - flex)) { String strNow = cursor.getString(); if (Character.isWhitespace(strNow.charAt(strNow.length() - 1))) { break; } } } catch (IndexOutOfBoundsException ex) { LOGGER.warn("Problem going right", ex); } }  String result = cursor.getString(); if (htmlMarkup) { result = result.substring(0, added) + "<b>" + citPart + "</b>" + result.substring(length); } return result.trim(); }  private void insertFullReferenceAtCursor(XTextCursor cursor, Map<BibEntry, BibDatabase> entries, OOBibStyle style, String parFormat) throws UndefinedParagraphFormatException, IllegalArgumentException, UnknownPropertyException, PropertyVetoException, WrappedTargetException { Map<BibEntry, BibDatabase> correctEntries; // If we don't have numbered entries, we need to sort the entries before adding them: if (style.isSortByPosition()) { // Use the received map directly correctEntries = entries; } else { // Sort map Map<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator); newMap.putAll(entries); correctEntries = newMap; } int number = 1; for (Map.Entry<BibEntry, BibDatabase> entry : correctEntries.entrySet()) { if (entry.getKey() instanceof UndefinedBibtexEntry) { continue; } OOUtil.insertParagraphBreak(text, cursor); if (style.isNumberEntries()) { int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT); OOUtil.insertTextAtCurrentLocation(text, cursor, style.getNumCitationMarker(Collections.singletonList(number++), minGroupingCount, true), Collections.emptyList()); } Layout layout = style.getReferenceFormat(entry.getKey().getType()); layout.setPostFormatter(POSTFORMATTER); OOUtil.insertFullReferenceAtCurrentLocation(text, cursor, layout, parFormat, entry.getKey(), entry.getValue(), uniquefiers.get(entry.getKey().getCiteKeyOptional().orElse(null))); }  }  private void createBibTextSection2(boolean end) throws IllegalArgumentException, CreationException {  XTextCursor mxDocCursor = text.createTextCursor(); if (end) { mxDocCursor.gotoEnd(false); } OOUtil.insertParagraphBreak(text, mxDocCursor); // Create a new TextSection from the document factory and access it's XNamed interface XNamed xChildNamed; try { xChildNamed = UnoRuntime.queryInterface(XNamed.class, mxDocFactory.createInstance("com.sun.star.text.TextSection")); } catch (Exception e) { throw new CreationException(e.getMessage()); } // Set the new sections name to 'Child_Section' xChildNamed.setName(OOBibBase.BIB_SECTION_NAME); // Access the Child_Section's XTextContent interface and insert it into the document XTextContent xChildSection = UnoRuntime.queryInterface(XTextContent.class, xChildNamed); text.insertTextContent(mxDocCursor, xChildSection, false);  }  private void clearBibTextSectionContent2() throws NoSuchElementException, WrappedTargetException, IllegalArgumentException, CreationException {  // Check if the section exists: XTextSectionsSupplier supplier = UnoRuntime.queryInterface(XTextSectionsSupplier.class, mxDoc); if (supplier.getTextSections().hasByName(OOBibBase.BIB_SECTION_NAME)) { XTextSection section = (XTextSection) ((Any) supplier.getTextSections().getByName(OOBibBase.BIB_SECTION_NAME)) .getObject(); // Clear it: XTextCursor cursor = text.createTextCursorByRange(section.getAnchor()); cursor.gotoRange(section.getAnchor(), false); cursor.setString(""); } else { createBibTextSection2(atEnd); } }  private void populateBibTextSection(Map<BibEntry, BibDatabase> entries, OOBibStyle style) throws NoSuchElementException, WrappedTargetException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException, IllegalArgumentException, CreationException { XTextSectionsSupplier supplier = UnoRuntime.queryInterface(XTextSectionsSupplier.class, mxDoc); XTextSection section = (XTextSection) ((Any) supplier.getTextSections().getByName(OOBibBase.BIB_SECTION_NAME)) .getObject(); XTextCursor cursor = text.createTextCursorByRange(section.getAnchor()); OOUtil.insertTextAtCurrentLocation(text, cursor, (String) style.getProperty(OOBibStyle.TITLE), (String) style.getProperty(OOBibStyle.REFERENCE_HEADER_PARAGRAPH_FORMAT)); insertFullReferenceAtCursor(cursor, entries, style, (String) style.getProperty(OOBibStyle.REFERENCE_PARAGRAPH_FORMAT)); insertBookMark(OOBibBase.BIB_SECTION_END_NAME, cursor); }  private XTextContent insertBookMark(String name, XTextCursor position) throws IllegalArgumentException, CreationException { Object bookmark; try { bookmark = mxDocFactory.createInstance("com.sun.star.text.Bookmark"); } catch (Exception e) { throw new CreationException(e.getMessage()); } // name the bookmark XNamed xNamed = UnoRuntime.queryInterface(XNamed.class, bookmark); xNamed.setName(name); // get XTextContent interface XTextContent xTextContent = UnoRuntime.queryInterface(XTextContent.class, bookmark); // insert bookmark at the end of the document // instead of mxDocText.getEnd you could use a text cursor's XTextRange interface or any XTextRange text.insertTextContent(position, xTextContent, true); position.collapseToEnd(); return xTextContent; }  private void insertReferenceMark(String name, String citationText, XTextCursor position, boolean withText, OOBibStyle style) throws UnknownPropertyException, WrappedTargetException, PropertyVetoException, IllegalArgumentException, UndefinedCharacterFormatException, CreationException {  // Check if there is "page info" stored for this citation. If so, insert it into // the citation text before inserting the citation: Optional<String> pageInfo = getCustomProperty(name); String citText; if ((pageInfo.isPresent()) && !pageInfo.get().isEmpty()) { citText = style.insertPageInfo(citationText, pageInfo.get()); } else { citText = citationText; }  Object bookmark; try { bookmark = mxDocFactory.createInstance("com.sun.star.text.ReferenceMark"); } catch (Exception e) { throw new CreationException(e.getMessage()); } // Name the reference XNamed xNamed = UnoRuntime.queryInterface(XNamed.class, bookmark); xNamed.setName(name);  if (withText) { position.setString(citText); XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, position);  // Set language to [None]: xCursorProps.setPropertyValue("CharLocale", new Locale("zxx", "", "")); if (style.isFormatCitations()) { String charStyle = style.getCitationCharacterFormat(); try { xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle); } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException | WrappedTargetException ex) { throw new UndefinedCharacterFormatException(charStyle); } } } else { position.setString(""); }  // get XTextContent interface XTextContent xTextContent = UnoRuntime.queryInterface(XTextContent.class, bookmark);  position.getText().insertTextContent(position, xTextContent, true);  // Check if we should italicize the "et al." string in citations: boolean italicize = style.getBooleanCitProperty(OOBibStyle.ITALIC_ET_AL); if (italicize) { String etAlString = style.getStringCitProperty(OOBibStyle.ET_AL_STRING); int index = citText.indexOf(etAlString); if (index >= 0) { italicizeOrBold(position, true, index, index + etAlString.length()); } }  position.collapseToEnd();  }  private void removeReferenceMark(String name) throws NoSuchElementException, WrappedTargetException { XNameAccess xReferenceMarks = getReferenceMarks(); if (xReferenceMarks.hasByName(name)) { Object referenceMark = xReferenceMarks.getByName(name); XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark); text.removeTextContent(bookmark); } }  /** * Get the XTextRange corresponding to the named bookmark. * @param name The name of the bookmark to find. * @return The XTextRange for the bookmark. * @throws WrappedTargetException * @throws NoSuchElementException */ private XTextRange getBookmarkRange(String name) throws NoSuchElementException, WrappedTargetException { XNameAccess xNamedBookmarks = getBookmarks();  // retrieve bookmark by name if (!xNamedBookmarks.hasByName(name)) { return null; } Object foundBookmark = xNamedBookmarks.getByName(name); XTextContent xFoundBookmark = UnoRuntime.queryInterface(XTextContent.class, foundBookmark); return xFoundBookmark.getAnchor(); }  private XNameAccess getBookmarks() { // query XBookmarksSupplier from document model and get bookmarks collection XBookmarksSupplier xBookmarksSupplier = UnoRuntime.queryInterface(XBookmarksSupplier.class, xCurrentComponent); XNameAccess xNamedBookmarks = xBookmarksSupplier.getBookmarks(); return xNamedBookmarks; }  private void italicizeOrBold(XTextCursor position, boolean italicize, int start, int end) throws UnknownPropertyException, PropertyVetoException, IllegalArgumentException, WrappedTargetException { XTextRange range = position.getStart(); XTextCursor cursor = position.getText().createTextCursorByRange(range); cursor.goRight((short) start, false); cursor.goRight((short) (end - start), true); XPropertySet xcp = UnoRuntime.queryInterface(XPropertySet.class, cursor); if (italicize) { xcp.setPropertyValue("CharPosture", com.sun.star.awt.FontSlant.ITALIC); } else { xcp.setPropertyValue("CharWeight", com.sun.star.awt.FontWeight.BOLD); } }  public void combineCiteMarkers(List<BibDatabase> databases, OOBibStyle style) throws IOException, WrappedTargetException, NoSuchElementException, IllegalArgumentException, UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException, CreationException, BibEntryNotFoundException { XNameAccess nameAccess = getReferenceMarks(); // TODO: doesn't work for citations in footnotes/tables List<String> names = getSortedReferenceMarks(nameAccess);  final XTextRangeCompare compare = UnoRuntime.queryInterface(XTextRangeCompare.class, text);  int piv = 0; boolean madeModifications = false; while (piv < (names.size() - 1)) { XTextRange range1 = UnoRuntime.queryInterface(XTextContent.class, nameAccess.getByName(names.get(piv))) .getAnchor().getEnd(); XTextRange range2 = UnoRuntime.queryInterface(XTextContent.class, nameAccess.getByName(names.get(piv + 1))) .getAnchor().getStart(); if (range1.getText() != range2.getText()) { piv++; continue; } XTextCursor mxDocCursor = range1.getText().createTextCursorByRange(range1); mxDocCursor.goRight((short) 1, true); boolean couldExpand = true; while (couldExpand && (compare.compareRegionEnds(mxDocCursor, range2) > 0)) { couldExpand = mxDocCursor.goRight((short) 1, true); } String cursorText = mxDocCursor.getString(); // Check if the string contains no line breaks and only whitespace: if ((cursorText.indexOf('\n') == -1) && cursorText.trim().isEmpty()) {  // If we are supposed to set character format for citations, test this before // making any changes. This way we can throw an exception before any reference // marks are removed, preventing damage to the user's document: if (style.isFormatCitations()) { XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, mxDocCursor); String charStyle = style.getCitationCharacterFormat(); try { xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle); } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException | WrappedTargetException ex) { // Setting the character format failed, so we throw an exception that // will result in an error message for the user: throw new UndefinedCharacterFormatException(charStyle); } }  List<String> keys = parseRefMarkName(names.get(piv)); keys.addAll(parseRefMarkName(names.get(piv + 1))); removeReferenceMark(names.get(piv)); removeReferenceMark(names.get(piv + 1)); List<BibEntry> entries = new ArrayList<>(); for (String key : keys) { for (BibDatabase database : databases) { Optional<BibEntry> entry = database.getEntryByKey(key); if (entry.isPresent()) { entries.add(entry.get()); break; } } } Collections.sort(entries, new FieldComparator(StandardField.YEAR)); String keyString = String.join(",", entries.stream().map(entry -> entry.getCiteKeyOptional().orElse("")) .collect(Collectors.toList())); // Insert bookmark: String bName = getUniqueReferenceMarkName(keyString, OOBibBase.AUTHORYEAR_PAR); insertReferenceMark(bName, "tmp", mxDocCursor, true, style); names.set(piv + 1, bName); madeModifications = true; } piv++; } if (madeModifications) { updateSortedReferenceMarks(); refreshCiteMarkers(databases, style); }  }  public BibDatabase generateDatabase(List<BibDatabase> databases) throws NoSuchElementException, WrappedTargetException { BibDatabase resultDatabase = new BibDatabase(); List<String> cited = findCitedKeys();  // For each cited key for (String key : cited) { // Loop through the available databases for (BibDatabase loopDatabase : databases) { Optional<BibEntry> entry = loopDatabase.getEntryByKey(key); // If entry found if (entry.isPresent()) { BibEntry clonedEntry = (BibEntry) entry.get().clone(); // Insert a copy of the entry resultDatabase.insertEntry(clonedEntry); // Check if the cloned entry has a crossref field clonedEntry.getField(StandardField.CROSSREF).ifPresent(crossref -> { // If the crossref entry is not already in the database if (!resultDatabase.getEntryByKey(crossref).isPresent()) { // Add it if it is in the current library loopDatabase.getEntryByKey(crossref).ifPresent(resultDatabase::insertEntry); } });  // Be happy with the first found BibEntry and move on to next key break; } } }  return resultDatabase; }  private static class ComparableMark implements Comparable<ComparableMark> {  private final String name; private final Point position;  public ComparableMark(String name, Point position) { this.name = name; this.position = position; }  @Override public int compareTo(ComparableMark other) { if (position.Y == other.position.Y) { return position.X - other.position.X; } else { return position.Y - other.position.Y; } }  @Override public boolean equals(Object o) { if (this == o) { return true; }  if (o instanceof ComparableMark) { ComparableMark other = (ComparableMark) o; return (this.position.X == other.position.X) && (this.position.Y == other.position.Y) && Objects.equals(this.name, other.name); } return false; }  public String getName() { return name; }  @Override public int hashCode() { return Objects.hash(position, name); } }  private class DocumentTitleViewModel {  private final XTextDocument xTextDocument; private final String description;  public DocumentTitleViewModel(XTextDocument xTextDocument) { this.xTextDocument = xTextDocument; this.description = getDocumentTitle(xTextDocument).orElse(""); }  public XTextDocument getXtextDocument() { return xTextDocument; }  @Override public String toString() { return description; } } }"

"public void about() { HelpAction.getMainHelpPageCommand().execute(); }"
"public JabRefIcon getTypeIcon() { return IconTheme.JabRefIcons.PDF_FILE; }"

"public abstract int getPageNumber();"





"public class AbbreviationsFileViewModel {  private final SimpleListProperty<AbbreviationViewModel> abbreviations = new SimpleListProperty<>( FXCollections.observableArrayList()); private final ReadOnlyBooleanProperty isBuiltInList; private final String name; private final Optional<Path> path;   public AbbreviationsFileViewModel(Path filePath) { this.path = Optional.ofNullable(filePath); this.name = path.get().toAbsolutePath().toString(); this.isBuiltInList = new SimpleBooleanProperty(false); this.abbreviations.add(new AbbreviationViewModel(null)); }  /** * This constructor should only be called to create a pseudo abbreviation file for built in lists. * This means it is a placeholder and it's path will be null meaning it has no place on the filesystem. * It's isPseudoFile property will therefore be set to true. */ public AbbreviationsFileViewModel(List<AbbreviationViewModel> abbreviations, String name) { this.abbreviations.addAll(abbreviations); this.name = name; this.path = Optional.empty(); this.isBuiltInList = new SimpleBooleanProperty(true); }  public void readAbbreviations() throws FileNotFoundException { if (path.isPresent()) { List<Abbreviation> abbreviationList = JournalAbbreviationLoader .readJournalListFromFile(path.get().toFile()); abbreviationList.forEach(abbreviation -> abbreviations.addAll(new AbbreviationViewModel(abbreviation))); } else { throw new FileNotFoundException(); } }  /** * This method will write all abbreviations of this abbreviation file to the file on the file system. * It essentially will check if the current file is a built in list and if not it will call * {@link AbbreviationWriter#writeOrCreate()}. */ public void writeOrCreate() throws IOException { if (!isBuiltInList.get()) { List<Abbreviation> actualAbbreviations = abbreviations.stream().filter(abb -> !abb.isPseudoAbbreviation()) .map(abb -> abb.getAbbreviationObject()).collect(Collectors.toList()); AbbreviationWriter.writeOrCreate(path.get(), actualAbbreviations, StandardCharsets.UTF_8); } }  public SimpleListProperty<AbbreviationViewModel> abbreviationsProperty() { return this.abbreviations; }  public boolean exists() { return path.isPresent() && Files.exists(path.get()); }  public Optional<Path> getAbsolutePath() { return path; }  public ReadOnlyBooleanProperty isBuiltInListProperty() { return this.isBuiltInList; }  @Override public String toString() { return this.name; }  @Override public int hashCode() { return Objects.hash(name); }  @Override public boolean equals(Object obj) { if (obj instanceof AbbreviationsFileViewModel) { return Objects.equals(this.name, ((AbbreviationsFileViewModel) obj).name); } else { return false; } } }"



"private Optional<BibEntry> entry = Optional.empty();"



"class UndefinedCharacterFormatException extends Exception {  private final String formatName;  public UndefinedCharacterFormatException(String formatName) { super(); this.formatName = formatName; }  public String getFormatName() { return formatName; } }"
"<V> Future<?> schedule(BackgroundTask<V> task, long delay, TimeUnit unit);"

"public class AutoLinkFilesAction extends SimpleCommand {  private final DialogService dialogService; private final JabRefPreferences preferences; private final StateManager stateManager; private UndoManager undoManager; private TaskExecutor taskExecutor;  public AutoLinkFilesAction(JabRefFrame frame, JabRefPreferences preferences, StateManager stateManager, UndoManager undoManager, TaskExecutor taskExecutor) { this.dialogService = frame.getDialogService(); this.preferences = preferences; this.stateManager = stateManager; this.undoManager = undoManager; this.taskExecutor = taskExecutor;  this.executable.bind(needsDatabase(this.stateManager).and(needsEntriesSelected(stateManager))); this.statusMessage.bind(BindingsHelper.ifThenElse(executable, "", Localization.lang("This operation requires one or more entries to be selected.")));  }  @Override public void execute() { BibDatabaseContext database = stateManager.getActiveDatabase().orElseThrow(() -> new NullPointerException("Database null")); List<BibEntry> entries = stateManager.getSelectedEntries();  final NamedCompound nc = new NamedCompound(Localization.lang("Automatically set file links")); AutoSetFileLinksUtil util = new AutoSetFileLinksUtil(database, preferences.getFilePreferences(), preferences.getAutoLinkPreferences(), ExternalFileTypes.getInstance()); Task<List<BibEntry>> linkFilesTask = new Task<List<BibEntry>>() {  @Override protected List<BibEntry> call() { return util.linkAssociatedFiles(entries, nc); }  @Override protected void succeeded() { if (!getValue().isEmpty()) { if (nc.hasEdits()) { nc.end(); undoManager.addEdit(nc); } dialogService.notify(Localization.lang("Finished automatically setting external links.")); } else { dialogService.notify(Localization.lang("Finished automatically setting external links.") + " " + Localization.lang("No files found.")); } } };  dialogService.showProgressDialogAndWait( Localization.lang("Automatically setting file links"), Localization.lang("Searching for files"), linkFilesTask); taskExecutor.execute(linkFilesTask); } }"
"public static XComponentContext createInitialComponentContext(Hashtable<String, Object> context_entries) throws Exception { return createInitialComponentContext((Map<String, Object>) context_entries); }"




"public class DatabaseChangeEvent { // no data }"

" public interface DatabaseChangeListener {  public void onDatabaseChangeNotification(DatabaseChangeEvent event); }"
"public class DatabaseChangeRegistration {  public void addListener(@SuppressWarnings("unused") DatabaseChangeListener listener) { // do nothing } }"



"public class OracleConnection implements Connection {  public static String DCN_NOTIFY_ROWIDS; public static String DCN_QUERY_CHANGE_NOTIFICATION;  @Override public <T> T unwrap(Class<T> iface) throws SQLException { //  Auto-generated method stub return null; }  @Override public boolean isWrapperFor(Class<?> iface) throws SQLException { //  Auto-generated method stub return false; }  @Override public Statement createStatement() throws SQLException { //  Auto-generated method stub return null; }  @Override public PreparedStatement prepareStatement(String sql) throws SQLException { //  Auto-generated method stub return null; }  @Override public CallableStatement prepareCall(String sql) throws SQLException { //  Auto-generated method stub return null; }  @Override public String nativeSQL(String sql) throws SQLException { //  Auto-generated method stub return null; }  @Override public void setAutoCommit(boolean autoCommit) throws SQLException { //  Auto-generated method stub  }  @Override public boolean getAutoCommit() throws SQLException { //  Auto-generated method stub return false; }  @Override public void commit() throws SQLException { //  Auto-generated method stub  }  @Override public void rollback() throws SQLException { //  Auto-generated method stub  }  @Override public void close() throws SQLException { //  Auto-generated method stub  }  @Override public boolean isClosed() throws SQLException { //  Auto-generated method stub return false; }  @Override public DatabaseMetaData getMetaData() throws SQLException { //  Auto-generated method stub return null; }  @Override public void setReadOnly(boolean readOnly) throws SQLException { //  Auto-generated method stub  }  @Override public boolean isReadOnly() throws SQLException { //  Auto-generated method stub return false; }  @Override public void setCatalog(String catalog) throws SQLException { //  Auto-generated method stub  }  @Override public String getCatalog() throws SQLException { //  Auto-generated method stub return null; }  @Override public void setTransactionIsolation(int level) throws SQLException { //  Auto-generated method stub  }  @Override public int getTransactionIsolation() throws SQLException { //  Auto-generated method stub return 0; }  @Override public SQLWarning getWarnings() throws SQLException { //  Auto-generated method stub return null; }  @Override public void clearWarnings() throws SQLException { //  Auto-generated method stub  }  @Override public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException { //  Auto-generated method stub return null; }  @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { //  Auto-generated method stub return null; }  @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { //  Auto-generated method stub return null; }  @Override public Map<String, Class<?>> getTypeMap() throws SQLException { //  Auto-generated method stub return null; }  @Override public void setTypeMap(Map<String, Class<?>> map) throws SQLException { //  Auto-generated method stub  }  @Override public void setHoldability(int holdability) throws SQLException { //  Auto-generated method stub  }  @Override public int getHoldability() throws SQLException { //  Auto-generated method stub return 0; }  @Override public Savepoint setSavepoint() throws SQLException { //  Auto-generated method stub return null; }  @Override public Savepoint setSavepoint(String name) throws SQLException { //  Auto-generated method stub return null; }  @Override public void rollback(Savepoint savepoint) throws SQLException { //  Auto-generated method stub  }  @Override public void releaseSavepoint(Savepoint savepoint) throws SQLException { //  Auto-generated method stub  }  @Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { //  Auto-generated method stub return null; }  @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { //  Auto-generated method stub return null; }  @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { //  Auto-generated method stub return null; }  @Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException { //  Auto-generated method stub return null; }  @Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException { //  Auto-generated method stub return null; }  @Override public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException { //  Auto-generated method stub return null; }  @Override public Clob createClob() throws SQLException { //  Auto-generated method stub return null; }  @Override public Blob createBlob() throws SQLException { //  Auto-generated method stub return null; }  @Override public NClob createNClob() throws SQLException { //  Auto-generated method stub return null; }  @Override public SQLXML createSQLXML() throws SQLException { //  Auto-generated method stub return null; }  @Override public boolean isValid(int timeout) throws SQLException { //  Auto-generated method stub return false; }  @Override public void setClientInfo(String name, String value) throws SQLClientInfoException { //  Auto-generated method stub  }  @Override public void setClientInfo(Properties properties) throws SQLClientInfoException { //  Auto-generated method stub  }  @Override public String getClientInfo(String name) throws SQLException { //  Auto-generated method stub return null; }  @Override public Properties getClientInfo() throws SQLException { //  Auto-generated method stub return null; }  @Override public Array createArrayOf(String typeName, Object[] elements) throws SQLException { //  Auto-generated method stub return null; }  @Override public Struct createStruct(String typeName, Object[] attributes) throws SQLException { //  Auto-generated method stub return null; }  @Override public void setSchema(String schema) throws SQLException { //  Auto-generated method stub  }  @Override public String getSchema() throws SQLException { //  Auto-generated method stub return null; }  @Override public void abort(Executor executor) throws SQLException { //  Auto-generated method stub  }  @Override public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException { //  Auto-generated method stub  }  @Override public int getNetworkTimeout() throws SQLException { //  Auto-generated method stub return 0; }  public DatabaseChangeRegistration registerDatabaseChangeNotification(@SuppressWarnings("unused") Properties properties) { return new DatabaseChangeRegistration(); }  public void unregisterDatabaseChangeNotification(@SuppressWarnings("unused") DatabaseChangeRegistration databaseChangeRegistration) { // do nothing } }"
"public class OracleDriver { // no data }"
"public class OracleStatement {  public void setDatabaseChangeRegistration(@SuppressWarnings("unused") DatabaseChangeRegistration registration) { // do nothing } }"
"package oracle.jdbc;"

"public @interface ApacheCommonsLang3Allowed {  // The rationale String value();  }"


"public enum BasePanelMode { SHOWING_NOTHING, SHOWING_EDITOR, WILL_SHOW_EDITOR }"
"public void setContent(ClipboardContent content) { clipboard.setContent(content); }"
"public String getContents() { String result = clipboard.getString(); if (result == null) { return ""; } return result; }"
"private static Optional<ParserResult> importToOpenBase(String argument) { Optional<ParserResult> result = importFile(argument);  result.ifPresent(ParserResult::setToOpenTab);  return result; }"
"private Optional<ParserResult> fetch(String fetchCommand) { if ((fetchCommand == null) || !fetchCommand.contains(":") || (fetchCommand.split(":").length != 2)) { System.out.println(Localization.lang("Expected syntax for --fetch='<name of fetcher>:<query>'")); System.out.println(Localization.lang("The following fetchers are available:")); return Optional.empty(); }  String[] split = fetchCommand.split(":"); String engine = split[0]; String query = split[1];  List<SearchBasedFetcher> fetchers = WebFetchers.getSearchBasedFetchers(Globals.prefs.getImportFormatPreferences()); Optional<SearchBasedFetcher> selectedFetcher = fetchers.stream() .filter(fetcher -> fetcher.getName().equalsIgnoreCase(engine)) .findFirst(); if (!selectedFetcher.isPresent()) { System.out.println(Localization.lang("Could not find fetcher '%0'", engine));  System.out.println(Localization.lang("The following fetchers are available:")); fetchers.forEach(fetcher -> System.out.println(" " + fetcher.getName()));  return Optional.empty(); } else { System.out.println(Localization.lang("Running query '%0' with fetcher '%1'.", query, engine)); System.out.print(Localization.lang("Please wait...")); try { List<BibEntry> matches = selectedFetcher.get().performSearch(query); if (matches.isEmpty()) { System.out.println("\r" + Localization.lang("No results found.")); return Optional.empty(); } else { System.out.println("\r" + Localization.lang("Found %0 results.", String.valueOf(matches.size()))); return Optional.of(new ParserResult(matches)); } } catch (FetcherException e) { LOGGER.error("Error while fetching", e); return Optional.empty(); } } }"



















"public SuggestionProviders getSuggestionProviders() { return suggestionProviders; }"
"private void copyCitationToClipboard(CitationStyleOutputFormat outputFormat) { CitationStyleToClipboardWorker worker = new CitationStyleToClipboardWorker(this, outputFormat, dialogService, Globals.clipboardManager, Globals.prefs.getPreviewPreferences()); worker.copyCitationStyleToClipboard(Globals.TASK_EXECUTOR); }"
"public void delete(boolean cut) { delete(cut, mainTable.getSelectedEntries()); }"
"public void runCommand(final Actions command) { if (!actions.containsKey(command)) { LOGGER.info("No action defined for '" + command + '\''); return; }  BaseAction action = actions.get(command); try { action.action(); } catch (Throwable ex) { LOGGER.error("runCommand error: " + ex.getMessage(), ex); } }"
"public void insertEntry(final BibEntry bibEntry) { if (bibEntry != null) { try { bibDatabaseContext.getDatabase().insertEntry(bibEntry);  // Set owner and timestamp UpdateField.setAutomaticFields(bibEntry, true, true, Globals.prefs.getUpdateFieldPreferences());  // Create an UndoableInsertEntry object. getUndoManager().addEdit(new UndoableInsertEntry(bibDatabaseContext.getDatabase(), bibEntry)); output(Localization.lang("Added new '%0' entry.", bibEntry.getType().getDisplayName()));  markBaseChanged(); // The database just changed. if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_OPEN_FORM)) { showAndEdit(bibEntry); } clearAndSelect(bibEntry); } catch (KeyCollisionException ex) { LOGGER.info("Collision for bibtex key" + bibEntry.getId(), ex); } } }"
"private void setupAutoCompletion() { AutoCompletePreferences autoCompletePreferences = preferences.getAutoCompletePreferences(); if (autoCompletePreferences.shouldAutoComplete()) { suggestionProviders = new SuggestionProviders(autoCompletePreferences, Globals.journalAbbreviationLoader); suggestionProviders.indexDatabase(getDatabase()); // Ensure that the suggestion providers are in sync with entries CoarseChangeFilter changeFilter = new CoarseChangeFilter(bibDatabaseContext); changeFilter.registerListener(new AutoCompleteUpdater(suggestionProviders)); } else { // Create empty suggestion providers if auto completion is deactivated suggestionProviders = new SuggestionProviders(); } }"
"public void showAndEdit(BibEntry entry) { showBottomPane(BasePanelMode.SHOWING_EDITOR);  if (entry != getShowing()) { entryEditor.setEntry(entry); showing = entry; } entryEditor.requestFocus(); }"
"public void clearAndSelect(final BibEntry bibEntry) { mainTable.clearAndSelect(bibEntry); }"
"public void entryEditorClosing() { closeBottomPane(); mainTable.requestFocus(); }"
"private void ensureNotShowingBottomPanel(BibEntry entry) { if (((mode == BasePanelMode.SHOWING_EDITOR) && (entryEditor.getEntry() == entry))) { closeBottomPane(); } }"
"private void saveDividerLocation(Number position) { if (position == null) { return; }  if (mode == BasePanelMode.SHOWING_EDITOR) { preferences.setEntryEditorDividerPosition(position.doubleValue()); } }"
"public List<BibEntry> getSelectedEntries() { return mainTable.getSelectedEntries(); }"
"public void setCurrentSearchQuery(Optional<SearchQuery> currentSearchQuery) { this.currentSearchQuery = currentSearchQuery; }"
"private class SearchAutoCompleteListener {  @Subscribe public void listen(EntryAddedEvent addedEntryEvent) { DefaultTaskExecutor.runInJavaFXThread(() -> searchAutoCompleter.indexEntry(addedEntryEvent.getBibEntry())); }  @Subscribe public void listen(EntryChangedEvent entryChangedEvent) { DefaultTaskExecutor.runInJavaFXThread(() -> searchAutoCompleter.indexEntry(entryChangedEvent.getBibEntry())); } }"
"private class SearchListener {  @Subscribe public void listen(EntryAddedEvent addedEntryEvent) { DefaultTaskExecutor.runInJavaFXThread(() -> frame.getGlobalSearchBar().performSearch()); }  @Subscribe public void listen(EntryChangedEvent entryChangedEvent) { DefaultTaskExecutor.runInJavaFXThread(() -> frame.getGlobalSearchBar().performSearch()); }  @Subscribe public void listen(EntryRemovedEvent removedEntryEvent) { // IMO only used to update the status (found X entries) DefaultTaskExecutor.runInJavaFXThread(() -> frame.getGlobalSearchBar().performSearch()); } }"











































"public class CrossrefFetcherEvaluator {  private CrossrefFetcherEvaluator() { }  public static void main(String[] args) throws IOException, InterruptedException { Globals.prefs = JabRefPreferences.getInstance(); try (FileReader reader = new FileReader(args[0])) { BibtexParser parser = new BibtexParser(Globals.prefs.getImportFormatPreferences(), Globals.getFileUpdateMonitor()); ParserResult result = parser.parse(reader); BibDatabase db = result.getDatabase();  List<BibEntry> entries = db.getEntries();  AtomicInteger dois = new AtomicInteger(); AtomicInteger doiFound = new AtomicInteger(); AtomicInteger doiNew = new AtomicInteger(); AtomicInteger doiIdentical = new AtomicInteger();  int total = entries.size();  CountDownLatch countDownLatch = new CountDownLatch(total);  ExecutorService executorService = Executors.newFixedThreadPool(5);  for (BibEntry entry : entries) { executorService.execute(new Runnable() {  @Override public void run() { Optional<DOI> origDOI = entry.getField(StandardField.DOI).flatMap(DOI::parse); if (origDOI.isPresent()) { dois.incrementAndGet(); try { Optional<DOI> crossrefDOI = new CrossRef().findIdentifier(entry); if (crossrefDOI.isPresent()) { doiFound.incrementAndGet(); if (origDOI.get().getDOI().equalsIgnoreCase(crossrefDOI.get().getDOI())) { doiIdentical.incrementAndGet(); } else { System.out.println("DOI not identical for : " + entry); } } else { System.out.println("DOI not found for: " + entry); } } catch (FetcherException e) { e.printStackTrace(); }  } else { try { Optional<DOI> crossrefDOI = new CrossRef().findIdentifier(entry); if (crossrefDOI.isPresent()) { System.out.println("New DOI found for: " + entry); doiNew.incrementAndGet(); } } catch (FetcherException e) { e.printStackTrace(); } } countDownLatch.countDown(); } });  } countDownLatch.await();  System.out.println("---------------------------------"); System.out.println("Total DB size: " + total); System.out.println("Total DOIs: " + dois); System.out.println("DOIs found: " + doiFound); System.out.println("DOIs identical: " + doiIdentical); System.out.println("New DOIs found: " + doiNew);  executorService.shutdown(); } } }"
"private static Object createDependency(Class<?> clazz) { if (clazz == DialogService.class) { return JabRefGUI.getMainFrame().getDialogService(); } else if (clazz == TaskExecutor.class) { return Globals.TASK_EXECUTOR; } else if (clazz == PreferencesService.class) { return Globals.prefs; } else if (clazz == KeyBindingRepository.class) { return Globals.getKeyPrefs(); } else if (clazz == JournalAbbreviationLoader.class) { return Globals.journalAbbreviationLoader; } else if (clazz == StateManager.class) { return Globals.stateManager; } else if (clazz == FileUpdateMonitor.class) { return Globals.getFileUpdateMonitor(); } else if (clazz == ProtectedTermsLoader.class) { return Globals.protectedTermsLoader; } else if (clazz == ClipBoardManager.class) { return Globals.clipboardManager; } else if (clazz == UndoManager.class) { return Globals.undoManager; } else { try { return clazz.newInstance(); } catch (InstantiationException | IllegalAccessException ex) { LOGGER.error("Cannot instantiate dependency: " + clazz, ex); return null; } } }"

"public interface DialogService {  /** * This will create and display new {@link ChoiceDialog} of type T with a default choice and a collection of possible choices * * @implNote The implementation should accept {@code null} for {@code defaultChoice}, but callers should use {@link #showChoiceDialogAndWait(String, String, String, Collection)}. */ <T> Optional<T> showChoiceDialogAndWait(String title, String content, String okButtonLabel, T defaultChoice, Collection<T> choices);  /** * This will create and display new {@link ChoiceDialog} of type T with a collection of possible choices */ default <T> Optional<T> showChoiceDialogAndWait(String title, String content, String okButtonLabel, Collection<T> choices) { return showChoiceDialogAndWait(title, content, okButtonLabel, null, choices); }  /** * This will create and display new {@link TextInputDialog} with a text fields to enter data */ Optional<String> showInputDialogAndWait(String title, String content);  /** * This will create and display new {@link TextInputDialog} with a text field with a default value to enter data */ Optional<String> showInputDialogWithDefaultAndWait(String title, String content, String defaultValue);  /** * This will create and display a new information dialog. * It will include a blue information icon on the left and * a single OK Button. To create an information dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)} */ void showInformationDialogAndWait(String title, String content);  /** * This will create and display a new information dialog. * It will include a yellow warning icon on the left and * a single OK Button. To create a warning dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)} */ void showWarningDialogAndWait(String title, String content);  /** * This will create and display a new error dialog. * It will include a red error icon on the left and * a single OK Button. To create a error dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)} */ void showErrorDialogAndWait(String title, String content);  /** * Create and display error dialog displaying the given exception. * * @param message   the error message * @param exception the exception causing the error */ void showErrorDialogAndWait(String message, Throwable exception);  /** * Create and display error dialog displaying the given exception. * * @param exception the exception causing the error */ default void showErrorDialogAndWait(Exception exception) { showErrorDialogAndWait(Localization.lang("Unhandled exception occurred."), exception); }  /** * Create and display error dialog displaying the given exception. * * @param exception the exception causing the error */ void showErrorDialogAndWait(String title, String content, Throwable exception);  /** * Create and display error dialog displaying the given message. * * @param message the error message */ void showErrorDialogAndWait(String message);  /** * This will create and display a new confirmation dialog. * It will include a blue question icon on the left and * a OK and Cancel button. To create a confirmation dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)} * * @return true if the use clicked "OK" otherwise false */ boolean showConfirmationDialogAndWait(String title, String content);  /** * Create and display a new confirmation dialog. * It will include a blue question icon on the left and * a OK (with given label) and Cancel button. To create a confirmation dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)}. * * @return true if the use clicked "OK" otherwise false */ boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel);  /** * Create and display a new confirmation dialog. * It will include a blue question icon on the left and * a OK (with given label) and Cancel (also with given label) button. To create a confirmation dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)}. * * @return true if the use clicked "OK" otherwise false */ boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel);  /** * Create and display a new confirmation dialog. * It will include a blue question icon on the left and * a YES (with given label) and Cancel (also with given label) button. To create a confirmation dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)}. * Moreover, the dialog contains a opt-out checkbox with the given text to support "Do not ask again"-behaviour. * * @return true if the use clicked "YES" otherwise false */ boolean showConfirmationDialogWithOptOutAndWait(String title, String content, String optOutMessage, Consumer<Boolean> optOutAction);  /** * Create and display a new confirmation dialog. * It will include a blue question icon on the left and * a YES (with given label) and Cancel (also with given label) button. To create a confirmation dialog with custom * buttons see also {@link #showCustomButtonDialogAndWait(Alert.AlertType, String, String, ButtonType...)}. * Moreover, the dialog contains a opt-out checkbox with the given text to support "Do not ask again"-behaviour. * * @return true if the use clicked "YES" otherwise false */ boolean showConfirmationDialogWithOptOutAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel, String optOutMessage, Consumer<Boolean> optOutAction);  /** * This will create and display a new dialog of the specified * {@link Alert.AlertType} but with user defined buttons as optional * {@link ButtonType}s. * * @return Optional with the pressed Button as ButtonType */ Optional<ButtonType> showCustomButtonDialogAndWait(Alert.AlertType type, String title, String content, ButtonType... buttonTypes);  /** * This will create and display a new dialog showing a custom {@link DialogPane} * and using custom {@link ButtonType}s. * * @return Optional with the pressed Button as ButtonType */ Optional<ButtonType> showCustomDialogAndWait(String title, DialogPane contentPane, ButtonType... buttonTypes);  /** * Shows a custom dialog and returns the result. * * @param dialog dialog to show * @param <R>    type of result */ <R> Optional<R> showCustomDialogAndWait(Dialog<R> dialog);  /** * Constructs and shows a canceable {@link ProgressDialog}. Clicking cancel will cancel the underlying service and close the dialog * * @param title title of the dialog * @param content message to show above the progress bar * @param task The {@link Task} which executes the work and for which to show the dialog */ <V> void showProgressDialogAndWait(String title, String content, Task<V> task);  /** * Notify the user in an non-blocking way (i.e., in form of toast in a snackbar). * * @param message the message to show. */ void notify(String message);  /** * Shows a new file save dialog. The method doesn't return until the * displayed file save dialog is dismissed. The return value specifies the * file chosen by the user or an empty {@link Optional} if no selection has been made. * After a file was selected, the given file dialog configuration is updated with the selected extension type (if any). * * @return the selected file or an empty {@link Optional} if no file has been selected */ Optional<Path> showFileSaveDialog(FileDialogConfiguration fileDialogConfiguration);  /** * Shows a new file open dialog. The method doesn't return until the * displayed open dialog is dismissed. The return value specifies * the file chosen by the user or an empty {@link Optional} if no selection has been * made. * After a file was selected, the given file dialog configuration is updated with the selected extension type (if any). * * @return the selected file or an empty {@link Optional} if no file has been selected */ Optional<Path> showFileOpenDialog(FileDialogConfiguration fileDialogConfiguration);  /** * Shows a new file open dialog. The method doesn't return until the * displayed open dialog is dismissed. The return value specifies * the files chosen by the user or an empty {@link List} if no selection has been * made. * * @return the selected files or an empty {@link List} if no file has been selected */ List<Path> showFileOpenDialogAndGetMultipleFiles(FileDialogConfiguration fileDialogConfiguration);  /** * Shows a new directory selection dialog. The method doesn't return until the * displayed open dialog is dismissed. The return value specifies * the file chosen by the user or an empty {@link Optional} if no selection has been * made. * * @return the selected directory or an empty {@link Optional} if no directory has been selected */ Optional<Path> showDirectorySelectionDialog(DirectoryDialogConfiguration directoryDialogConfiguration);  /** * Displays a Print Dialog. Allow the user to update job state such as printer and settings. These changes will be * available in the appropriate properties after the print dialog has returned. The print dialog is also used to * confirm the user wants to proceed with printing. * * @param job the print job to customize * @return false if the user opts to cancel printing */ boolean showPrintDialog(PrinterJob job);  /** * Shows a new dialog that list all files contained in the given archive and which lets the user select one of these * files. The method doesn't return until the displayed open dialog is dismissed. The return value specifies the * file chosen by the user or an empty {@link Optional} if no selection has been made. * * @return the selected file or an empty {@link Optional} if no file has been selected */ Optional<Path> showFileOpenFromArchiveDialog(Path archivePath) throws IOException; }"
"<T> Optional<T> showChoiceDialogAndWait(String title, String content, String okButtonLabel, T defaultChoice, Collection<T> choices);"
"Optional<String> showInputDialogAndWait(String title, String content);"
"Optional<String> showInputDialogWithDefaultAndWait(String title, String content, String defaultValue);"
"void showInformationDialogAndWait(String title, String content);"
"void showWarningDialogAndWait(String title, String content);"
"void showErrorDialogAndWait(String title, String content);"
"void showErrorDialogAndWait(String message, Throwable exception);"
"void showErrorDialogAndWait(String title, String content, Throwable exception);"
"void showErrorDialogAndWait(String message);"
"boolean showConfirmationDialogAndWait(String title, String content);"
"boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel);"
"boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel);"
"boolean showConfirmationDialogWithOptOutAndWait(String title, String content, String optOutMessage, Consumer<Boolean> optOutAction);"
"boolean showConfirmationDialogWithOptOutAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel, String optOutMessage, Consumer<Boolean> optOutAction);"
"<R> Optional<R> showCustomDialogAndWait(Dialog<R> dialog);"
"<V> void showProgressDialogAndWait(String title, String content, Task<V> task);"
"void notify(String message);"
"Optional<Path> showFileSaveDialog(FileDialogConfiguration fileDialogConfiguration);"
"Optional<Path> showFileOpenDialog(FileDialogConfiguration fileDialogConfiguration);"
" List<Path> showFileOpenDialogAndGetMultipleFiles(FileDialogConfiguration fileDialogConfiguration);"
"Optional<Path> showDirectorySelectionDialog(DirectoryDialogConfiguration directoryDialogConfiguration);"
"boolean showPrintDialog(PrinterJob job);"
"Optional<Path> showFileOpenFromArchiveDialog(Path archivePath) throws IOException;"
" public class DragAndDropDataFormats {  public static final DataFormat GROUP = new DataFormat("dnd/org.jabref.model.groups.GroupTreeNode"); public static final DataFormat LINKED_FILE = new DataFormat("dnd/org.jabref.model.entry.LinkedFile"); public static final DataFormat ENTRIES = new DataFormat("dnd/org.jabref.model.entry.BibEntries"); public static final DataFormat PREVIEWLAYOUTS = new DataFormat("dnd/org.jabref.logic.citationstyle.PreviewLayouts"); @SuppressWarnings("unchecked") public static final Class<List<PreviewLayout>> PREVIEWLAYOUT_LIST_CLASS = (Class<List<PreviewLayout>>) (Class<?>) List.class; }"
"public class EntryTypeView extends BaseDialog<EntryType> {  @FXML private ButtonType generateButton; @FXML private TextField idTextField; @FXML private ComboBox<IdBasedFetcher> idBasedFetchers; @FXML private FlowPane biblatexPane; @FXML private FlowPane bibTexPane; @FXML private FlowPane ieeetranPane; @FXML private FlowPane customPane; @FXML private TitledPane biblatexTitlePane; @FXML private TitledPane bibTexTitlePane; @FXML private TitledPane ieeeTranTitlePane; @FXML private TitledPane customTitlePane;  private final BasePanel basePanel; private final DialogService dialogService; private final JabRefPreferences prefs;  private EntryType type; private EntryTypeViewModel viewModel;  public EntryTypeView(BasePanel basePanel, DialogService dialogService, JabRefPreferences preferences) { this.basePanel = basePanel; this.dialogService = dialogService; this.prefs = preferences;  this.setTitle(Localization.lang("Select entry type")); ViewLoader.view(this) .load() .setAsDialogPane(this);  ControlHelper.setAction(generateButton, this.getDialogPane(), event -> viewModel.runFetcherWorker());  setResultConverter(button -> { //The buttonType will always be cancel, even if we pressed one of the entry type buttons return type; });  Button btnGenerate = (Button) this.getDialogPane().lookupButton(generateButton);  btnGenerate.textProperty().bind(EasyBind.map(viewModel.searchingProperty(), searching -> (searching) ? Localization.lang("Searching...") : Localization.lang("Generate"))); btnGenerate.disableProperty().bind(viewModel.searchingProperty());  EasyBind.subscribe(viewModel.searchSuccesfulProperty(), value -> { if (value) { setEntryTypeForReturnAndClose(Optional.empty()); } });  }  private void addEntriesToPane(FlowPane pane, Collection<? extends BibEntryType> entries) { for (BibEntryType entryType : entries) { Button entryButton = new Button(entryType.getType().getDisplayName()); entryButton.setUserData(entryType); entryButton.setOnAction(event -> setEntryTypeForReturnAndClose(Optional.of(entryType))); pane.getChildren().add(entryButton); } }  @FXML public void initialize() { viewModel = new EntryTypeViewModel(prefs, basePanel, dialogService);  idBasedFetchers.itemsProperty().bind(viewModel.fetcherItemsProperty()); idTextField.textProperty().bindBidirectional(viewModel.idTextProperty()); idBasedFetchers.valueProperty().bindBidirectional(viewModel.selectedItemProperty());  EasyBind.subscribe(viewModel.getFocusAndSelectAllProperty(), evt -> { if (evt) { idTextField.requestFocus(); idTextField.selectAll(); } });  new ViewModelListCellFactory<IdBasedFetcher>().withText(item -> item.getName()).install(idBasedFetchers);  //we set the managed property so that they will only be rendered when they are visble so that the Nodes only take the space when visible //avoids removing and adding from the scence graph bibTexTitlePane.managedProperty().bind(bibTexTitlePane.visibleProperty()); ieeeTranTitlePane.managedProperty().bind(ieeeTranTitlePane.visibleProperty()); biblatexTitlePane.managedProperty().bind(biblatexTitlePane.visibleProperty()); customTitlePane.managedProperty().bind(customTitlePane.visibleProperty());  if (basePanel.getBibDatabaseContext().isBiblatexMode()) { addEntriesToPane(biblatexPane, BiblatexEntryTypeDefinitions.ALL);  bibTexTitlePane.setVisible(false); ieeeTranTitlePane.setVisible(false);  List<BibEntryType> customTypes = Globals.entryTypesManager.getAllCustomTypes(BibDatabaseMode.BIBLATEX); if (customTypes.isEmpty()) { customTitlePane.setVisible(false); } else { addEntriesToPane(customPane, customTypes); }  } else { biblatexTitlePane.setVisible(false); addEntriesToPane(bibTexPane, BibtexEntryTypeDefinitions.ALL); addEntriesToPane(ieeetranPane, IEEETranEntryTypeDefinitions.ALL);  List<BibEntryType> customTypes = Globals.entryTypesManager.getAllCustomTypes(BibDatabaseMode.BIBTEX); if (customTypes.isEmpty()) { customTitlePane.setVisible(false); } else { addEntriesToPane(customPane, customTypes); } }  Platform.runLater(() -> idTextField.requestFocus()); }  public EntryType getChoice() { return type; }  @FXML private void runFetcherWorker(Event event) { viewModel.runFetcherWorker(); }  @FXML private void focusTextField(Event event) { idTextField.requestFocus(); idTextField.selectAll(); }  private void setEntryTypeForReturnAndClose(Optional<BibEntryType> entryType) { type = entryType.map(BibEntryType::getType).orElse(null); viewModel.stopFetching(); this.close(); } }"



"public class FXDialog extends Alert {  public FXDialog(AlertType type, String title, Image image, boolean isModal) { this(type, title, isModal); setDialogIcon(image); }  public FXDialog(AlertType type, String title, Image image) { this(type, title, true); setDialogIcon(image); }  public FXDialog(AlertType type, String title, boolean isModal) { this(type, isModal); setTitle(title); }  public FXDialog(AlertType type, String title) { this(type); setTitle(title); }  public FXDialog(AlertType type, boolean isModal) { super(type);  setDialogIcon(IconTheme.getJabRefImageFX());  Stage dialogWindow = getDialogWindow(); dialogWindow.setOnCloseRequest(evt -> this.close()); if (isModal) { initModality(Modality.APPLICATION_MODAL); } else { initModality(Modality.NONE); }  dialogWindow.getScene().setOnKeyPressed(event -> { KeyBindingRepository keyBindingRepository = Globals.getKeyPrefs(); if (keyBindingRepository.checkKeyCombinationEquality(KeyBinding.CLOSE, event)) { dialogWindow.close(); } }); }  public FXDialog(AlertType type) { this(type, true); }  private void setDialogIcon(Image image) { Stage fxDialogWindow = getDialogWindow(); fxDialogWindow.getIcons().add(image); }  private Stage getDialogWindow() { return (Stage) getDialogPane().getScene().getWindow(); }  }"
" public static JournalAbbreviationLoader journalAbbreviationLoader;"
"public static ProtectedTermsLoader protectedTermsLoader;"
" public static ClipBoardManager clipboardManager = new ClipBoardManager();"






"public class GUIGlobals {  public static Color editorTextColor; public static Color validFieldBackgroundColor; public static Color activeBackgroundColor; public static Color invalidFieldBackgroundColor; public static Font currentFont;  public static CustomLocalDragboard localDragboard = new CustomLocalDragboard();  public static final int WIDTH_ICON_COL = 16 + 12; // add some additional space to improve appearance  public static final int WIDTH_ICON_COL_RANKING = 5 * 16; // Width of Ranking Icon Column  public static final String UNTITLED_TITLE = Localization.lang("untitled");  private GUIGlobals() { }  public static void updateEntryEditorColors() { GUIGlobals.activeBackgroundColor = JabRefPreferences.getInstance().getColor(JabRefPreferences.ACTIVE_FIELD_EDITOR_BACKGROUND_COLOR); GUIGlobals.validFieldBackgroundColor = JabRefPreferences.getInstance().getColor(JabRefPreferences.VALID_FIELD_BACKGROUND_COLOR); GUIGlobals.invalidFieldBackgroundColor = JabRefPreferences.getInstance().getColor(JabRefPreferences.INVALID_FIELD_BACKGROUND_COLOR); GUIGlobals.editorTextColor = JabRefPreferences.getInstance().getColor(JabRefPreferences.FIELD_EDITOR_TEXT_COLOR); }  /** * Perform initializations that are only used in graphical mode. This is to prevent * the "Xlib: connection to ":0.0" refused by server" error when access to the X server * on Un*x is unavailable. */ public static void init() { // Set up entry editor colors, first time: GUIGlobals.updateEntryEditorColors();  IconTheme.loadFonts(); GUIGlobals.currentFont = new Font(Globals.prefs.getFontFamily(), Globals.prefs.getDouble(JabRefPreferences.FONT_SIZE)); }  public static void setFont(double size) { currentFont = new Font(currentFont.getFamily(), size); // update preferences Globals.prefs.putInt(JabRefPreferences.FONT_SIZE, size); } }"
"public static void init() { // Set up entry editor colors, first time: GUIGlobals.updateEntryEditorColors();  IconTheme.loadFonts(); GUIGlobals.currentFont = new Font(Globals.prefs.getFontFamily(), Globals.prefs.getDouble(JabRefPreferences.FONT_SIZE)); }"






"public class JabRefDialogService implements DialogService { // Snackbar dialog maximum size public static final int DIALOG_SIZE_LIMIT = 300;  private static final Duration TOAST_MESSAGE_DISPLAY_TIME = Duration.millis(3000); private static final Logger LOGGER = LoggerFactory.getLogger(JabRefDialogService.class); private final Window mainWindow; private final JFXSnackbar statusLine;  public JabRefDialogService(Window mainWindow, Pane mainPane) { this.mainWindow = mainWindow; this.statusLine = new JFXSnackbar(mainPane); }  private static FXDialog createDialog(AlertType type, String title, String content) { FXDialog alert = new FXDialog(type, title, true); alert.setHeaderText(null); alert.setContentText(content); alert.getDialogPane().setMinHeight(Region.USE_PREF_SIZE); return alert; }  private static FXDialog createDialogWithOptOut(AlertType type, String title, String content, String optOutMessage, Consumer<Boolean> optOutAction) { FXDialog alert = new FXDialog(type, title, true); // Need to force the alert to layout in order to grab the graphic as we are replacing the dialog pane with a custom pane alert.getDialogPane().applyCss(); Node graphic = alert.getDialogPane().getGraphic();  // Create a new dialog pane that has a checkbox instead of the hide/show details button // Use the supplied callback for the action of the checkbox alert.setDialogPane(new DialogPane() {  @Override protected Node createDetailsButton() { CheckBox optOut = new CheckBox(); optOut.setText(optOutMessage); optOut.setOnAction(e -> optOutAction.accept(optOut.isSelected())); return optOut; } });  // Fool the dialog into thinking there is some expandable content; a group won't take up any space if it has no children alert.getDialogPane().setExpandableContent(new Group()); alert.getDialogPane().setExpanded(true);  // Reset the dialog graphic using the default style alert.getDialogPane().setGraphic(graphic);  alert.setHeaderText(null); alert.setContentText(content); alert.getDialogPane().setMinHeight(Region.USE_PREF_SIZE); return alert; }  public static String shortenDialogMessage(String dialogMessage) { if (dialogMessage.length() < JabRefDialogService.DIALOG_SIZE_LIMIT) { return dialogMessage.trim(); } return (dialogMessage.substring(0, Math.min(dialogMessage.length(), JabRefDialogService.DIALOG_SIZE_LIMIT)) + "...").trim(); }  @Override public <T> Optional<T> showChoiceDialogAndWait(String title, String content, String okButtonLabel, T defaultChoice, Collection<T> choices) { ChoiceDialog<T> choiceDialog = new ChoiceDialog<>(defaultChoice, choices); ButtonType okButtonType = new ButtonType(okButtonLabel, ButtonBar.ButtonData.OK_DONE); choiceDialog.getDialogPane().getButtonTypes().setAll(ButtonType.CANCEL, okButtonType); choiceDialog.setHeaderText(title); choiceDialog.setTitle(title); choiceDialog.setContentText(content); return choiceDialog.showAndWait(); }  @Override public Optional<String> showInputDialogAndWait(String title, String content) { TextInputDialog inputDialog = new TextInputDialog(); inputDialog.setHeaderText(title); inputDialog.setContentText(content); return inputDialog.showAndWait(); }  @Override public Optional<String> showInputDialogWithDefaultAndWait(String title, String content, String defaultValue) { TextInputDialog inputDialog = new TextInputDialog(defaultValue); inputDialog.setHeaderText(title); inputDialog.setContentText(content); return inputDialog.showAndWait(); }  @Override public void showInformationDialogAndWait(String title, String content) { FXDialog alert = createDialog(AlertType.INFORMATION, title, content); alert.showAndWait(); }  @Override public void showWarningDialogAndWait(String title, String content) { FXDialog alert = createDialog(AlertType.WARNING, title, content); alert.showAndWait(); }  @Override public void showErrorDialogAndWait(String title, String content) { FXDialog alert = createDialog(AlertType.ERROR, title, content); alert.showAndWait(); }  @Override public void showErrorDialogAndWait(String message, Throwable exception) { ExceptionDialog exceptionDialog = new ExceptionDialog(exception); exceptionDialog.getDialogPane().setMaxWidth(mainWindow.getWidth() / 2); exceptionDialog.setHeaderText(message); exceptionDialog.showAndWait(); }  @Override public void showErrorDialogAndWait(String title, String content, Throwable exception) { ExceptionDialog exceptionDialog = new ExceptionDialog(exception); exceptionDialog.setHeaderText(title); exceptionDialog.setContentText(content); exceptionDialog.showAndWait(); }  @Override public void showErrorDialogAndWait(String message) { FXDialog alert = createDialog(AlertType.ERROR, Localization.lang("Error Occurred"), message); alert.showAndWait(); }  @Override public boolean showConfirmationDialogAndWait(String title, String content) { FXDialog alert = createDialog(AlertType.CONFIRMATION, title, content); return alert.showAndWait().filter(buttonType -> buttonType == ButtonType.OK).isPresent(); }  @Override public boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel) { FXDialog alert = createDialog(AlertType.CONFIRMATION, title, content); ButtonType okButtonType = new ButtonType(okButtonLabel, ButtonBar.ButtonData.OK_DONE); alert.getButtonTypes().setAll(ButtonType.CANCEL, okButtonType); return alert.showAndWait().filter(buttonType -> buttonType == okButtonType).isPresent(); }  @Override public boolean showConfirmationDialogAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel) { FXDialog alert = createDialog(AlertType.CONFIRMATION, title, content); ButtonType okButtonType = new ButtonType(okButtonLabel, ButtonBar.ButtonData.OK_DONE); ButtonType cancelButtonType = new ButtonType(cancelButtonLabel, ButtonBar.ButtonData.NO); alert.getButtonTypes().setAll(okButtonType, cancelButtonType); return alert.showAndWait().filter(buttonType -> buttonType == okButtonType).isPresent(); }  @Override public boolean showConfirmationDialogWithOptOutAndWait(String title, String content, String optOutMessage, Consumer<Boolean> optOutAction) { FXDialog alert = createDialogWithOptOut(AlertType.CONFIRMATION, title, content, optOutMessage, optOutAction); alert.getButtonTypes().setAll(ButtonType.YES, ButtonType.NO); return alert.showAndWait().filter(buttonType -> buttonType == ButtonType.YES).isPresent(); }  @Override public boolean showConfirmationDialogWithOptOutAndWait(String title, String content, String okButtonLabel, String cancelButtonLabel, String optOutMessage, Consumer<Boolean> optOutAction) { FXDialog alert = createDialogWithOptOut(AlertType.CONFIRMATION, title, content, optOutMessage, optOutAction); ButtonType okButtonType = new ButtonType(okButtonLabel, ButtonBar.ButtonData.YES); ButtonType cancelButtonType = new ButtonType(cancelButtonLabel, ButtonBar.ButtonData.NO); alert.getButtonTypes().setAll(okButtonType, cancelButtonType); return alert.showAndWait().filter(buttonType -> buttonType == okButtonType).isPresent(); }  @Override public Optional<ButtonType> showCustomButtonDialogAndWait(AlertType type, String title, String content, ButtonType... buttonTypes) { FXDialog alert = createDialog(type, title, content); alert.getButtonTypes().setAll(buttonTypes); return alert.showAndWait(); }  @Override public Optional<ButtonType> showCustomDialogAndWait(String title, DialogPane contentPane, ButtonType... buttonTypes) { FXDialog alert = new FXDialog(AlertType.NONE, title); alert.setDialogPane(contentPane); alert.getButtonTypes().setAll(buttonTypes); alert.getDialogPane().setMinHeight(Region.USE_PREF_SIZE); alert.setResizable(true); return alert.showAndWait(); }  @Override public <R> Optional<R> showCustomDialogAndWait(Dialog<R> dialog) { return dialog.showAndWait(); }  @Override public <V> void showProgressDialogAndWait(String title, String content, Task<V> task) { ProgressDialog progressDialog = new ProgressDialog(task); progressDialog.setHeaderText(null); progressDialog.setTitle(title); progressDialog.setContentText(content); progressDialog.setGraphic(null); ((Stage) progressDialog.getDialogPane().getScene().getWindow()).getIcons().add(IconTheme.getJabRefImageFX()); progressDialog.setOnCloseRequest(evt -> task.cancel()); DialogPane dialogPane = progressDialog.getDialogPane(); dialogPane.getButtonTypes().add(ButtonType.CANCEL); Button cancelButton = (Button) dialogPane.lookupButton(ButtonType.CANCEL); cancelButton.setOnAction(evt -> { task.cancel(); progressDialog.close(); }); progressDialog.show(); }  @Override public void notify(String message) { LOGGER.info(message); statusLine.fireEvent(new SnackbarEvent(new JFXSnackbarLayout(message), TOAST_MESSAGE_DISPLAY_TIME, null)); }  @Override public Optional<Path> showFileSaveDialog(FileDialogConfiguration fileDialogConfiguration) { FileChooser chooser = getConfiguredFileChooser(fileDialogConfiguration); File file = chooser.showSaveDialog(mainWindow); Optional.ofNullable(chooser.getSelectedExtensionFilter()).ifPresent(fileDialogConfiguration::setSelectedExtensionFilter); return Optional.ofNullable(file).map(File::toPath); }  @Override public Optional<Path> showFileOpenDialog(FileDialogConfiguration fileDialogConfiguration) { FileChooser chooser = getConfiguredFileChooser(fileDialogConfiguration); File file = chooser.showOpenDialog(mainWindow); Optional.ofNullable(chooser.getSelectedExtensionFilter()).ifPresent(fileDialogConfiguration::setSelectedExtensionFilter); return Optional.ofNullable(file).map(File::toPath); }  @Override public Optional<Path> showDirectorySelectionDialog(DirectoryDialogConfiguration directoryDialogConfiguration) { DirectoryChooser chooser = getConfiguredDirectoryChooser(directoryDialogConfiguration); File file = chooser.showDialog(mainWindow); return Optional.ofNullable(file).map(File::toPath); }  @Override public List<Path> showFileOpenDialogAndGetMultipleFiles(FileDialogConfiguration fileDialogConfiguration) { FileChooser chooser = getConfiguredFileChooser(fileDialogConfiguration); List<File> files = chooser.showOpenMultipleDialog(mainWindow); return files != null ? files.stream().map(File::toPath).collect(Collectors.toList()) : Collections.emptyList(); }  private DirectoryChooser getConfiguredDirectoryChooser(DirectoryDialogConfiguration directoryDialogConfiguration) { DirectoryChooser chooser = new DirectoryChooser(); directoryDialogConfiguration.getInitialDirectory().map(Path::toFile).ifPresent(chooser::setInitialDirectory); return chooser; }  private FileChooser getConfiguredFileChooser(FileDialogConfiguration fileDialogConfiguration) { FileChooser chooser = new FileChooser(); chooser.getExtensionFilters().addAll(fileDialogConfiguration.getExtensionFilters()); chooser.setSelectedExtensionFilter(fileDialogConfiguration.getDefaultExtension()); chooser.setInitialFileName(fileDialogConfiguration.getInitialFileName()); fileDialogConfiguration.getInitialDirectory().map(Path::toFile).ifPresent(chooser::setInitialDirectory); return chooser; }  @Override public boolean showPrintDialog(PrinterJob job) { return job.showPrintDialog(mainWindow); }  @Override public Optional<Path> showFileOpenFromArchiveDialog(Path archivePath) throws IOException { try (FileSystem zipFile = FileSystems.newFileSystem(archivePath, null)) { return new ZipFileChooser(zipFile).showAndWait(); } catch (NoClassDefFoundError exc) { throw new IOException("Could not instantiate ZIP-archive reader.", exc); } } }"



"public class JabRefLauncher { public static void main(String[] args) { JabRefMain.main(args); } }"
"public class SidePane extends BorderPane {  private final VBox mainPanel = new VBox();  public SidePane() { setId("sidePane"); setCenter(mainPanel); }  public void setComponents(Collection<SidePaneComponent> components) { mainPanel.getChildren().clear();  for (SidePaneComponent component : components) { BorderPane node = new BorderPane(); node.getStyleClass().add("sidePaneComponent"); node.setTop(component.getHeader()); node.setCenter(component.getContentPane()); mainPanel.getChildren().add(node); VBox.setVgrow(node, component.getResizePolicy()); } } }"
"public void beforeClosing() { // Nothing to do by default }"
"public void afterOpening() { // Nothing to do by default }"























































"public void savePartOfDatabase(BibDatabaseContext bibDatabaseContext, List<BibEntry> entries) throws IOException { Optional<String> sharedDatabaseIDOptional = bibDatabaseContext.getDatabase().getSharedDatabaseID();  if (sharedDatabaseIDOptional.isPresent()) { writeDatabaseID(sharedDatabaseIDOptional.get()); }  // Map to collect entry type definitions that we must save along with entries using them. Set<BibEntryType> typesToWrite = new HashSet<>();  // Some file formats write something at the start of the file (like the encoding) if (preferences.getSaveType() != SavePreferences.DatabaseSaveType.PLAIN_BIBTEX) { writePrelogue(bibDatabaseContext, preferences.getEncoding()); }  // Write preamble if there is one. writePreamble(bibDatabaseContext.getDatabase().getPreamble().orElse(""));  // Write strings if there are any. writeStrings(bibDatabaseContext.getDatabase());  // Write database entries. List<BibEntry> sortedEntries = getSortedEntries(bibDatabaseContext, entries, preferences); List<FieldChange> saveActionChanges = applySaveActions(sortedEntries, bibDatabaseContext.getMetaData()); saveActionsFieldChanges.addAll(saveActionChanges); if (preferences.generateBibtexKeysBeforeSaving()) { List<FieldChange> keyChanges = generateBibtexKeys(bibDatabaseContext, sortedEntries); saveActionsFieldChanges.addAll(keyChanges); }  for (BibEntry entry : sortedEntries) { // Check if we must write the type definition for this // entry, as well. Our criterion is that all non-standard // types (*not* all customized standard types) must be written. if (entryTypesManager.isCustomType(entry.getType(), bibDatabaseContext.getMode())) { // If user-defined entry type, then add it // Otherwise (enrich returns empty optional) it is a completely unknown entry type, so ignore it entryTypesManager.enrich(entry.getType(), bibDatabaseContext.getMode()).ifPresent(typesToWrite::add); }  writeEntry(entry, bibDatabaseContext.getMode()); }  if (preferences.getSaveType() != SavePreferences.DatabaseSaveType.PLAIN_BIBTEX) { // Write meta data. writeMetaData(bibDatabaseContext.getMetaData(), preferences.getGlobalCiteKeyPattern());  // Write type definitions, if any: writeEntryTypeDefinitions(typesToWrite); }  //finally write whatever remains of the file, but at least a concluding newline writeEpilogue(bibDatabaseContext.getDatabase().getEpilog());  writer.close(); }"
"public class AutosaveEvent { // no data }"
"private final DuplicationChecker duplicationChecker = new DuplicationChecker();"
"protected void writeMetaData(MetaData metaData, GlobalBibtexKeyPattern globalCiteKeyPattern) throws IOException { Objects.requireNonNull(metaData);  Map<String, String> serializedMetaData = MetaDataSerializer.getSerializedStringMap(metaData, globalCiteKeyPattern);  for (Map.Entry<String, String> metaItem : serializedMetaData.entrySet()) { writeMetaDataItem(metaItem); } }"
"public boolean hasEntries() { return !entries.isEmpty(); }"
"public boolean containsEntryWithId(String id) { return internalIDs.contains(id); }"
"public Set<Field> getAllVisibleFields() { Set<Field> allFields = new TreeSet<>(Comparator.comparing(Field::getName)); for (BibEntry e : getEntries()) { allFields.addAll(e.getFields()); } return allFields.stream().filter(field -> !FieldFactory.isInternalField(field)) .collect(Collectors.toSet()); }"
"public synchronized List<BibEntry> getEntriesByKey(String key) { List<BibEntry> result = new ArrayList<>();  for (BibEntry entry : entries) { entry.getCiteKeyOptional().ifPresent(entryKey -> { if (key.equals(entryKey)) { result.add(entry); } }); } return result; }"
"public synchronized boolean insertEntry(BibEntry entry, EntryEventSource eventSource) throws KeyCollisionException { insertEntries(Collections.singletonList(entry), eventSource); return duplicationChecker.isDuplicateCiteKeyExisting(entry); }"
"public synchronized void removeEntry(BibEntry toBeDeleted) { removeEntry(toBeDeleted, EntryEventSource.LOCAL); }"
"public synchronized void setPreamble(String preamble) { this.preamble = preamble; }"
"public void removeString(String id) { bibtexStrings.remove(id); }"
"public BibtexString getString(String id) { return bibtexStrings.get(id); }"
"public boolean hasNoStrings() { return bibtexStrings.isEmpty(); }"
"public void copyPreamble(BibDatabase database) { setPreamble(database.getPreamble().orElse("")); }"
"public BibEntry resolveForStrings(BibEntry entry, boolean inPlace) {  BibEntry resultingEntry; if (inPlace) { resultingEntry = entry; } else { resultingEntry = (BibEntry) entry.clone(); }  for (Map.Entry<Field, String> field : resultingEntry.getFieldMap().entrySet()) { resultingEntry.setField(field.getKey(), this.resolveForStrings(field.getValue())); } return resultingEntry; }"



"private Optional<Path> file;"
"public Optional<Path> getFirstExistingFileDir(FilePreferences preferences) { return getFileDirectoriesAsPaths(preferences).stream().filter(Files::exists).findFirst(); }"




"public BibDatabaseMode getOppositeMode() { if (this == BIBTEX) { return BIBLATEX; } else { return BIBTEX; } }"
"private T parent;"
"private T child;"
"public Optional<T> getParent() { return Optional.ofNullable(parent); }"
"public boolean isAncestorOf(T anotherNode) { Objects.requireNonNull(anotherNode);  if (anotherNode == this) { return true; } else { return child.isAncestorOf(anotherNode); } }"
"public void addAtEnd(T node) { if (child == null) { setChild(node); } else { child.addAtEnd(node); } }"

"public class CoarseChangeFilter {  private final EventBus eventBus = new EventBus(); private Field lastFieldChanged; private final BibDatabaseContext context;  public CoarseChangeFilter(BibDatabaseContext bibDatabaseContext) { // Listen for change events bibDatabaseContext.getDatabase().registerListener(this); bibDatabaseContext.getMetaData().registerListener(this); this.context = bibDatabaseContext; }  @Subscribe public synchronized void listen(@SuppressWarnings("unused") BibDatabaseContextChangedEvent event) { if (!(event instanceof FieldChangedEvent)) { eventBus.post(event); } else { // Only relay event if the field changes are more than one character or a new field is edited FieldChangedEvent fieldChange = (FieldChangedEvent) event; boolean isEditOnNewField = lastFieldChanged == null || !lastFieldChanged.equals(fieldChange.getField());  if (fieldChange.getDelta() > 1 || isEditOnNewField) { lastFieldChanged = fieldChange.getField(); eventBus.post(event); } } }  public void registerListener(Object listener) { eventBus.register(listener); }  public void unregisterListener(Object listener) { eventBus.unregister(listener); }  public void shutdown() { context.getDatabase().unregisterListener(this); context.getMetaData().unregisterListener(this); } }"


"public class DatabaseNotSupportedException extends Exception {  public DatabaseNotSupportedException() { super("The structure of the SQL database is not supported."); } }"

"private final Map<String, Integer> allKeys = new HashMap<>();"
"private void removeKeyFromSet(String key) { if (key == null || key.isEmpty()) { return; }  int numberOfKeyOccurrences = getNumberOfKeyOccurrences(key); if (numberOfKeyOccurrences > 1) { allKeys.put(key, numberOfKeyOccurrences - 1); } else { allKeys.remove(key); } }"
"private List<FieldChange> cleanupSingleField(Field fieldKey, BibEntry entry) { if (!entry.hasField(fieldKey)) { // Not set -> nothing to do return new ArrayList<>(); } String oldValue = entry.getField(fieldKey).orElse(null);  // Run formatter String newValue = formatter.format(oldValue);  if (oldValue.equals(newValue)) { return new ArrayList<>(); } else { if (newValue.isEmpty()) { entry.clearField(fieldKey); newValue = null; } else { entry.setField(fieldKey, newValue, EntryEventSource.SAVE_ACTION); } FieldChange change = new FieldChange(entry, fieldKey, oldValue, newValue); return Collections.singletonList(change); } }"

"private final ObservableList<T> children;"
"private T parent;"
"public int getPositionInParent() { return getParent().orElseThrow(() -> new UnsupportedOperationException("Roots have no position in parent")) .getIndexOfChild((T) this).get(); }"
"public int getLevel() { if (parent == null) { return 0; } return parent.getLevel() + 1; }"
"public List<T> getPathFromRoot() { if (parent == null) { List<T> pathToMe = new ArrayList<>(); pathToMe.add((T) this); return pathToMe; }  List<T> path = parent.getPathFromRoot(); path.add((T) this); return path; }"
"public Optional<T> getPreviousSibling() { return getRelativeSibling(-1); }"
"protected boolean childIndexExists(int index) { return (index >= 0) && (index < children.size()); }"

"public void removeFromParent() { if (parent != null) { parent.removeChild((T) this); } }"

"public void sortChildren(Comparator<? super T> comparator, boolean recursive) { Objects.requireNonNull(comparator);  if (this.isLeaf()) { return; // nothing to sort }  int j = getNumberOfChildren() - 1; int lastModified; while (j > 0) { lastModified = j + 1; j = -1; for (int i = 1; i < lastModified; ++i) { T child1 = getChildAt(i - 1).get(); T child2 = getChildAt(i).get(); if (comparator.compare(child1, child2) > 0) { child1.moveTo((T) this, i); j = i; } } } if (recursive) { for (T child : getChildren()) { child.sortChildren(comparator, true); } } }"
"public void moveTo(T target, int targetIndex) { Objects.requireNonNull(target);  // Check that the target node is not an ancestor of this node, because this would create loops in the tree if (this.isAncestorOf(target)) { throw new UnsupportedOperationException("the target cannot be a descendant of this node"); }  // Remove from previous parent Optional<T> oldParent = getParent(); if (oldParent.isPresent()) { oldParent.get().removeChild((T) this); }  // Add as child target.addChild((T) this, targetIndex); }"
"public T copySubtree() { T copy = copyNode(); for (T child : getChildren()) { child.copySubtree().moveTo(copy); } return copy; }"

"public static void runMigrations() {  Preferences mainPrefsNode = Preferences.userNodeForPackage(JabRefMain.class);  upgradePrefsToOrgJabRef(mainPrefsNode); upgradeSortOrder(Globals.prefs); upgradeFaultyEncodingStrings(Globals.prefs); upgradeLabelPatternToBibtexKeyPattern(Globals.prefs); upgradeImportFileAndDirePatterns(Globals.prefs, mainPrefsNode); upgradeStoredBibEntryTypes(Globals.prefs, mainPrefsNode); upgradeKeyBindingsToJavaFX(Globals.prefs); addCrossRefRelatedFieldsForAutoComplete(Globals.prefs); upgradePreviewStyleFromReviewToComment(Globals.prefs); }"
"private static void upgradeFaultyEncodingStrings(JabRefPreferences prefs) { String defaultEncoding = prefs.get(JabRefPreferences.DEFAULT_ENCODING); if (defaultEncoding == null) { return; }  Map<String, String> encodingMap = new HashMap<>(); encodingMap.put("UTF8", "UTF-8"); encodingMap.put("Cp1250", "CP1250"); encodingMap.put("Cp1251", "CP1251"); encodingMap.put("Cp1252", "CP1252"); encodingMap.put("Cp1253", "CP1253"); encodingMap.put("Cp1254", "CP1254"); encodingMap.put("Cp1257", "CP1257"); encodingMap.put("ISO8859_1", "ISO8859-1"); encodingMap.put("ISO8859_2", "ISO8859-2"); encodingMap.put("ISO8859_3", "ISO8859-3"); encodingMap.put("ISO8859_4", "ISO8859-4"); encodingMap.put("ISO8859_5", "ISO8859-5"); encodingMap.put("ISO8859_6", "ISO8859-6"); encodingMap.put("ISO8859_7", "ISO8859-7"); encodingMap.put("ISO8859_8", "ISO8859-8"); encodingMap.put("ISO8859_9", "ISO8859-9"); encodingMap.put("ISO8859_13", "ISO8859-13"); encodingMap.put("ISO8859_15", "ISO8859-15"); encodingMap.put("KOI8_R", "KOI8-R"); encodingMap.put("Big5_HKSCS", "Big5-HKSCS"); encodingMap.put("EUC_JP", "EUC-JP");  if (encodingMap.containsKey(defaultEncoding)) { prefs.put(JabRefPreferences.DEFAULT_ENCODING, encodingMap.get(defaultEncoding)); } }"
"private static void upgradeSortOrder(JabRefPreferences prefs) {  if (prefs.get(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, null) == null) { if (prefs.getBoolean("exportInStandardOrder", false)) { prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true); prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, StandardField.AUTHOR.getName()); prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, StandardField.EDITOR.getName()); prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, StandardField.YEAR.getName()); prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, false); prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, false); prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, false); } else if (prefs.getBoolean("exportInTitleOrder", false)) { // exportInTitleOrder => title, author, editor prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true); prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, StandardField.TITLE.getName()); prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, StandardField.AUTHOR.getName()); prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, StandardField.EDITOR.getName()); prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, false); prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, false); prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, false); } } }"




"public abstract String getKey();"
"public abstract String format(String value);"
"public class ACS implements FulltextFetcher { private static final Logger LOGGER = LoggerFactory.getLogger(ACS.class);  private static final String SOURCE = "https://pubs.acs.org/doi/abs/%s";  /** * Tries to find a fulltext URL for a given BibTex entry. * * Currently only uses the DOI if found. * * @param entry The Bibtex entry * @return The fulltext PDF URL Optional, if found, or an empty Optional if not found. * @throws NullPointerException if no BibTex entry is given * @throws java.io.IOException */ @Override public Optional<URL> findFullText(BibEntry entry) throws IOException { Objects.requireNonNull(entry); Optional<URL> pdfLink = Optional.empty();  // DOI search Optional<DOI> doi = entry.getField(StandardField.DOI).flatMap(DOI::parse);  if (doi.isPresent()) { String source = String.format(SOURCE, doi.get().getDOI()); // Retrieve PDF link Document html = Jsoup.connect(source).ignoreHttpErrors(true).get(); Element link = html.select(".pdf-high-res a").first();  if (link != null) { LOGGER.info("Fulltext PDF found @ ACS."); pdfLink = Optional.of(new URL(source.replaceFirst("/abs/", "/pdf/"))); } } return pdfLink; }  @Override public TrustLevel getTrustLevel() { return TrustLevel.PUBLISHER; } }"
"public int hashCode() { return getKey().hashCode(); }"




"public class BiblioscapeImporter extends Importer {  @Override public String getName() { return "Biblioscape"; }  @Override public StandardFileType getFileType() { return StandardFileType.TXT; }  @Override public String getDescription() { return "Imports a Biblioscape Tag File.\n" + "Several Biblioscape field types are ignored. Others are only included in the BibTeX field \"comment\"."; }  @Override public boolean isRecognizedFormat(BufferedReader reader) { Objects.requireNonNull(reader); return true; }  @Override public ParserResult importDatabase(BufferedReader reader) throws IOException { List<BibEntry> bibItems = new ArrayList<>(); String line; Map<Field, String> hm = new HashMap<>(); Map<String, StringBuilder> lines = new HashMap<>(); StringBuilder previousLine = null; while ((line = reader.readLine()) != null) { if (line.isEmpty()) { continue; // ignore empty lines, e.g. at file } // end // entry delimiter -> item complete if ("------".equals(line)) { String[] type = new String[2]; String[] pages = new String[2]; String country = null; String address = null; String titleST = null; String titleTI = null; List<String> comments = new ArrayList<>(); // add item for (Map.Entry<String, StringBuilder> entry : lines.entrySet()) { if ("AU".equals(entry.getKey())) { hm.put(StandardField.AUTHOR, entry.getValue() .toString()); } else if ("TI".equals(entry.getKey())) { titleTI = entry.getValue() .toString(); } else if ("ST".equals(entry.getKey())) { titleST = entry.getValue() .toString(); } else if ("YP".equals(entry.getKey())) { hm.put(StandardField.YEAR, entry .getValue().toString()); } else if ("VL".equals(entry.getKey())) { hm.put(StandardField.VOLUME, entry .getValue().toString()); } else if ("NB".equals(entry.getKey())) { hm.put(StandardField.NUMBER, entry .getValue().toString()); } else if ("PS".equals(entry.getKey())) { pages[0] = entry.getValue() .toString(); } else if ("PE".equals(entry.getKey())) { pages[1] = entry.getValue() .toString(); } else if ("KW".equals(entry.getKey())) { hm.put(StandardField.KEYWORDS, entry .getValue().toString()); } else if ("RT".equals(entry.getKey())) { type[0] = entry.getValue() .toString(); } else if ("SB".equals(entry.getKey())) { comments.add("Subject: " + entry.getValue()); } else if ("SA".equals(entry.getKey())) { comments .add("Secondary Authors: " + entry.getValue()); } else if ("NT".equals(entry.getKey())) { hm.put(StandardField.NOTE, entry .getValue().toString()); } else if ("PB".equals(entry.getKey())) { hm.put(StandardField.PUBLISHER, entry .getValue().toString()); } else if ("TA".equals(entry.getKey())) { comments .add("Tertiary Authors: " + entry.getValue()); } else if ("TT".equals(entry.getKey())) { comments .add("Tertiary Title: " + entry.getValue()); } else if ("ED".equals(entry.getKey())) { hm.put(StandardField.EDITION, entry .getValue().toString()); } else if ("TW".equals(entry.getKey())) { type[1] = entry.getValue() .toString(); } else if ("QA".equals(entry.getKey())) { comments .add("Quaternary Authors: " + entry.getValue()); } else if ("QT".equals(entry.getKey())) { comments .add("Quaternary Title: " + entry.getValue()); } else if ("IS".equals(entry.getKey())) { hm.put(StandardField.ISBN, entry .getValue().toString()); } else if ("AB".equals(entry.getKey())) { hm.put(StandardField.ABSTRACT, entry .getValue().toString()); } else if ("AD".equals(entry.getKey())) { address = entry.getValue() .toString(); } else if ("LG".equals(entry.getKey())) { hm.put(StandardField.LANGUAGE, entry .getValue().toString()); } else if ("CO".equals(entry.getKey())) { country = entry.getValue() .toString(); } else if ("UR".equals(entry.getKey()) || "AT".equals(entry.getKey())) { String s = entry.getValue().toString().trim(); hm.put(s.startsWith("http://") || s.startsWith("ftp://") ? StandardField.URL : StandardField.PDF, entry.getValue().toString()); } else if ("C1".equals(entry.getKey())) { comments.add("Custom1: " + entry.getValue()); } else if ("C2".equals(entry.getKey())) { comments.add("Custom2: " + entry.getValue()); } else if ("C3".equals(entry.getKey())) { comments.add("Custom3: " + entry.getValue()); } else if ("C4".equals(entry.getKey())) { comments.add("Custom4: " + entry.getValue()); } else if ("C5".equals(entry.getKey())) { comments.add("Custom5: " + entry.getValue()); } else if ("C6".equals(entry.getKey())) { comments.add("Custom6: " + entry.getValue()); } else if ("DE".equals(entry.getKey())) { hm.put(StandardField.ANNOTE, entry .getValue().toString()); } else if ("CA".equals(entry.getKey())) { comments.add("Categories: " + entry.getValue()); } else if ("TH".equals(entry.getKey())) { comments.add("Short Title: " + entry.getValue()); } else if ("SE".equals(entry.getKey())) { hm.put(StandardField.CHAPTER, entry .getValue().toString()); //else if (entry.getKey().equals("AC")) // hm.put("",entry.getValue().toString()); //else if (entry.getKey().equals("LP")) // hm.put("",entry.getValue().toString()); } }  EntryType bibtexType = BibEntry.DEFAULT_TYPE; // to find type, first check TW, then RT for (int i = 1; (i >= 0) && BibEntry.DEFAULT_TYPE.equals(bibtexType); --i) { if (type[i] == null) { continue; } type[i] = type[i].toLowerCase(Locale.ROOT); if (type[i].contains("article")) { bibtexType = StandardEntryType.Article; } else if (type[i].contains("journal")) { bibtexType = StandardEntryType.Article; } else if (type[i].contains("book section")) { bibtexType = StandardEntryType.InBook; } else if (type[i].contains("book")) { bibtexType = StandardEntryType.Book; } else if (type[i].contains("conference")) { bibtexType = StandardEntryType.InProceedings; } else if (type[i].contains("proceedings")) { bibtexType = StandardEntryType.InProceedings; } else if (type[i].contains("report")) { bibtexType = StandardEntryType.TechReport; } else if (type[i].contains("thesis") && type[i].contains("master")) { bibtexType = StandardEntryType.MastersThesis; } else if (type[i].contains("thesis")) { bibtexType = StandardEntryType.PhdThesis; } }  // depending on bibtexType, decide where to place the titleRT and // titleTI if (bibtexType.equals(StandardEntryType.Article)) { if (titleST != null) { hm.put(StandardField.JOURNAL, titleST); } if (titleTI != null) { hm.put(StandardField.TITLE, titleTI); } } else if (bibtexType.equals(StandardEntryType.InBook)) { if (titleST != null) { hm.put(StandardField.BOOKTITLE, titleST); } if (titleTI != null) { hm.put(StandardField.TITLE, titleTI); } } else { if (titleST != null) { hm.put(StandardField.BOOKTITLE, titleST); } if (titleTI != null) { hm.put(StandardField.TITLE, titleTI); } }  // concatenate pages if ((pages[0] != null) || (pages[1] != null)) { hm.put(StandardField.PAGES, (pages[0] == null ? "" : pages[0]) + (pages[1] == null ? "" : "--" + pages[1])); }  // concatenate address and country if (address != null) { hm.put(StandardField.ADDRESS, address + (country == null ? "" : ", " + country)); }  if (!comments.isEmpty()) { // set comment if present hm.put(StandardField.COMMENT, String.join(";", comments)); } BibEntry b = new BibEntry(bibtexType); b.setField(hm); bibItems.add(b);  hm.clear(); lines.clear(); previousLine = null;  continue; } // new key if (line.startsWith("--") && (line.length() >= 7) && "-- ".equals(line.substring(4, 7))) { previousLine = new StringBuilder(line.substring(7)); lines.put(line.substring(2, 4), previousLine); continue; } // continuation (folding) of previous line if (previousLine == null) { return new ParserResult(); } previousLine.append(line.trim()); }  return new ParserResult(bibItems); }  }"







"public static Optional<BibEntry> getEntry(String entryUrl, ImportFormatPreferences importFormatPreferences) { try { // Replace special characters by corresponding sequences: String cleanURL = entryUrl.replace("%", "%25").replace(":", "%3A").replace("/", "%2F").replace("?", "%3F") .replace("&", "%26").replace("=", "%3D");  URL url = new URL(BibsonomyScraper.BIBSONOMY_SCRAPER + cleanURL + BibsonomyScraper.BIBSONOMY_SCRAPER_POST); String bibtex = new URLDownload(url).asString(); return BibtexParser.singleFromString(bibtex, importFormatPreferences, new DummyFileUpdateMonitor()); } catch (IOException ex) { LOGGER.warn("Could not download entry", ex); return Optional.empty(); } catch (ParseException ex) { LOGGER.warn("Could not parse entry", ex); return Optional.empty(); } catch (RuntimeException ex) { LOGGER.warn("Could not get entry", ex); return Optional.empty(); } }"






"private int convertSpecialChar(StringBuilder sb, char[] c, int start, FORMAT_MODE format) { int i = start;  sb.append(c[i]); i++; // skip over open brace  while ((i < c.length) && (braceLevel > 0)) { sb.append(c[i]); i++; // skip over the |backslash|  Optional<String> s = BibtexCaseChanger.findSpecialChar(c, i); if (s.isPresent()) { i = convertAccented(c, i, s.get(), sb, format); }  while ((i < c.length) && (braceLevel > 0) && (c[i] != '\\')) { if (c[i] == '}') { braceLevel--; } else if (c[i] == '{') { braceLevel++; } i = convertNonControl(c, i, sb, format); } } return i; }"

"public static Optional<String> findSpecialChar(char[] c, int pos) { if ((pos + 1) < c.length) { if ((c[pos] == 'o') && (c[pos + 1] == 'e')) { return Optional.of("oe"); } if ((c[pos] == 'O') && (c[pos + 1] == 'E')) { return Optional.of("OE"); } if ((c[pos] == 'a') && (c[pos + 1] == 'e')) { return Optional.of("ae"); } if ((c[pos] == 'A') && (c[pos + 1] == 'E')) { return Optional.of("AE"); } if ((c[pos] == 's') && (c[pos + 1] == 's')) { return Optional.of("ss"); } if ((c[pos] == 'A') && (c[pos + 1] == 'A')) { return Optional.of("AA"); } if ((c[pos] == 'a') && (c[pos + 1] == 'a')) { return Optional.of("aa"); } } if ("ijoOlL".indexOf(c[pos]) >= 0) { return Optional.of(String.valueOf(c[pos])); } return Optional.empty(); }"




"public String format(String input) { Title title = new Title(input);  title.getWords().stream().forEach(Word::toUpperFirst);  return title.toString(); }"
"public class ChangeCaseFunction implements BstFunction {  private final VM vm;   public ChangeCaseFunction(VM vm) { this.vm = vm; }  @Override public void execute(BstEntry context) { Stack<Object> stack = vm.getStack();  if (stack.size() < 2) { throw new VMException("Not enough operands on stack for operation change.case$"); }  Object o1 = stack.pop(); if (!((o1 instanceof String) && (((String) o1).length() == 1))) { throw new VMException("A format string of length 1 is needed for change.case$"); }  Object o2 = stack.pop(); if (!(o2 instanceof String)) { throw new VMException("A string is needed as second parameter for change.case$"); }  char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0); String s = (String) o2;  stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format))); }  }"

"public static List<BibEntry> getSortedEntries(BibDatabaseContext bibDatabaseContext, List<BibEntry> entriesToSort, SavePreferences preferences) { Objects.requireNonNull(bibDatabaseContext); Objects.requireNonNull(entriesToSort);  //if no meta data are present, simply return in original order if (bibDatabaseContext.getMetaData() == null) { return new LinkedList<>(entriesToSort); }  List<Comparator<BibEntry>> comparators = getSaveComparators(bibDatabaseContext.getMetaData(), preferences); FieldComparatorStack<BibEntry> comparatorStack = new FieldComparatorStack<>(comparators);  List<BibEntry> sorted = new ArrayList<>(entriesToSort); sorted.sort(comparatorStack); return sorted; }"

"private static final Logger LOGGER = LoggerFactory.getLogger(DoiResolution.class);  @Override public Optional<URL> findFullText(BibEntry entry) throws IOException { Objects.requireNonNull(entry); Optional<URL> pdfLink = Optional.empty();  Optional<DOI> doi = entry.getField(StandardField.DOI).flatMap(DOI::parse);  if (doi.isPresent()) { String sciLink = doi.get().getURIAsASCIIString();  // follow all redirects and scan for a single pdf link if (!sciLink.isEmpty()) { try { Connection connection = Jsoup.connect(sciLink); // pretend to be a browser (agent & referrer) connection.userAgent(URLDownload.USER_AGENT); connection.referrer("http://www.google.com"); connection.followRedirects(true); connection.ignoreHttpErrors(true); // some publishers are quite slow (default is 3s) connection.timeout(10000);  Document html = connection.get();  // scan for PDF Elements elements = html.body().select("a[href]"); List<Optional<URL>> links = new ArrayList<>();  for (Element element : elements) { String href = element.attr("abs:href").toLowerCase(Locale.ENGLISH); String hrefText = element.text().toLowerCase(Locale.ENGLISH); // Only check if pdf is included in the link or inside the text // ACM uses tokens without PDF inside the link // See https://github.com/lehner/LocalCopy for more scrape ideas if ((href.contains("pdf") || hrefText.contains("pdf")) && new URLDownload(href).isPdf()) { links.add(Optional.of(new URL(href))); } } // return if only one link was found (high accuracy) if (links.size() == 1) { LOGGER.info("Fulltext PDF found @ " + sciLink); pdfLink = links.get(0); } } catch (UnsupportedMimeTypeException type) { // this might be the PDF already as we follow redirects if (type.getMimeType().startsWith("application/pdf")) { return Optional.of(new URL(type.getUrl())); } LOGGER.warn("DoiResolution fetcher failed: ", type); } catch (IOException e) { LOGGER.warn("DoiResolution fetcher failed: ", e); } } } return pdfLink; }  @Override public TrustLevel getTrustLevel() { return TrustLevel.SOURCE; } }"




"public List<String> getValue(EntryType entryType) { List<String> result = data.get(entryType); //  Test to see if we found anything if (result == null) { // check default value result = getDefaultValue(); if (result == null || result.isEmpty()) { // we are the "last" to ask // we don't have anything left return getLastLevelBibtexKeyPattern(entryType); } } return result;  }"




"public static final String[] getDefaultOptions() { return new String[] {"--nologo", "--nodefault", "--norestore", "--nolockcheck"}; }"

"private XTextRange getBookmarkRange(String name) throws NoSuchElementException, WrappedTargetException { XNameAccess xNamedBookmarks = getBookmarks();  // retrieve bookmark by name if (!xNamedBookmarks.hasByName(name)) { return null; } Object foundBookmark = xNamedBookmarks.getByName(name); XTextContent xFoundBookmark = UnoRuntime.queryInterface(XTextContent.class, foundBookmark); return xFoundBookmark.getAnchor(); }"


"public class SidePaneManager {  private final SidePane sidePane; private final Map<SidePaneType, SidePaneComponent> components = new LinkedHashMap<>(); private final List<SidePaneComponent> visibleComponents = new LinkedList<>(); private final JabRefPreferences preferences;  public SidePaneManager(JabRefPreferences preferences, JabRefFrame frame) { this.preferences = preferences; this.sidePane = new SidePane();  OpenOfficePreferences openOfficePreferences = preferences.getOpenOfficePreferences(); Stream.of( new GroupSidePane(this, preferences, frame.getDialogService()), new WebSearchPane(this, preferences, frame), new OpenOfficeSidePanel(this, preferences, frame)) .forEach(pane -> components.put(pane.getType(), pane));  if (preferences.getBoolean(JabRefPreferences.GROUP_SIDEPANE_VISIBLE)) { show(SidePaneType.GROUPS); }  if (openOfficePreferences.getShowPanel()) { show(SidePaneType.OPEN_OFFICE); }  if (preferences.getBoolean(JabRefPreferences.WEB_SEARCH_VISIBLE)) { show(SidePaneType.WEB_SEARCH); }  updateView(); }  public SidePane getPane() { return sidePane; }  public boolean isComponentVisible(SidePaneType type) { return visibleComponents.contains(getComponent(type)); }  public SidePaneComponent getComponent(SidePaneType type) { SidePaneComponent component = components.get(type); if (component == null) { throw new IllegalStateException("Side component " + type + " not registered."); } else { return component; } }  /** * If the given component is visible it will be hidden and the other way around. */ public void toggle(SidePaneType type) { if (isComponentVisible(type)) { hide(type); } else { show(type); } }  /** * Makes sure that the given component is visible. */ public void show(SidePaneType type) { SidePaneComponent component = getComponent(type); if (!visibleComponents.contains(component)) { // Add the new component visibleComponents.add(component);  // Sort the visible components by their preferred position visibleComponents.sort(new PreferredIndexSort());  updateView();  component.afterOpening(); } }  /** * Makes sure that the given component is not visible. */ public void hide(SidePaneType type) { SidePaneComponent component = getComponent(type); if (visibleComponents.contains(component)) { component.beforeClosing();  visibleComponents.remove(component);  updateView(); } }  /** * Stores the current configuration of visible components in the preferences, * so that we show components at the preferred position next time. */ private void updatePreferredPositions() { Map<SidePaneType, Integer> preferredPositions = preferences.getSidePanePreferredPositions();  // Use the currently shown positions of all visible components int index = 0; for (SidePaneComponent comp : visibleComponents) { preferredPositions.put(comp.getType(), index); index++; } preferences.storeSidePanePreferredPositions(preferredPositions); }  /** * Moves the given component up. */ public void moveUp(SidePaneComponent component) { if (visibleComponents.contains(component)) { int currentPosition = visibleComponents.indexOf(component); if (currentPosition > 0) { int newPosition = currentPosition - 1; visibleComponents.remove(currentPosition); visibleComponents.add(newPosition, component);  updatePreferredPositions(); updateView(); } } }  /** * Moves the given component down. */ public void moveDown(SidePaneComponent comp) { if (visibleComponents.contains(comp)) { int currentPosition = visibleComponents.indexOf(comp); if (currentPosition < (visibleComponents.size() - 1)) { int newPosition = currentPosition + 1; visibleComponents.remove(currentPosition); visibleComponents.add(newPosition, comp);  updatePreferredPositions(); updateView(); } } }  /** * Updates the view to reflect changes to visible components. */ private void updateView() { sidePane.setComponents(visibleComponents);  if (visibleComponents.isEmpty()) { sidePane.setVisible(false); } else { sidePane.setVisible(true); } }  /** * Helper class for sorting visible components based on their preferred position. */ private class PreferredIndexSort implements Comparator<SidePaneComponent> {  private final Map<SidePaneType, Integer> preferredPositions;  public PreferredIndexSort() { preferredPositions = Globals.prefs.getSidePanePreferredPositions(); }  @Override public int compare(SidePaneComponent comp1, SidePaneComponent comp2) { int pos1 = preferredPositions.getOrDefault(comp1.getType(), 0); int pos2 = preferredPositions.getOrDefault(comp2.getType(), 0); return Integer.compare(pos1, pos2); } } }"









"class ConnectionLostException extends RuntimeException {  public ConnectionLostException(String s) { super(s); } }"
"public class PreferencesDialogView extends BaseDialog<PreferencesDialogViewModel> {  @FXML private CustomTextField searchBox; @FXML private ListView<PreferencesTab> preferenceTabList; @FXML private ScrollPane preferencePaneContainer; @FXML private ButtonType saveButton;  @Inject private DialogService dialogService; @Inject private TaskExecutor taskExecutor;  private JabRefFrame frame; private PreferencesDialogViewModel viewModel;  public PreferencesDialogView(JabRefFrame frame) { this.frame = frame; this.setTitle(Localization.lang("JabRef preferences"));  ViewLoader.view(this) .load() .setAsDialogPane(this);  ControlHelper.setAction(saveButton, getDialogPane(), event -> savePreferencesAndCloseDialog());  // ToDo: After conversion of all tabs to mvvm, rework interface and make validSettings bindable // Button btnSave = (Button) this.getDialogPane().lookupButton(saveButton); // btnSave.disableProperty().bind(viewModel.validSettings().validProperty().not()); }  public PreferencesDialogViewModel getViewModel() { return viewModel; }  @FXML private void initialize() { viewModel = new PreferencesDialogViewModel(dialogService, frame);  preferenceTabList.itemsProperty().setValue(viewModel.getPreferenceTabs());  PreferencesSearchHandler searchHandler = new PreferencesSearchHandler(viewModel.getPreferenceTabs()); preferenceTabList.itemsProperty().bindBidirectional(searchHandler.filteredPreferenceTabsProperty()); searchBox.textProperty().addListener((observable, previousText, newText) -> { searchHandler.filterTabs(newText.toLowerCase(Locale.ROOT)); preferenceTabList.getSelectionModel().clearSelection(); preferenceTabList.getSelectionModel().selectFirst(); }); searchBox.setPromptText(Localization.lang("Search") + "..."); searchBox.setLeft(IconTheme.JabRefIcons.SEARCH.getGraphicNode());  EasyBind.subscribe(preferenceTabList.getSelectionModel().selectedItemProperty(), tab -> { if (tab == null) { preferencePaneContainer.setContent(null); } else { preferencePaneContainer.setContent(tab.getBuilder()); } });  preferenceTabList.getSelectionModel().selectFirst(); new ViewModelListCellFactory<PreferencesTab>() .withText(PreferencesTab::getTabName) .install(preferenceTabList);  viewModel.setValues(); }  @FXML private void closeDialog() { close(); }  @FXML private void savePreferencesAndCloseDialog() { if (viewModel.validSettings()) { viewModel.storeAllSettings(); closeDialog(); } }  @FXML void exportPreferences() { viewModel.exportPreferences(); }  @FXML void importPreferences() { viewModel.importPreferences(); }  @FXML void showAllPreferences() { viewModel.showPreferences(); }  @FXML void resetPreferences() { viewModel.resetPreferences(); } }"
"private void jumpToSearchKey(ListView<PreviewLayout> list, KeyEvent keypressed) { if (keypressed.getCharacter() == null) { return; }  if (System.currentTimeMillis() - lastKeyPressTime < 1000) { listSearchTerm += keypressed.getCharacter().toLowerCase(); } else { listSearchTerm = keypressed.getCharacter().toLowerCase(); }  lastKeyPressTime = System.currentTimeMillis();  list.getItems().stream().filter(item -> item.getName().toLowerCase().startsWith(listSearchTerm)) .findFirst().ifPresent(list::scrollTo); }"
"private class PreferredIndexSort implements Comparator<SidePaneComponent> {  private final Map<SidePaneType, Integer> preferredPositions;  public PreferredIndexSort() { preferredPositions = Globals.prefs.getSidePanePreferredPositions(); }  @Override public int compare(SidePaneComponent comp1, SidePaneComponent comp2) { int pos1 = preferredPositions.getOrDefault(comp1.getType(), 0); int pos2 = preferredPositions.getOrDefault(comp2.getType(), 0); return Integer.compare(pos1, pos2); } }"
"void setValues();"


"boolean validateSettings();"


"public class StateManager {  private final OptionalObjectProperty<BibDatabaseContext> activeDatabase = OptionalObjectProperty.empty(); private final ReadOnlyListWrapper<GroupTreeNode> activeGroups = new ReadOnlyListWrapper<>(FXCollections.observableArrayList()); private final ObservableList<BibEntry> selectedEntries = FXCollections.observableArrayList(); private final ObservableMap<BibDatabaseContext, ObservableList<GroupTreeNode>> selectedGroups = FXCollections.observableHashMap(); private final OptionalObjectProperty<SearchQuery> activeSearchQuery = OptionalObjectProperty.empty(); private final ObservableMap<BibDatabaseContext, IntegerProperty> searchResultMap = FXCollections.observableHashMap();  public StateManager() { activeGroups.bind(Bindings.valueAt(selectedGroups, activeDatabase.orElse(null))); }  public OptionalObjectProperty<BibDatabaseContext> activeDatabaseProperty() { return activeDatabase; }  public OptionalObjectProperty<SearchQuery> activeSearchQueryProperty() { return activeSearchQuery; }  public void setActiveSearchResultSize(BibDatabaseContext database, IntegerProperty resultSize) { searchResultMap.put(database, resultSize); }  public IntegerProperty getSearchResultSize() { return searchResultMap.get(activeDatabase.getValue().orElse(new BibDatabaseContext())); }  public ReadOnlyListProperty<GroupTreeNode> activeGroupProperty() { return activeGroups.getReadOnlyProperty(); }  public ObservableList<BibEntry> getSelectedEntries() { return selectedEntries; }  public void setSelectedEntries(List<BibEntry> newSelectedEntries) { selectedEntries.setAll(newSelectedEntries); }  public void setSelectedGroups(BibDatabaseContext database, List<GroupTreeNode> newSelectedGroups) { Objects.requireNonNull(newSelectedGroups); selectedGroups.put(database, FXCollections.observableArrayList(newSelectedGroups)); }  public ObservableList<GroupTreeNode> getSelectedGroup(BibDatabaseContext database) { ObservableList<GroupTreeNode> selectedGroupsForDatabase = selectedGroups.get(database); return selectedGroupsForDatabase != null ? selectedGroupsForDatabase : FXCollections.observableArrayList(); }  public void clearSelectedGroups(BibDatabaseContext database) { selectedGroups.remove(database); }  public Optional<BibDatabaseContext> getActiveDatabase() { return activeDatabase.get(); }  public List<BibEntry> getEntriesInCurrentDatabase() { return OptionalUtil.flatMap(activeDatabase.get(), BibDatabaseContext::getEntries) .collect(Collectors.toList()); }  public void clearSearchQuery() { activeSearchQuery.setValue(Optional.empty()); }  public void setSearchQuery(SearchQuery searchQuery) { activeSearchQuery.setValue(Optional.of(searchQuery)); } }"


"boolean requiresBibtexKeys();"




"private final boolean separationBySpace;"

"public class OnlyIntegerFormatter extends TextFormatter<Integer> {  public OnlyIntegerFormatter() { this(0); }  public OnlyIntegerFormatter(Integer defaultValue) { super(new IntegerStringConverter(), defaultValue, new IntegerFilter()); }  private static class IntegerFilter implements UnaryOperator<Change> { private final static Pattern DIGIT_PATTERN = Pattern.compile("\\d*");  @Override public Change apply(TextFormatter.Change aT) { return DIGIT_PATTERN.matcher(aT.getText()).matches() ? aT : null; } } }"


"public class TooltipTextUtil {  public enum TextType { NORMAL, BOLD, ITALIC, MONOSPACED }  public static Text createText(String textString, TextType textType) { Text text = new Text(textString); switch (textType) { case BOLD: text.getStyleClass().setAll("tooltip-text-bold"); break; case ITALIC: text.getStyleClass().setAll("tooltip-text-italic"); break; case MONOSPACED: text.getStyleClass().setAll("tooltip-text-monospaced"); break; default: break; } return text; }  public static Text createText(String textString) { return createText(textString, TextType.NORMAL); }  public static String textToHTMLString(Text text) { String textString = text.getText(); textString = textString.replace("\n", "<br>"); if (text.getStyleClass().toString().contains("tooltip-text-monospaced")) { textString = String.format("<kbd>%s</kbd>", textString); } if (text.getStyleClass().toString().contains("tooltip-text-bold")) { textString = String.format("<b>%s</b>", textString); } if (text.getStyleClass().toString().contains("tooltip-text-italic")) { textString = String.format("<i>%s</i>", textString); } return textString; }  /** * Formats a String to multiple Texts by replacing some parts and adding font characteristics. */ public static List<Text> formatToTexts(String original, TextReplacement... replacements) { List<Text> textList = new ArrayList<>(); textList.add(new Text(original)); for (TextReplacement replacement : replacements) { splitReplace(textList, replacement); }  return textList; }  private static void splitReplace(List<Text> textList, TextReplacement replacement) { Optional<Text> textContainingReplacement = textList.stream().filter(it -> it.getText().contains(replacement.toReplace)).findFirst(); if (textContainingReplacement.isPresent()) { int index = textList.indexOf(textContainingReplacement.get()); String original = textContainingReplacement.get().getText(); textList.remove(index); String[] textParts = original.split(replacement.toReplace); if (textParts.length == 2) { if (textParts[0].equals("")) { textList.add(index, TooltipTextUtil.createText(replacement.replacement, replacement.textType)); textList.add(index + 1, TooltipTextUtil.createText(textParts[1], TooltipTextUtil.TextType.NORMAL)); } else { textList.add(index, TooltipTextUtil.createText(textParts[0], TooltipTextUtil.TextType.NORMAL)); textList.add(index + 1, TooltipTextUtil.createText(replacement.replacement, replacement.textType)); textList.add(index + 2, TooltipTextUtil.createText(textParts[1], TooltipTextUtil.TextType.NORMAL)); } } else if (textParts.length == 1) { textList.add(index, TooltipTextUtil.createText(textParts[0], TooltipTextUtil.TextType.NORMAL)); textList.add(index + 1, TooltipTextUtil.createText(replacement.replacement, replacement.textType)); } else { throw new IllegalStateException("It is not allowed that the toReplace string: '" + replacement.toReplace + "' exists multiple times in the original string"); } } else { throw new IllegalStateException("It is not allowed that the toReplace string: '" + replacement.toReplace + "' does not exist in the original string"); } }  public static class TextReplacement { private final String toReplace; private final String replacement; private final TooltipTextUtil.TextType textType;  public TextReplacement(String toReplace, String replacement, TooltipTextUtil.TextType textType) { this.toReplace = toReplace; this.replacement = replacement; this.textType = textType; } } }"
"<V> Future<V> execute(Task<V> task);"
"void shutdown();"

"public class AutoCompleteUpdater {  private final SuggestionProviders suggestionProviders;  public AutoCompleteUpdater(SuggestionProviders suggestionProviders) { this.suggestionProviders = suggestionProviders; }  @Subscribe public void listen(EntryAddedEvent addedEntryEvent) { suggestionProviders.indexEntry(addedEntryEvent.getBibEntry()); }  @Subscribe public void listen(EntryChangedEvent entryChangedEvent) { suggestionProviders.indexEntry(entryChangedEvent.getBibEntry()); } }"

"private StringConverter<T> converter;"
"public BackgroundTask<Void> thenRun(Consumer<V> nextOperation) { return new BackgroundTask<Void>() { @Override protected Void call() throws Exception { V result = BackgroundTask.this.call(); BackgroundTask<Void> nextTask = BackgroundTask.wrap(() -> nextOperation.accept(result)); EasyBind.subscribe(nextTask.progressProperty(), this::updateProgress); return nextTask.call(); } }; }"

"public void addPossibleSuggestions(Collection<T> newPossible) { synchronized (possibleSuggestionsLock) { possibleSuggestions.addAll(newPossible); } }"
"private final Map<Field, AutoCompleteSuggestionProvider<?>> providers = new HashMap<>();"
"public class WordSuggestionProvider extends StringSuggestionProvider implements AutoCompleteSuggestionProvider<String> {  private static final String SEPARATING_CHARS = ";,\n ";  private final Field field;  public WordSuggestionProvider(Field field) { this.field = Objects.requireNonNull(field); }  @Override public void indexEntry(BibEntry entry) { if (entry == null) { return; }  entry.getField(field).ifPresent(fieldValue -> { StringTokenizer tok = new StringTokenizer(fieldValue, SEPARATING_CHARS); while (tok.hasMoreTokens()) { addPossibleSuggestions(tok.nextToken()); } }); } }"

"public BasePanel getBasePanelAt(int i) { return (BasePanel) tabbedPane.getTabs().get(i).getContent(); }"
"public class CopyFilesResultListDependency {  private List<CopyFilesResultItemViewModel> results = new ArrayList<>();  public CopyFilesResultListDependency() { //empty, workaround for injection into FXML controller }  public CopyFilesResultListDependency(List<CopyFilesResultItemViewModel> results) { this.results = results; }  public List<CopyFilesResultItemViewModel> getResults() { return results; }  @Override public String toString() { return "CopyFilesResultListDependency [results=" + results + "]"; }  }"


"void openPdfWithParameters(String filePath, List<String> parameters) throws IOException;"








"private StackPane getRelatedArticlesPane(BibEntry entry) { StackPane root = new StackPane(); root.getStyleClass().add("related-articles-tab"); ProgressIndicator progress = new ProgressIndicator(); progress.setMaxSize(100, 100);  MrDLibFetcher fetcher = new MrDLibFetcher(Globals.prefs.get(JabRefPreferences.LANGUAGE), Globals.BUILD_INFO.getVersion()); BackgroundTask .wrap(() -> fetcher.performSearch(entry)) .onRunning(() -> progress.setVisible(true)) .onSuccess(relatedArticles -> { progress.setVisible(false); root.getChildren().add(getRelatedArticleInfo(relatedArticles, fetcher)); }) .onFailure(exception -> { LOGGER.error("Error while fetching from Mr. DLib", exception); progress.setVisible(false); root.getChildren().add(getErrorInfo()); }) .executeWith(Globals.TASK_EXECUTOR);  root.getChildren().add(progress);  return root; }"




"private EntryType currentEntryType;"
"protected void handleFocus() { // Do nothing by default }"

"public void copyCurrentAnnotation() { if (null == getCurrentAnnotation()) { return; } StringJoiner sj = new StringJoiner("," + OS.NEWLINE); sj.add(Localization.lang("Author") + ": " + getCurrentAnnotation().getAuthor()); sj.add(Localization.lang("Date") + ": " + getCurrentAnnotation().getDate()); sj.add(Localization.lang("Page") + ": " + getCurrentAnnotation().getPage()); sj.add(Localization.lang("Content") + ": " + getCurrentAnnotation().getContent()); sj.add(Localization.lang("Marking") + ": " + getCurrentAnnotation().markingProperty().get());  Globals.clipboardManager.setContent(sj.toString()); }"
"public void reportIssue() { try { // System info String systemInfo = String.format("JabRef %s%n%s %s %s %nJava %s", buildInfo.getVersion(), BuildInfo.OS, BuildInfo.OS_VERSION, BuildInfo.OS_ARCH, BuildInfo.JAVA_VERSION); // Steps to reproduce String howToReproduce = "Steps to reproduce:\n\n1. ...\n2. ...\n3. ..."; // Log messages String issueDetails = "<details>\n" + "<summary>" + "Detail information:" + "</summary>\n\n```\n" + getLogMessagesAsString(allMessagesData) + "\n```\n\n</details>"; clipBoardManager.setContent(issueDetails); // Bug report body String issueBody = systemInfo + "\n\n" + howToReproduce + "\n\n" + "Paste your log details here.";  dialogService.notify(Localization.lang("Issue on GitHub successfully reported.")); dialogService.showInformationDialogAndWait(Localization.lang("Issue report successful"), Localization.lang("Your issue was reported in your browser.") + "\n" + Localization.lang("The log and exception information was copied to your clipboard.") + " " + Localization.lang("Please paste this information (with Ctrl+V) in the issue description.") + "\n" + Localization.lang("Please also add all steps to reproduce this issue, if possible."));  URIBuilder uriBuilder = new URIBuilder() .setScheme("https").setHost("github.com") .setPath("/JabRef/jabref/issues/new") .setParameter("body", issueBody); JabRefDesktop.openBrowser(uriBuilder.build().toString()); } catch (IOException | URISyntaxException e) { LOGGER.error("Problem opening url", e); } }"

"public class ExportCommand extends SimpleCommand {  private static final Logger LOGGER = LoggerFactory.getLogger(ExportCommand.class); private final JabRefFrame frame; private final boolean selectedOnly; private final JabRefPreferences preferences; private final DialogService dialogService;  /** * @param selectedOnly true if only the selected entries should be exported, otherwise all entries are exported */ public ExportCommand(JabRefFrame frame, boolean selectedOnly, JabRefPreferences preferences) { this.frame = frame; this.selectedOnly = selectedOnly; this.preferences = preferences; this.dialogService = frame.getDialogService(); }  @Override public void execute() { List<TemplateExporter> customExporters = preferences.getCustomExportFormats(Globals.journalAbbreviationLoader); LayoutFormatterPreferences layoutPreferences = preferences.getLayoutFormatterPreferences(Globals.journalAbbreviationLoader); SavePreferences savePreferences = preferences.loadForExportFromPreferences(); XmpPreferences xmpPreferences = preferences.getXMPPreferences();  //Get list of exporters and sort before adding to file dialog List<Exporter> exporters = Globals.exportFactory.getExporters().stream() .sorted(Comparator.comparing(Exporter::getName)) .collect(Collectors.toList());  Globals.exportFactory = ExporterFactory.create(customExporters, layoutPreferences, savePreferences, xmpPreferences); FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .addExtensionFilter(FileFilterConverter.exporterToExtensionFilter(exporters)) .withDefaultExtension(Globals.prefs.get(JabRefPreferences.LAST_USED_EXPORT)) .withInitialDirectory(Globals.prefs.get(JabRefPreferences.EXPORT_WORKING_DIRECTORY)) .build(); dialogService.showFileSaveDialog(fileDialogConfiguration) .ifPresent(path -> export(path, fileDialogConfiguration.getSelectedExtensionFilter(), exporters)); }  private void export(Path file, FileChooser.ExtensionFilter selectedExtensionFilter, List<Exporter> exporters) { String selectedExtension = selectedExtensionFilter.getExtensions().get(0).replace("*", ""); if (!file.endsWith(selectedExtension)) { FileUtil.addExtension(file, selectedExtension); }  final Exporter format = FileFilterConverter.getExporter(selectedExtensionFilter, exporters) .orElseThrow(() -> new IllegalStateException("User didn't selected a file type for the extension")); List<BibEntry> entries; if (selectedOnly) { // Selected entries entries = frame.getCurrentBasePanel().getSelectedEntries(); } else { // All entries entries = frame.getCurrentBasePanel().getDatabase().getEntries(); }  // Set the global variable for this database's file directory before exporting, // so formatters can resolve linked files correctly. // (This is an ugly hack!) Globals.prefs.fileDirForDatabase = frame.getCurrentBasePanel() .getBibDatabaseContext() .getFileDirectories(Globals.prefs.getFilePreferences());  // Make sure we remember which filter was used, to set // the default for next time: Globals.prefs.put(JabRefPreferences.LAST_USED_EXPORT, format.getName()); Globals.prefs.put(JabRefPreferences.EXPORT_WORKING_DIRECTORY, file.getParent().toString());  final List<BibEntry> finEntries = entries; BackgroundTask .wrap(() -> { format.export(frame.getCurrentBasePanel().getBibDatabaseContext(), file, frame.getCurrentBasePanel() .getBibDatabaseContext() .getMetaData() .getEncoding() .orElse(Globals.prefs.getDefaultEncoding()), finEntries); return null; // can not use BackgroundTask.wrap(Runnable) because Runnable.run() can't throw Exceptions }) .onSuccess(x -> frame.getDialogService().notify(Localization.lang("%0 export successful", format.getName()))) .onFailure(this::handleError) .executeWith(Globals.TASK_EXECUTOR); }  private void handleError(Exception ex) { LOGGER.warn("Problem exporting", ex); frame.getDialogService().notify(Localization.lang("Could not save file.")); // Need to warn the user that saving failed! frame.getDialogService().showErrorDialogAndWait(Localization.lang("Save library"), Localization.lang("Could not save file."), ex); } }"






"public class FindUnlinkedFilesDialog extends BaseDialog<Void> {  private static final Logger LOGGER = LoggerFactory.getLogger(FindUnlinkedFilesDialog.class); private final BibDatabaseContext databaseContext; private final ImportHandler importHandler; private final JabRefPreferences preferences = Globals.prefs; private final DialogService dialogService; private Button buttonScan; private Button buttonExport; private Button buttonApply; private TextField textfieldDirectoryPath; private TreeView<FileNodeWrapper> tree; private ComboBox<FileChooser.ExtensionFilter> comboBoxFileTypeSelection; private VBox panelSearchProgress; private BackgroundTask findUnlinkedFilesTask;  public FindUnlinkedFilesDialog(BibDatabaseContext database, DialogService dialogService, CountingUndoManager undoManager) { super(); this.setTitle(Localization.lang("Find unlinked files")); this.dialogService = dialogService;  databaseContext = database; importHandler = new ImportHandler( dialogService, databaseContext, ExternalFileTypes.getInstance(), Globals.prefs.getFilePreferences(), Globals.prefs.getImportFormatPreferences(), Globals.prefs.getUpdateFieldPreferences(), Globals.getFileUpdateMonitor(), undoManager, Globals.stateManager);  initialize(); }  /** * Initializes the components, the layout, the data structure and the actions in this dialog. */ private void initialize() { Button buttonBrowse = new Button(Localization.lang("Browse")); buttonBrowse.setTooltip(new Tooltip(Localization.lang("Opens the file browser."))); buttonBrowse.getStyleClass().add("text-button"); buttonBrowse.setOnAction(e -> { DirectoryDialogConfiguration directoryDialogConfiguration = new DirectoryDialogConfiguration.Builder() .withInitialDirectory(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).build(); dialogService.showDirectorySelectionDialog(directoryDialogConfiguration) .ifPresent(selectedDirectory -> { textfieldDirectoryPath.setText(selectedDirectory.toAbsolutePath().toString()); preferences.put(JabRefPreferences.WORKING_DIRECTORY, selectedDirectory.toAbsolutePath().toString()); }); });  buttonScan = new Button(Localization.lang("Scan directory")); buttonScan.setTooltip(new Tooltip((Localization.lang("Searches the selected directory for unlinked files.")))); buttonScan.setOnAction(e -> startSearch()); buttonScan.setDefaultButton(true); buttonScan.setPadding(new Insets(5, 0, 0, 0));  buttonExport = new Button(Localization.lang("Export selected entries")); buttonExport.setTooltip(new Tooltip(Localization.lang("Export to text file."))); buttonExport.getStyleClass().add("text-button"); buttonExport.setDisable(true); buttonExport.setOnAction(e -> startExport());  ButtonType buttonTypeImport = new ButtonType(Localization.lang("Import"), ButtonBar.ButtonData.OK_DONE); getDialogPane().getButtonTypes().setAll( buttonTypeImport, ButtonType.CANCEL ); buttonApply = (Button) getDialogPane().lookupButton(buttonTypeImport); buttonApply.setTooltip(new Tooltip((Localization.lang("Starts the import of BibTeX entries.")))); buttonApply.setDisable(true);  /* Actions for the TreeView */ Button buttonOptionSelectAll = new Button(); buttonOptionSelectAll.setText(Localization.lang("Select all")); buttonOptionSelectAll.getStyleClass().add("text-button"); buttonOptionSelectAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); // Need to toggle a twice to make sure everything is selected root.setSelected(true); root.setSelected(false); root.setSelected(true); }); Button buttonOptionDeselectAll = new Button(); buttonOptionDeselectAll.setText(Localization.lang("Unselect all")); buttonOptionDeselectAll.getStyleClass().add("text-button"); buttonOptionDeselectAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); // Need to toggle a twice to make sure nothing is selected root.setSelected(false); root.setSelected(true); root.setSelected(false); }); Button buttonOptionExpandAll = new Button(); buttonOptionExpandAll.setText(Localization.lang("Expand all")); buttonOptionExpandAll.getStyleClass().add("text-button"); buttonOptionExpandAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); expandTree(root, true); }); Button buttonOptionCollapseAll = new Button(); buttonOptionCollapseAll.setText(Localization.lang("Collapse all")); buttonOptionCollapseAll.getStyleClass().add("text-button"); buttonOptionCollapseAll.setOnAction(event -> { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); expandTree(root, false); root.setExpanded(true); });  textfieldDirectoryPath = new TextField(); Path initialPath = databaseContext.getFirstExistingFileDir(preferences.getFilePreferences()) .orElse(preferences.getWorkingDir()); textfieldDirectoryPath.setText(initialPath.toAbsolutePath().toString());  Label labelDirectoryDescription = new Label(Localization.lang("Select a directory where the search shall start.")); Label labelFileTypesDescription = new Label(Localization.lang("Select file type:")); Label labelFilesDescription = new Label(Localization.lang("These files are not linked in the active library.")); Label labelSearchingDirectoryInfo = new Label(Localization.lang("Searching file system..."));  tree = new TreeView<>(); tree.setPrefWidth(Double.POSITIVE_INFINITY);  ScrollPane scrollPaneTree = new ScrollPane(tree); scrollPaneTree.setFitToWidth(true);  ProgressIndicator progressBarSearching = new ProgressIndicator(); progressBarSearching.setMaxSize(50, 50);  setResultConverter(buttonPressed -> { if (buttonPressed == buttonTypeImport) { startImport(); } else { if (findUnlinkedFilesTask != null) { findUnlinkedFilesTask.cancel(); } } return null; });  new ViewModelTreeCellFactory<FileNodeWrapper>() .withText(node -> { if (Files.isRegularFile(node.path)) { // File return node.path.getFileName().toString(); } else { // Directory return node.path.getFileName() + " (" + node.fileCount + " file" + (node.fileCount > 1 ? "s" : "") + ")"; } }) .install(tree); List<FileChooser.ExtensionFilter> fileFilterList = Arrays.asList( FileFilterConverter.ANY_FILE, FileFilterConverter.toExtensionFilter(StandardFileType.PDF), FileFilterConverter.toExtensionFilter(StandardFileType.BIBTEX_DB) );  comboBoxFileTypeSelection = new ComboBox<>(FXCollections.observableArrayList(fileFilterList)); comboBoxFileTypeSelection.getSelectionModel().selectFirst(); new ViewModelListCellFactory<FileChooser.ExtensionFilter>() .withText(fileFilter -> fileFilter.getDescription() + fileFilter.getExtensions().stream().collect(Collectors.joining(", ", " (", ")"))) .withIcon(fileFilter -> ExternalFileTypes.getInstance().getExternalFileTypeByExt(fileFilter.getExtensions().get(0)) .map(ExternalFileType::getIcon) .orElse(null)) .install(comboBoxFileTypeSelection);  panelSearchProgress = new VBox(5, labelSearchingDirectoryInfo, progressBarSearching); panelSearchProgress.toFront(); panelSearchProgress.setVisible(false);  //        panelDirectory.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), //                Localization.lang("Select directory"))); //        panelFiles.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), //                Localization.lang("Select files"))); //        panelEntryTypesSelection.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), //                Localization.lang("BibTeX entry creation")));  VBox panelDirectory = new VBox(5); panelDirectory.getChildren().setAll( labelDirectoryDescription, new HBox(10, textfieldDirectoryPath, buttonBrowse), new HBox(15, labelFileTypesDescription, comboBoxFileTypeSelection), buttonScan ); HBox.setHgrow(textfieldDirectoryPath, Priority.ALWAYS);  StackPane stackPaneTree = new StackPane(scrollPaneTree, panelSearchProgress); StackPane.setAlignment(panelSearchProgress, Pos.CENTER); BorderPane panelFiles = new BorderPane(); panelFiles.setTop(labelFilesDescription); panelFiles.setCenter(stackPaneTree); panelFiles.setBottom(new HBox(5, buttonOptionSelectAll, buttonOptionDeselectAll, buttonOptionExpandAll, buttonOptionCollapseAll, buttonExport));  VBox container = new VBox(20); container.getChildren().addAll( panelDirectory, panelFiles ); container.setPrefWidth(600); getDialogPane().setContent(container); }  /** * Expands or collapses the specified tree according to the <code>expand</code>-parameter. */ private void expandTree(TreeItem<?> item, boolean expand) { if (item != null && !item.isLeaf()) { item.setExpanded(expand); for (TreeItem<?> child : item.getChildren()) { expandTree(child, expand); } } }  /** * Starts the search of unlinked files according chosen directory and the file type selection. The search will * process in a separate thread and a progress indicator will be displayed. */ private void startSearch() { Path directory = getSearchDirectory(); FileFilter selectedFileFilter = FileFilterConverter.toFileFilter(comboBoxFileTypeSelection.getValue());  findUnlinkedFilesTask = new UnlinkedFilesCrawler(directory, selectedFileFilter, databaseContext) .onRunning(() -> { panelSearchProgress.setVisible(true); buttonScan.setDisable(true); tree.setRoot(null); }) .onFinished(() -> { panelSearchProgress.setVisible(false); buttonScan.setDisable(false); }) .onSuccess(root -> { tree.setRoot(root); root.setSelected(true); root.setExpanded(true);  buttonApply.setDisable(false); buttonExport.setDisable(false); buttonScan.setDefaultButton(false); }); findUnlinkedFilesTask.executeWith(Globals.TASK_EXECUTOR); }  private Path getSearchDirectory() { Path directory = Paths.get(textfieldDirectoryPath.getText()); if (Files.notExists(directory)) { directory = Paths.get(System.getProperty("user.dir")); textfieldDirectoryPath.setText(directory.toAbsolutePath().toString()); } if (!Files.isDirectory(directory)) { directory = directory.getParent(); textfieldDirectoryPath.setText(directory.toAbsolutePath().toString()); } return directory; }  /** * This will start the import of all file of all selected nodes in the file tree view. */ private void startImport() { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot(); final List<Path> fileList = getFileListFromNode(root);  if (fileList.isEmpty()) { return; }  importHandler.importAsNewEntries(fileList); }  /** * This starts the export of all files of all selected nodes in the file tree view. */ private void startExport() { CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();  final List<Path> fileList = getFileListFromNode(root); if (fileList.isEmpty()) { return; }  buttonExport.setVisible(false); buttonApply.setVisible(false);  FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .withInitialDirectory(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).build(); Optional<Path> exportPath = dialogService.showFileSaveDialog(fileDialogConfiguration);  if (!exportPath.isPresent()) { buttonExport.setVisible(true); buttonApply.setVisible(true); return; }  try (BufferedWriter writer = Files.newBufferedWriter(exportPath.get(), StandardCharsets.UTF_8, StandardOpenOption.CREATE)) { for (Path file : fileList) { writer.write(file.toString() + "\n"); } } catch (IOException e) { LOGGER.warn("IO Error.", e); }  buttonExport.setVisible(true); buttonApply.setVisible(true); }  /** * Creates a list of all files (leaf nodes in the tree structure), which have been selected. * * @param node The root node representing a tree structure. */ private List<Path> getFileListFromNode(CheckBoxTreeItem<FileNodeWrapper> node) { List<Path> filesList = new ArrayList<>(); for (TreeItem<FileNodeWrapper> childNode : node.getChildren()) { CheckBoxTreeItem<FileNodeWrapper> child = (CheckBoxTreeItem<FileNodeWrapper>) childNode; if (child.isLeaf() && child.isSelected()) { Path nodeFile = child.getValue().path; if ((nodeFile != null) && Files.isRegularFile(nodeFile)) { filesList.add(nodeFile); } } } return filesList; }  public static class FileNodeWrapper {  public final Path path; public final int fileCount;  public FileNodeWrapper(Path path) { this(path, 0); }  public FileNodeWrapper(Path path, int fileCount) { this.path = path; this.fileCount = fileCount; } } }"




"public Optional<ExternalFileType> getExternalFileTypeForName(String filename) { int longestFound = -1; ExternalFileType foundType = null; for (ExternalFileType type : externalFileTypes) { if (!type.getExtension().isEmpty() && filename.toLowerCase(Locale.ROOT).endsWith(type.getExtension().toLowerCase(Locale.ROOT)) && (type.getExtension().length() > longestFound)) { longestFound = type.getExtension().length(); foundType = type; } } return Optional.ofNullable(foundType); }"






"public static ExternalFileType buildFromArgs(String[] val) { if ((val == null) || (val.length < 4) || (val.length > 5)) { throw new IllegalArgumentException("Cannot construct ExternalFileType without four elements in String[] argument."); } String name = val[0]; String extension = val[1]; String openWith; String mimeType; String iconName;  if (val.length == 4) { // Up to version 2.4b the mime type is not included: mimeType = ""; openWith = val[2]; iconName = val[3]; } else { // When mime type is included, the array length should be 5: mimeType = val[2]; openWith = val[3]; iconName = val[4]; }  // set icon to default first JabRefIcon icon = IconTheme.JabRefIcons.FILE;  // check whether there is another icon defined for this file type for (ExternalFileType fileType : ExternalFileTypes.getDefaultExternalFileTypes()) { if (fileType.getName().equals(name)) { icon = fileType.getIcon(); break; } }  return new CustomExternalFileType(name, extension, mimeType, openWith, iconName, icon); }"
"public void storeSettings() { ExternalFileTypes.getInstance().setExternalFileTypes(fileTypes); }"

"void addToContextMenu(final Supplier<List<MenuItem>> items);"




"@SuppressWarnings("unchecked") protected T getValueFromString(String string) { try { return (T) string; } catch (ClassCastException ex) { LOGGER.error(String.format("Could not cast string to type %1$s. Try overriding the method in a subclass and provide a conversion from string to the concrete type %1$s", string.getClass()), ex); } return null; }"
"public static Supplier<List<MenuItem>> getDOIMenu(TextArea textArea) { return () -> { ActionFactory factory = new ActionFactory(Globals.getKeyPrefs()); MenuItem copyDoiUrlMenuItem = factory.createMenuItem(StandardActions.COPY_DOI, new CopyDoiUrlAction(textArea));  List<MenuItem> menuItems = new ArrayList<>(); menuItems.add(copyDoiUrlMenuItem); menuItems.add(new SeparatorMenuItem()); menuItems.addAll(getDefaultMenu(textArea).get()); return menuItems; }; }"
"public class FileListEntry {  private String description;  private String link;  private Optional<ExternalFileType> type;  public FileListEntry(String description, String link) { this(description, link, Optional.empty()); }  public FileListEntry(String description, String link, ExternalFileType type) { this.setDescription(Objects.requireNonNull(description)); this.setLink(Objects.requireNonNull(link)); this.setType(Optional.of(Objects.requireNonNull(type))); }  public FileListEntry(String description, String link, Optional<ExternalFileType> type) { this.setDescription(Objects.requireNonNull(description)); this.setLink(Objects.requireNonNull(link)); this.setType(Objects.requireNonNull(type)); }  public String[] getStringArrayRepresentation() { return new String[] {getDescription(), getLink(), getTypeName()}; }  private String getTypeName() { return this.getType().isPresent() ? this.getType().get().getName() : ""; }  @Override public String toString() { return getDescription() + " : " + getLink() + " : " + getType().orElse(null); }  public LinkedFile toParsedFileField() { return new LinkedFile(getDescription(), getLink(), getType().isPresent() ? getType().get().getName() : ""); }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public String getLink() { return link; }  public void setLink(String link) { this.link = link; }  public Optional<ExternalFileType> getType() { return type; }  public void setType(Optional<ExternalFileType> type) { this.type = type; } }"
"class UndoableMoveGroup extends AbstractUndoableJabRefEdit {  private final GroupTreeNodeViewModel root; private final List<Integer> pathToNewParent; private final int newChildIndex; private final List<Integer> pathToOldParent; private final int oldChildIndex;   public UndoableMoveGroup(GroupTreeNodeViewModel root, MoveGroupChange moveChange) { this.root = Objects.requireNonNull(root); Objects.requireNonNull(moveChange); pathToOldParent = moveChange.getOldParent().getIndexedPathFromRoot(); pathToNewParent = moveChange.getNewParent().getIndexedPathFromRoot(); oldChildIndex = moveChange.getOldChildIndex(); newChildIndex = moveChange.getNewChildIndex(); }  @Override public String getPresentationName() { return Localization.lang("move group"); }  @Override public void undo() { super.undo();  GroupTreeNode newParent = root.getNode().getDescendant(pathToNewParent).get(); //TODO: NULL GroupTreeNode node = newParent.getChildAt(newChildIndex).get(); //TODO: Null //TODO: NULL node.moveTo(root.getNode().getDescendant(pathToOldParent).get(), oldChildIndex); }  @Override public void redo() { super.redo();  GroupTreeNode oldParent = root.getNode().getDescendant(pathToOldParent).get(); //TODO: NULL GroupTreeNode node = oldParent.getChildAt(oldChildIndex).get(); //TODO:Null //TODO: NULL node.moveTo(root.getNode().getDescendant(pathToNewParent).get(), newChildIndex); } }"




"private final List<Integer> m_subtreeRootPath;"
"private final List<GroupTreeNode> m_modifiedSubtree = new ArrayList<>();"

"class GroupDialog extends BaseDialog<AbstractGroup> {  private static final int INDEX_EXPLICIT_GROUP = 0; private static final int INDEX_KEYWORD_GROUP = 1; private static final int INDEX_SEARCH_GROUP = 2; private static final int INDEX_AUTO_GROUP = 3; private static final int INDEX_TEX_GROUP = 4;  // for all types private final TextField nameField = new TextField(); private final TextField descriptionField = new TextField(); private final JFXColorPicker colorField = new JFXColorPicker(); private final TextField iconField = new TextField(); private final RadioButton explicitRadioButton = new RadioButton(Localization.lang("Statically group entries by manual assignment")); private final RadioButton keywordsRadioButton = new RadioButton(Localization.lang("Dynamically group entries by searching a field for a keyword")); private final RadioButton searchRadioButton = new RadioButton(Localization.lang("Dynamically group entries by a free-form search expression")); private final RadioButton autoRadioButton = new RadioButton(Localization.lang("Automatically create groups")); private final RadioButton texRadioButton = new RadioButton(Localization.lang("Group containing entries cited in a given TeX file")); private final RadioButton independentButton = new RadioButton(Localization.lang("Independent group: When selected, view only this group's entries")); private final RadioButton intersectionButton = new RadioButton(Localization.lang("Refine supergroup: When selected, view entries contained in both this group and its supergroup")); private final RadioButton unionButton = new RadioButton(Localization.lang("Include subgroups: When selected, view entries contained in this group or its subgroups")); private final DialogService dialogService; private final JabRefPreferences prefs; private final BasePanel basePanel;  // for KeywordGroup private final TextField keywordGroupSearchTerm = new TextField(); private final TextField keywordGroupSearchField = new TextField(); private final CheckBox keywordGroupCaseSensitive = new CheckBox(Localization.lang("Case sensitive")); private final CheckBox keywordGroupRegExp = new CheckBox(Localization.lang("regular expression"));  // for SearchGroup private final TextField searchGroupSearchExpression = new TextField(); private final CheckBox searchGroupCaseSensitive = new CheckBox(Localization.lang("Case sensitive")); private final CheckBox searchGroupRegExp = new CheckBox(Localization.lang("regular expression"));  // for AutoGroup private final RadioButton autoGroupKeywordsOption = new RadioButton(Localization.lang("Generate groups from keywords in a BibTeX field")); private final TextField autoGroupKeywordsField = new TextField(); private final TextField autoGroupKeywordsDeliminator = new TextField(); private final TextField autoGroupKeywordsHierarchicalDeliminator = new TextField(); private final RadioButton autoGroupPersonsOption = new RadioButton(Localization.lang("Generate groups for author last names")); private final TextField autoGroupPersonsField = new TextField();  // for TexGroup private final TextField texGroupFilePath = new TextField(); private final Button texGroupBrowseButton = new Button("Browse"); private final HBox texGroupHBox = new HBox(10);  // for all types private final TextFlow descriptionTextFlow = new TextFlow(); private final StackPane optionsPanel = new StackPane();   /** * Shows a group add/edit dialog. * * @param editedGroup The group being edited, or null if a new group is to be *                    created. */ public GroupDialog(DialogService dialogService, BasePanel basePanel, JabRefPreferences prefs, AbstractGroup editedGroup) {  if (editedGroup == null) { this.setTitle(Localization.lang("Add subgroup")); } else { this.setTitle(Localization.lang("Edit group")); }  explicitRadioButton.setSelected(true);  descriptionTextFlow.setMinWidth(585); descriptionTextFlow.setPrefWidth(585); descriptionTextFlow.setMinHeight(180); descriptionTextFlow.setPrefHeight(180);  this.dialogService = dialogService; this.prefs = prefs; this.basePanel = basePanel;  // set default values (overwritten if editedGroup != null) keywordGroupSearchField.setText(prefs.get(JabRefPreferences.GROUPS_DEFAULT_FIELD));  // configure elements ToggleGroup groupType = new ToggleGroup(); explicitRadioButton.setToggleGroup(groupType); keywordsRadioButton.setToggleGroup(groupType); searchRadioButton.setToggleGroup(groupType); autoRadioButton.setToggleGroup(groupType); texRadioButton.setToggleGroup(groupType);  // Build individual layout cards for each group VBox explicitPanel = createOptionsExplicitGroup(); explicitPanel.setVisible(true); VBox keywordPanel = createOptionsKeywordGroup(); VBox searchPanel = createOptionsSearchGroup(); VBox autoPanel = createOptionsAutoGroup(); VBox texPanel = createOptionsTexGroup(); optionsPanel.getChildren().addAll(explicitPanel, keywordPanel, searchPanel, autoPanel, texPanel); optionsPanel.setPadding(new Insets(0, 0, 0, 10));  // ... for buttons panel getDialogPane().getButtonTypes().setAll(ButtonType.OK, ButtonType.CANCEL);  // General information VBox contextPanel = new VBox(10); contextPanel.setPadding(new Insets(0, 0, 0, 10)); contextPanel.getChildren().setAll( independentButton, intersectionButton, unionButton ); ToggleGroup groupHierarchy = new ToggleGroup(); independentButton.setToggleGroup(groupHierarchy); intersectionButton.setToggleGroup(groupHierarchy); unionButton.setToggleGroup(groupHierarchy);  colorField.setMinHeight(20); VBox generalPanel = new VBox(10); generalPanel.getChildren().setAll( new VBox( new Label(Localization.lang("Name")), nameField ), new VBox( new Label(Localization.lang("Description")), descriptionField ), new HBox(30, new VBox( new Label(Localization.lang("Icon")), iconField ), new VBox( new Label(Localization.lang("Color")), colorField ) ), new VBox(5, new Label(Localization.lang("Hierarchical context")), contextPanel ) );  VBox selectPanel = new VBox(10, explicitRadioButton, keywordsRadioButton, searchRadioButton, autoRadioButton, texRadioButton ); selectPanel.setPadding(new Insets(0, 0, 0, 10));  // Description panel ScrollPane descriptionPane = new ScrollPane(descriptionTextFlow); descriptionPane.setHbarPolicy(ScrollBarPolicy.AS_NEEDED); descriptionPane.setVbarPolicy(ScrollBarPolicy.AS_NEEDED);  // create layout HBox mainPanel = new HBox(15); getDialogPane().setContent(mainPanel); mainPanel.setPadding(new Insets(5, 15, 5, 15)); mainPanel.getChildren().setAll( new VBox(5, generalPanel, new VBox(5, new Label(Localization.lang("Type")), selectPanel ) ), new Separator(Orientation.VERTICAL), new VBox(5, new VBox( new Label(Localization.lang("Options")), optionsPanel ), new Label(Localization.lang("Description")), descriptionPane ) );  updateComponents();  // add listeners groupType.selectedToggleProperty().addListener((ObservableValue<? extends Toggle> ov, Toggle old_Toggle, Toggle new_Toggle) -> { int select = INDEX_EXPLICIT_GROUP; if (groupType.getSelectedToggle() == explicitRadioButton) { select = INDEX_EXPLICIT_GROUP; } else if (groupType.getSelectedToggle() == keywordsRadioButton) { select = INDEX_KEYWORD_GROUP; } else if (groupType.getSelectedToggle() == searchRadioButton) { select = INDEX_SEARCH_GROUP; } else if (groupType.getSelectedToggle() == autoRadioButton) { select = INDEX_AUTO_GROUP; } else if (groupType.getSelectedToggle() == texRadioButton) { select = INDEX_TEX_GROUP; } for (Node n : optionsPanel.getChildren()) { n.setVisible(false); } optionsPanel.getChildren().get(select).setVisible(true); updateComponents(); });  setResultConverter(button -> { if (button == ButtonType.OK) { AbstractGroup resultingGroup = null; try { String groupName = nameField.getText().trim(); if (explicitRadioButton.isSelected()) { Character keywordDelimiter = Globals.prefs.getKeywordDelimiter(); if (groupName.contains(Character.toString(keywordDelimiter))) { dialogService.showWarningDialogAndWait(null, Localization.lang("The group name contains the keyword separator \"%0\" and thus probably does not work as expected.", Character.toString(keywordDelimiter))); }  Optional<GroupTreeNode> rootGroup = basePanel.getBibDatabaseContext().getMetaData().getGroups(); if (rootGroup.isPresent()) { int groupsWithSameName = rootGroup.get().findChildrenSatisfying(group -> group.getName().equals(groupName)).size(); boolean warnAboutSameName = false; if ((editedGroup == null) && (groupsWithSameName > 0)) { // New group but there is already one group with the same name warnAboutSameName = true; } if ((editedGroup != null) && !editedGroup.getName().equals(groupName) && (groupsWithSameName > 0)) { // Edit group, changed name to something that is already present warnAboutSameName = true; }  if (warnAboutSameName) { dialogService.showErrorDialogAndWait(Localization.lang("There exists already a group with the same name.", Character.toString(keywordDelimiter))); return null; } }  resultingGroup = new ExplicitGroup(groupName, getContext(), keywordDelimiter); } else if (keywordsRadioButton.isSelected()) { // regex is correct, otherwise OK would have been disabled // therefore I don't catch anything here if (keywordGroupRegExp.isSelected()) { resultingGroup = new RegexKeywordGroup(groupName, getContext(), FieldFactory.parseField(keywordGroupSearchField.getText().trim()), keywordGroupSearchTerm.getText().trim(), keywordGroupCaseSensitive.isSelected()); } else { resultingGroup = new WordKeywordGroup(groupName, getContext(), FieldFactory.parseField(keywordGroupSearchField.getText().trim()), keywordGroupSearchTerm.getText().trim(), keywordGroupCaseSensitive.isSelected(), Globals.prefs.getKeywordDelimiter(), false); } } else if (searchRadioButton.isSelected()) { resultingGroup = new SearchGroup(groupName, getContext(), searchGroupSearchExpression.getText().trim(), isCaseSensitive(), isRegex()); } else if (autoRadioButton.isSelected()) { if (autoGroupKeywordsOption.isSelected()) { resultingGroup = new AutomaticKeywordGroup( groupName, getContext(), FieldFactory.parseField(autoGroupKeywordsField.getText().trim()), autoGroupKeywordsDeliminator.getText().charAt(0), autoGroupKeywordsHierarchicalDeliminator.getText().charAt(0)); } else { resultingGroup = new AutomaticPersonsGroup(groupName, getContext(), FieldFactory.parseField(autoGroupPersonsField.getText().trim())); } } else if (texRadioButton.isSelected()) { resultingGroup = TexGroup.create(groupName, getContext(), Paths.get(texGroupFilePath.getText().trim()), new DefaultAuxParser(new BibDatabase()), Globals.getFileUpdateMonitor(), basePanel.getBibDatabaseContext().getMetaData()); }  resultingGroup.setColor(colorField.getValue()); resultingGroup.setDescription(descriptionField.getText()); resultingGroup.setIconName(iconField.getText()); return resultingGroup; } catch (IllegalArgumentException | IOException exception) { dialogService.showErrorDialogAndWait(exception.getLocalizedMessage(), exception); return null; } } return null; });  nameField.textProperty().addListener((observable, oldValue, newValue) -> updateComponents()); keywordGroupSearchTerm.textProperty().addListener((observable, oldValue, newValue) -> updateComponents()); searchGroupSearchExpression.textProperty().addListener((observable, oldValue, newValue) -> updateComponents());  EventHandler<ActionEvent> actionHandler = (ActionEvent e) -> updateComponents(); nameField.setOnAction(actionHandler); descriptionField.setOnAction(actionHandler); iconField.setOnAction(actionHandler); keywordGroupSearchField.setOnAction(actionHandler); keywordGroupSearchTerm.setOnAction(actionHandler); keywordGroupCaseSensitive.setOnAction(actionHandler); keywordGroupRegExp.setOnAction(actionHandler); searchGroupSearchExpression.setOnAction(actionHandler); searchGroupRegExp.setOnAction(actionHandler);  // configure for current type if (editedGroup == null) { // creating new group -> defaults! colorField.setValue(IconTheme.getDefaultGroupColor()); explicitRadioButton.setSelected(true); setContext(GroupHierarchyType.INDEPENDENT); } else { nameField.setText(editedGroup.getName()); colorField.setValue(editedGroup.getColor().orElse(IconTheme.getDefaultGroupColor())); descriptionField.setText(editedGroup.getDescription().orElse("")); iconField.setText(editedGroup.getIconName().orElse("")); setContext(editedGroup.getHierarchicalContext());  if (editedGroup.getClass() == WordKeywordGroup.class) { WordKeywordGroup group = (WordKeywordGroup) editedGroup; keywordGroupSearchField.setText(group.getSearchField().getName()); keywordGroupSearchTerm.setText(group.getSearchExpression()); keywordGroupCaseSensitive.setSelected(group.isCaseSensitive()); keywordGroupRegExp.setSelected(false); keywordsRadioButton.setSelected(true); } else if (editedGroup.getClass() == RegexKeywordGroup.class) { RegexKeywordGroup group = (RegexKeywordGroup) editedGroup; keywordGroupSearchField.setText(group.getSearchField().getName()); keywordGroupSearchTerm.setText(group.getSearchExpression()); keywordGroupCaseSensitive.setSelected(group.isCaseSensitive()); keywordGroupRegExp.setSelected(true); keywordsRadioButton.setSelected(true); } else if (editedGroup.getClass() == SearchGroup.class) { SearchGroup group = (SearchGroup) editedGroup; searchGroupSearchExpression.setText(group.getSearchExpression()); searchGroupCaseSensitive.setSelected(group.isCaseSensitive()); searchGroupRegExp.setSelected(group.isRegularExpression()); searchRadioButton.setSelected(true); } else if (editedGroup.getClass() == ExplicitGroup.class) { explicitRadioButton.setSelected(true); } else if (editedGroup instanceof AutomaticGroup) { autoRadioButton.setSelected(true);  if (editedGroup.getClass() == AutomaticKeywordGroup.class) { AutomaticKeywordGroup group = (AutomaticKeywordGroup) editedGroup; autoGroupKeywordsDeliminator.setText(group.getKeywordDelimiter().toString()); autoGroupKeywordsHierarchicalDeliminator.setText(group.getKeywordHierarchicalDelimiter().toString()); autoGroupKeywordsField.setText(group.getField().getName()); } else if (editedGroup.getClass() == AutomaticPersonsGroup.class) { AutomaticPersonsGroup group = (AutomaticPersonsGroup) editedGroup; autoGroupPersonsField.setText(group.getField().getName()); } } else if (editedGroup.getClass() == TexGroup.class) { texRadioButton.setSelected(true);  TexGroup group = (TexGroup) editedGroup; texGroupFilePath.setText(group.getFilePath().toString()); } } getDialogPane().getScene().getWindow().sizeToScene(); }  public GroupDialog(DialogService dialogService) { this(dialogService, JabRefGUI.getMainFrame().getCurrentBasePanel(), Globals.prefs, null); }  public GroupDialog(DialogService dialogService, AbstractGroup editedGroup) { this(dialogService, JabRefGUI.getMainFrame().getCurrentBasePanel(), Globals.prefs, editedGroup); }  private static String formatRegExException(String regExp, Exception e) { String[] sa = e.getMessage().split("\\n"); StringBuilder sb = new StringBuilder(); for (int i = 0; i < sa.length; ++i) { if (i > 0) { sb.append("<br>"); } sb.append(StringUtil.quoteForHTML(sa[i])); } String s = Localization.lang( "The regular expression <b>%0</b> is invalid:", StringUtil.quoteForHTML(regExp)) + "<p><tt>" + sb + "</tt>"; if (!(e instanceof PatternSyntaxException)) { return s; } int lastNewline = s.lastIndexOf("<br>"); int hat = s.lastIndexOf('^'); if ((lastNewline >= 0) && (hat >= 0) && (hat > lastNewline)) { return s.substring(0, lastNewline + 4) + s.substring(lastNewline + 4).replace(" ", "&nbsp;"); } return s; }  private VBox createOptionsTexGroup() { VBox texPanel = new VBox(); texPanel.setVisible(false); texPanel.getChildren().add(new Label(Localization.lang("Aux file"))); texGroupBrowseButton.setOnAction((ActionEvent e) -> openBrowseDialog()); texGroupHBox.getChildren().add(texGroupFilePath); texGroupHBox.getChildren().add(texGroupBrowseButton); HBox.setHgrow(texGroupFilePath, Priority.ALWAYS); texPanel.getChildren().add(texGroupHBox); return texPanel; }  private VBox createOptionsAutoGroup() { VBox autoPanel = new VBox(10); autoPanel.setVisible(false); ToggleGroup tg = new ToggleGroup(); autoGroupKeywordsOption.setToggleGroup(tg); autoGroupPersonsOption.setToggleGroup(tg); VBox fieldToGroupByKeywords = new VBox( new Label(Localization.lang("Field to group by") + ":"), autoGroupKeywordsField ); fieldToGroupByKeywords.setPadding(new Insets(0, 0, 0, 20)); VBox delimiterCharacters = new VBox( new Label(Localization.lang("Use the following delimiter character(s):")), new HBox(10, autoGroupKeywordsDeliminator, autoGroupKeywordsHierarchicalDeliminator ) ); delimiterCharacters.setPadding(new Insets(0, 0, 0, 20)); VBox fieldToGroupByPersons = new VBox( new Label(Localization.lang("Field to group by") + ":"), autoGroupPersonsField ); fieldToGroupByPersons.setPadding(new Insets(0, 0, 0, 20)); autoPanel.getChildren().setAll( autoGroupKeywordsOption, fieldToGroupByKeywords, delimiterCharacters, autoGroupPersonsOption, fieldToGroupByPersons ); autoGroupKeywordsOption.setSelected(true); autoGroupKeywordsField.setText(Globals.prefs.get(JabRefPreferences.GROUPS_DEFAULT_FIELD)); autoGroupKeywordsDeliminator.setText(Globals.prefs.get(JabRefPreferences.KEYWORD_SEPARATOR)); autoGroupKeywordsHierarchicalDeliminator.setText(Keyword.DEFAULT_HIERARCHICAL_DELIMITER.toString()); autoGroupPersonsField.setText(StandardField.AUTHOR.getName()); return autoPanel; }  private VBox createOptionsSearchGroup() { VBox searchPanel = new VBox(10); searchPanel.setVisible(false); searchPanel.getChildren().setAll( new VBox( new Label(Localization.lang("Search expression")), searchGroupSearchExpression ), searchGroupCaseSensitive, searchGroupRegExp ); return searchPanel; }  private VBox createOptionsExplicitGroup() { return new VBox(); }  private VBox createOptionsKeywordGroup() { VBox keywordPanel = new VBox(10); keywordPanel.setVisible(false); keywordPanel.getChildren().setAll( new VBox( new Label(Localization.lang("Field")), keywordGroupSearchField ), new VBox( new Label(Localization.lang("Keyword")), keywordGroupSearchTerm ), keywordGroupCaseSensitive, keywordGroupRegExp ); return keywordPanel; }  private void updateComponents() { // all groups need a name boolean okEnabled = !nameField.getText().trim().isEmpty(); if (!okEnabled) { setDescription(Localization.lang("Please enter a name for the group.")); getDialogPane().lookupButton(ButtonType.OK).setDisable(true); return; } String s1; String s2; if (keywordsRadioButton.isSelected()) { s1 = keywordGroupSearchField.getText().trim(); okEnabled = okEnabled && s1.matches("\\w+"); s2 = keywordGroupSearchTerm.getText().trim(); okEnabled = okEnabled && !s2.isEmpty(); if (okEnabled) { if (keywordGroupRegExp.isSelected()) { try { Pattern.compile(s2); setDescription(GroupDescriptions.getDescriptionForPreview(s1, s2, keywordGroupCaseSensitive.isSelected(), keywordGroupRegExp.isSelected())); } catch (PatternSyntaxException e) { okEnabled = false; setDescription(formatRegExException(s2, e)); } } else { setDescription(GroupDescriptions.getDescriptionForPreview(s1, s2, keywordGroupCaseSensitive.isSelected(), keywordGroupRegExp.isSelected())); } } else { setDescription(Localization.lang( "Please enter the field to search (e.g. <b>keywords</b>) and the keyword to search it for (e.g. <b>electrical</b>).")); } setNameFontItalic(true); } else if (searchRadioButton.isSelected()) { s1 = searchGroupSearchExpression.getText().trim(); okEnabled = okEnabled & !s1.isEmpty(); if (okEnabled) { setDescription(fromTextFlowToHTMLString(SearchDescribers.getSearchDescriberFor( new SearchQuery(s1, isCaseSensitive(), isRegex())) .getDescription()));  if (isRegex()) { try { Pattern.compile(s1); } catch (PatternSyntaxException e) { okEnabled = false; setDescription(formatRegExException(s1, e)); } } } else { setDescription(Localization .lang("Please enter a search term. For example, to search all fields for <b>Smith</b>, enter:<p>" + "<tt>smith</tt><p>" + "To search the field <b>Author</b> for <b>Smith</b> and the field <b>Title</b> for <b>electrical</b>, enter:<p>" + "<tt>author=smith and title=electrical</tt>")); } setNameFontItalic(true); } else if (explicitRadioButton.isSelected()) { setDescription(GroupDescriptions.getDescriptionForPreview()); setNameFontItalic(false); } getDialogPane().lookupButton(ButtonType.OK).setDisable(!okEnabled); }  private void openBrowseDialog() { FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder() .addExtensionFilter(StandardFileType.AUX) .withDefaultExtension(StandardFileType.AUX) .withInitialDirectory(Globals.prefs.get(JabRefPreferences.WORKING_DIRECTORY)).build(); dialogService.showFileOpenDialog(fileDialogConfiguration).ifPresent(file -> texGroupFilePath.setText(relativize(file.toAbsolutePath()).toString())); }  private Path relativize(Path path) { List<Path> fileDirectories = getFileDirectoriesAsPaths(); return FileUtil.relativize(path, fileDirectories); }  private List<Path> getFileDirectoriesAsPaths() { List<Path> fileDirs = new ArrayList<>(); MetaData metaData = basePanel.getBibDatabaseContext().getMetaData(); metaData.getLaTexFileDirectory(prefs.getFilePreferences().getUser()) .ifPresent(laTexFileDirectory -> fileDirs.add(laTexFileDirectory));  return fileDirs; }  private String fromTextFlowToHTMLString(TextFlow textFlow) { StringBuilder htmlStringBuilder = new StringBuilder(); for (Node node : textFlow.getChildren()) { if (node instanceof Text) { htmlStringBuilder.append(TooltipTextUtil.textToHTMLString((Text) node)); } } return htmlStringBuilder.toString(); }  private boolean isRegex() { return searchGroupRegExp.isSelected(); }  private boolean isCaseSensitive() { return searchGroupCaseSensitive.isSelected(); }  private void setDescription(String description) { descriptionTextFlow.getChildren().setAll(createFormattedDescription(description)); }  private ArrayList<Node> createFormattedDescription(String descriptionHTML) { ArrayList<Node> nodes = new ArrayList<>();  descriptionHTML = descriptionHTML.replaceAll("<p>|<br>", "\n");  String[] boldSplit = descriptionHTML.split("(?=<b>)|(?<=</b>)|(?=<i>)|(?<=</i>)|(?=<tt>)|(?<=</tt>)|(?=<kbd>)|(?<=</kbd>)");  for (String bs : boldSplit) {  if (bs.matches("<b>[^<>]*</b>")) {  bs = bs.replaceAll("<b>|</b>", ""); Text textElement = new Text(bs); textElement.setStyle("-fx-font-weight: bold"); nodes.add(textElement); } else if (bs.matches("<i>[^<>]*</i>")) {  bs = bs.replaceAll("<i>|</i>", ""); Text textElement = new Text(bs); textElement.setStyle("-fx-font-style: italic"); nodes.add(textElement); } else if (bs.matches("<tt>[^<>]*</tt>|<kbd>[^<>]*</kbd>")) {  bs = bs.replaceAll("<tt>|</tt>|<kbd>|</kbd>", ""); Text textElement = new Text(bs); textElement.setStyle("-fx-font-family: 'Courier New', Courier, monospace"); nodes.add(textElement); } else { nodes.add(new Text(bs)); } }  return nodes; }  /** * Sets the font of the name entry field. */ private void setNameFontItalic(boolean italic) { Font f = nameField.getFont(); if (italic) { Font.font(f.getFamily(), FontPosture.ITALIC, f.getSize()); } else { Font.font(f.getFamily(), FontPosture.REGULAR, f.getSize()); } }  /** * Returns the int representing the selected hierarchical group context. */ private GroupHierarchyType getContext() { if (independentButton.isSelected()) { return GroupHierarchyType.INDEPENDENT; } if (intersectionButton.isSelected()) { return GroupHierarchyType.REFINING; } if (unionButton.isSelected()) { return GroupHierarchyType.INCLUDING; } return GroupHierarchyType.INDEPENDENT; // default }  private void setContext(GroupHierarchyType context) { switch (context) { case INDEPENDENT: independentButton.setSelected(true); break; case REFINING: intersectionButton.setSelected(true); break; case INCLUDING: unionButton.setSelected(true); break; } } }"



"public class GroupSidePane extends SidePaneComponent {  private final JabRefPreferences preferences; private final DialogService dialogService; private final Button intersectionUnionToggle = IconTheme.JabRefIcons.GROUP_INTERSECTION.asButton();  public GroupSidePane(SidePaneManager manager, JabRefPreferences preferences, DialogService dialogService) { super(manager, IconTheme.JabRefIcons.TOGGLE_GROUPS, Localization.lang("Groups")); this.preferences = preferences; this.dialogService = dialogService; }  @Override protected List<Node> getAdditionalHeaderButtons() { intersectionUnionToggle.setOnAction(event -> toggleUnionIntersection()); return Collections.singletonList(intersectionUnionToggle); }  @Override public void afterOpening() { preferences.putBoolean(JabRefPreferences.GROUP_SIDEPANE_VISIBLE, Boolean.TRUE); setGraphicsAndTooltipForButton(preferences.getGroupViewMode()); }  @Override public Priority getResizePolicy() { return Priority.ALWAYS; }  @Override public void beforeClosing() { preferences.putBoolean(JabRefPreferences.GROUP_SIDEPANE_VISIBLE, Boolean.FALSE); }  @Override public Action getToggleAction() { return StandardActions.TOGGLE_GROUPS; }  private void toggleUnionIntersection() { GroupViewMode mode = preferences.getGroupViewMode();  if (mode == GroupViewMode.UNION) { preferences.setGroupViewMode(GroupViewMode.INTERSECTION); dialogService.notify(Localization.lang("Group view mode set to intersection")); } else if (mode == GroupViewMode.INTERSECTION) { preferences.setGroupViewMode(GroupViewMode.UNION); dialogService.notify(Localization.lang("Group view mode set to union")); }  setGraphicsAndTooltipForButton(mode); }  private void setGraphicsAndTooltipForButton(GroupViewMode mode) { GroupModeViewModel modeViewModel = new GroupModeViewModel(mode); intersectionUnionToggle.setGraphic(modeViewModel.getUnionIntersectionGraphic()); intersectionUnionToggle.setTooltip(modeViewModel.getUnionIntersectionTooltip()); }  @Override protected Node createContentPane() { return ViewLoader.view(GroupTreeView.class) .load() .getView(); }  @Override public SidePaneType getType() { return SidePaneType.GROUPS; } }"




"private static final Set<String> AVAILABLE_LANG_FILES = Stream.of("en", "de", "fr", "in", "ja")"

"public class ErrorConsoleAction extends SimpleCommand {  @Override public void execute() { new ErrorConsoleView().show(); }  }"














"boolean isActionNecessary(ParserResult pr);"
"public void openFile(Path file, boolean raisePanel) { List<Path> filesToOpen = new ArrayList<>(); filesToOpen.add(file); openFiles(filesToOpen, raisePanel); }"



"public class AbbreviateAction implements BaseAction {  private static final Logger LOGGER = LoggerFactory.getLogger(AbbreviateAction.class); private final BasePanel panel; private final boolean iso;  public AbbreviateAction(BasePanel panel, boolean iso) { this.panel = panel; this.iso = iso; }  @Override public void action() { panel.output(Localization.lang("Abbreviating...")); BackgroundTask.wrap(this::abbreviate) .onSuccess(panel::output) .executeWith(Globals.TASK_EXECUTOR);  }  private String abbreviate() { List<BibEntry> entries = panel.getSelectedEntries(); UndoableAbbreviator undoableAbbreviator = new UndoableAbbreviator( Globals.journalAbbreviationLoader.getRepository(Globals.prefs.getJournalAbbreviationPreferences()), iso);  NamedCompound ce = new NamedCompound(Localization.lang("Abbreviate journal names")); Set<Callable<Boolean>> tasks = new HashSet<>();  // Collect all callables to execute in one collection. for (BibEntry entry : entries) { Callable<Boolean> callable = () -> { for (Field journalField : FieldFactory.getJournalNameFields()) { if (undoableAbbreviator.abbreviate(panel.getDatabase(), entry, journalField, ce)) { return true; } } return false; }; tasks.add(callable); }  // Execute the callables and wait for the results. List<Future<Boolean>> futures = JabRefExecutorService.INSTANCE.executeAll(tasks);  // Evaluate the results of the callables. long count = futures.stream().filter(future -> { try { return future.get(); } catch (InterruptedException | ExecutionException exception) { LOGGER.error("Unable to retrieve value.", exception); return false; } }).count();  if (count > 0) { ce.end(); panel.getUndoManager().addEdit(ce); panel.markBaseChanged(); return Localization.lang("Abbreviated %0 journal names.", String.valueOf(count)); } else { return Localization.lang("No journal names could be abbreviated."); } } }"
"public class UnabbreviateAction implements BaseAction {  private final BasePanel panel;  public UnabbreviateAction(BasePanel panel) { this.panel = panel; }  @Override public void action() { panel.output(Localization.lang("Unabbreviating...")); BackgroundTask.wrap(this::unabbreviate) .onSuccess(panel::output) .executeWith(Globals.TASK_EXECUTOR); }  private String unabbreviate() { List<BibEntry> entries = panel.getSelectedEntries(); // never null  UndoableUnabbreviator undoableAbbreviator = new UndoableUnabbreviator(Globals.journalAbbreviationLoader .getRepository(Globals.prefs.getJournalAbbreviationPreferences()));  NamedCompound ce = new NamedCompound(Localization.lang("Unabbreviate journal names")); int count = 0; for (BibEntry entry : entries) { for (Field journalField : FieldFactory.getJournalNameFields()) { if (undoableAbbreviator.unabbreviate(panel.getDatabase(), entry, journalField, ce)) { count++; } } } if (count > 0) { ce.end(); panel.getUndoManager().addEdit(ce); panel.markBaseChanged(); return Localization.lang("Unabbreviated %0 journal names.", String.valueOf(count)); } else { return Localization.lang("No journal names could be unabbreviated."); } } }"

"public class JournalAbbreviationsAbbreviationTableEditingCell extends TableCell<AbbreviationViewModel, String> {  private TextField textField; private String oldAbbreviation; private int editingIndex;  @Override public void startEdit() { if (!isEmpty() && viewModel.isAbbreviationEditableAndRemovableProperty().get()) { oldAbbreviation = viewModel.currentAbbreviationProperty().get().getAbbreviation(); super.startEdit(); createTextField(); setText(null); setGraphic(textField); editingIndex = journalAbbreviationsTable.getSelectionModel().getSelectedIndex(); textField.requestFocus(); textField.selectAll(); } }  @Override public void cancelEdit() { super.cancelEdit(); setText(getItem()); setGraphic(null); journalAbbreviationsTable.itemsProperty().get().get(editingIndex).setAbbreviation(oldAbbreviation); }  @Override public void updateItem(String item, boolean empty) { super.updateItem(item, empty); if (empty) { setText(null); setGraphic(null); } else { if (isEditing()) { if (textField != null) { textField.setText(getString()); } setText(null); setGraphic(textField); } else { setText(getString()); setGraphic(null); } } }  @Override public void commitEdit(String abbreviation) { journalAbbreviationsTable.getSelectionModel().select(editingIndex); AbbreviationViewModel current = viewModel.currentAbbreviationProperty().get(); super.commitEdit(abbreviation); current.setAbbreviation(oldAbbreviation); viewModel.editAbbreviation(current.getName(), abbreviation); }  private void createTextField() { textField = new TextField(getString()); textField.setMinWidth(this.getWidth() - (this.getGraphicTextGap() * 2)); textField.focusedProperty().addListener((observable, oldValue, newValue) -> { if (!newValue) { commitEdit(textField.getText()); } }); textField.setOnKeyPressed(t -> { if (t.getCode() == KeyCode.ENTER) { if (isEditing()) { journalAbbreviationsTable.requestFocus(); } else { startEdit(); } } else if (t.getCode() == KeyCode.ESCAPE) { cancelEdit(); } }); }  private String getString() { return getItem() == null ? "" : getItem(); } }"
"public boolean unabbreviate(BibDatabase database, BibEntry entry, Field field, CompoundEdit ce) { if (!entry.hasField(field)) { return false; } String text = entry.getField(field).get(); String origText = text; if (database != null) { text = database.resolveForStrings(text); }  if (!journalAbbreviationRepository.isKnownName(text)) { return false; // cannot do anything if it is not known }  if (!journalAbbreviationRepository.isAbbreviatedName(text)) { return false; // cannot unabbreviate unabbreviated name. }  Abbreviation abbreviation = journalAbbreviationRepository.getAbbreviation(text).get(); // must be here String newText = abbreviation.getName(); entry.setField(field, newText); ce.addEdit(new UndoableFieldChange(entry, field, origText, newText)); return true; }"





